From 0fedc35c20c4425831358b11c7440b9a02a17bfa Mon Sep 17 00:00:00 2001
From: Tejas Patil <tejaspp@amiindia.co.in>
Date: Fri, 26 Feb 2021 10:28:24 +0000
Subject: [PATCH 21/21] char-ipmi-Add-clock-control-logic-into-Aspeed-LPC-KC

---
 .../bindings/ipmi/aspeed-kcs-bmc.txt          |  3 ++
 arch/arm/boot/dts/aspeed-g5.dtsi              |  5 ++-
 drivers/char/ipmi/kcs_bmc_aspeed.c            | 38 +++++++++++++++----
 3 files changed, 37 insertions(+), 9 deletions(-)

diff --git a/Documentation/devicetree/bindings/ipmi/aspeed-kcs-bmc.txt b/Documentation/devicetree/bindings/ipmi/aspeed-kcs-bmc.txt
index d98a9bf45..7e0cd0890 100644
--- a/Documentation/devicetree/bindings/ipmi/aspeed-kcs-bmc.txt
+++ b/Documentation/devicetree/bindings/ipmi/aspeed-kcs-bmc.txt
@@ -9,6 +9,8 @@ Required properties:
     "aspeed,ast2400-kcs-bmc"
     "aspeed,ast2500-kcs-bmc"
 - interrupts : interrupt generated by the controller
+- clocks: contains a phandle to the syscon node describing the clocks.
+	  There should then be one cell representing the clock to use.
 - kcs_chan : The LPC channel number in the controller
 - kcs_addr : The host CPU IO map address
 
@@ -19,6 +21,7 @@ Example:
         compatible = "aspeed,ast2500-kcs-bmc";
         reg = <0x0 0x80>;
         interrupts = <8>;
+	clocks = <&syscon ASPEED_CLK_GATE_LCLK>;
         kcs_chan = <3>;
         kcs_addr = <0xCA2>;
         status = "okay";
diff --git a/arch/arm/boot/dts/aspeed-g5.dtsi b/arch/arm/boot/dts/aspeed-g5.dtsi
index bf6f297d2..4b43e0647 100644
--- a/arch/arm/boot/dts/aspeed-g5.dtsi
+++ b/arch/arm/boot/dts/aspeed-g5.dtsi
@@ -135,7 +135,7 @@
 		};
 
 		vic: interrupt-controller@1e6c0080 {
-			compatible = "aspeed,ast2400-vic";
+			compatible = "aspeed,ast2500-vic";
 			interrupt-controller;
 			#interrupt-cells = <1>;
 			valid-sources = <0xfefff7ff 0x0807ffff>;
@@ -493,18 +493,21 @@
 						compatible = "aspeed,ast2500-kcs-bmc";
 						interrupts = <8>;
 						kcs_chan = <1>;
+						clocks = <&syscon ASPEED_CLK_GATE_LCLK>;
 						status = "disabled";
 					};
 					kcs2: kcs2@0 {
 						compatible = "aspeed,ast2500-kcs-bmc";
 						interrupts = <8>;
 						kcs_chan = <2>;
+						clocks = <&syscon ASPEED_CLK_GATE_LCLK>;
 						status = "disabled";
 					};
 					kcs3: kcs3@0 {
 						compatible = "aspeed,ast2500-kcs-bmc";
 						interrupts = <8>;
 						kcs_chan = <3>;
+						clocks = <&syscon ASPEED_CLK_GATE_LCLK>;
 						status = "disabled";
 					};
 				};
diff --git a/drivers/char/ipmi/kcs_bmc_aspeed.c b/drivers/char/ipmi/kcs_bmc_aspeed.c
index a0a8bb89c..3c44f0934 100644
--- a/drivers/char/ipmi/kcs_bmc_aspeed.c
+++ b/drivers/char/ipmi/kcs_bmc_aspeed.c
@@ -1,11 +1,9 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2015-2018, Intel Corporation.
- */
+// Copyright (c) 2015-2019, Intel Corporation.
 
 #define pr_fmt(fmt) "aspeed-kcs-bmc: " fmt
 
 #include <linux/atomic.h>
+#include <linux/clk.h>
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
@@ -63,6 +61,7 @@
 
 struct aspeed_kcs_bmc {
 	struct regmap *map;
+	struct clk    *clk;
 };
 
 
@@ -264,36 +263,59 @@ static int aspeed_kcs_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
+	priv->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		rc = PTR_ERR(priv->clk);
+		if (rc != -EPROBE_DEFER)
+			dev_err(dev, "couldn't get clock\n");
+		return rc;
+	}
+	rc = clk_prepare_enable(priv->clk);
+	if (rc) {
+		dev_err(dev, "couldn't enable clock\n");
+		return rc;
+	}
+	
 	kcs_bmc->ioreg = ast_kcs_bmc_ioregs[chan - 1];
 	kcs_bmc->io_inputb = aspeed_kcs_inb;
 	kcs_bmc->io_outputb = aspeed_kcs_outb;
 
 	dev_set_drvdata(dev, kcs_bmc);
 
-	aspeed_kcs_set_address(kcs_bmc, addr);
-	aspeed_kcs_enable_channel(kcs_bmc, true);
 	rc = aspeed_kcs_config_irq(kcs_bmc, pdev);
 	if (rc)
-		return rc;
+		goto err;
 
 	rc = misc_register(&kcs_bmc->miscdev);
 	if (rc) {
 		dev_err(dev, "Unable to register device\n");
-		return rc;
+		goto err;
 	}
 
+	aspeed_kcs_set_address(kcs_bmc, addr);
+	aspeed_kcs_enable_channel(kcs_bmc, true);
+	
 	pr_info("channel=%u addr=0x%x idr=0x%x odr=0x%x str=0x%x\n",
 		chan, addr,
 		kcs_bmc->ioreg.idr, kcs_bmc->ioreg.odr, kcs_bmc->ioreg.str);
 
 	return 0;
+
+err:
+	aspeed_kcs_enable_channel(kcs_bmc, false);
+	clk_disable_unprepare(priv->clk);
+
+	return rc;	
 }
 
 static int aspeed_kcs_remove(struct platform_device *pdev)
 {
 	struct kcs_bmc *kcs_bmc = dev_get_drvdata(&pdev->dev);
+	struct aspeed_kcs_bmc *priv = kcs_bmc_priv(kcs_bmc);
 
 	misc_deregister(&kcs_bmc->miscdev);
+	aspeed_kcs_enable_channel(kcs_bmc, false);
+	clk_disable_unprepare(priv->clk);	
 
 	return 0;
 }
-- 
2.17.1

