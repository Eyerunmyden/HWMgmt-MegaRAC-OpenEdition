From 262c8dcbba03108d45ad3624b308c8b863bd3958 Mon Sep 17 00:00:00 2001
From: ThuBaNguyen <thu@os.amperecomputing.com>
Date: Sat, 24 Apr 2021 21:40:05 +0700
Subject: [PATCH] AmpereSoc: Add AmpereSoC daemon to public AmpereSoC dbus
 object

Ampere SoC devices are complicated. They need new daemon to handle their
sensors, events and errors. This commit add AmpereSoC class for that purpose.
In this first commit, AmpereSoC class will only support parsing the sensors in
entity manager configuration file and creating the sensors in dbus object.

Below is some info about Ampere SoC daemon:

1. It is named as xyz.openbmc_project.socsensor.service.
2. It supportes device type is "smpro_hwmon".
3. It publics the sensors to xyz.openbmc_project.SoCSensor dbus object.

Tested:
	1. Add Ampere Soc configuration in entity-manger.
	2. Power on the host.
	3. Call "busctr tree xyz.openbmc_project.SoCSensor" to list
	   the host sensors.

Signed-off-by: ThuBaNguyen <thu@os.amperecomputing.com>

%% original patch: 0007-AmpereSoc-Add-AmpereSoC-daemon-to-public-AmpereSoC-d.patch

%% original patch: 0007-AmpereSoc-Add-AmpereSoC-daemon-to-public-AmpereSoC-d.patch
---
 include/AmpereSoC.hpp                         |  59 ++
 meson_options.txt                             |   1 +
 service_files/meson.build                     |   1 +
 .../xyz.openbmc_project.adcsensor.service     |   1 +
 .../xyz.openbmc_project.socsensor.service     |  15 +
 src/AmpereSoC.cpp                             | 219 +++++
 src/AmpereSoCMain.cpp                         | 865 ++++++++++++++++++
 src/meson.build                               |  20 +
 8 files changed, 1181 insertions(+)
 create mode 100644 include/AmpereSoC.hpp
 create mode 100644 service_files/xyz.openbmc_project.socsensor.service
 create mode 100644 src/AmpereSoC.cpp
 create mode 100644 src/AmpereSoCMain.cpp

diff --git a/include/AmpereSoC.hpp b/include/AmpereSoC.hpp
new file mode 100644
index 0000000..c799b4a
--- /dev/null
+++ b/include/AmpereSoC.hpp
@@ -0,0 +1,59 @@
+#pragma once
+
+#include <PwmSensor.hpp>
+#include <Thresholds.hpp>
+#include <boost/asio/streambuf.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <sensor.hpp>
+
+#include <memory>
+#include <string>
+#include <utility>
+
+class SoCSensor : public Sensor, public std::enable_shared_from_this<SoCSensor>
+{
+  public:
+    SoCSensor(const std::string& path, const std::string& objectType,
+              sdbusplus::asio::object_server& objectServer,
+              std::shared_ptr<sdbusplus::asio::connection>& conn,
+              boost::asio::io_service& io, const std::string& sensorName,
+              std::vector<thresholds::Threshold>&& thresholds,
+              const std::string& sensorConfiguration,
+              std::string& sensorTypeName, unsigned int factor, double max,
+              double min, const std::string& label, size_t tSize);
+    ~SoCSensor() override;
+    void setupRead(void);
+
+  private:
+    sdbusplus::asio::object_server& objServer;
+    boost::asio::posix::stream_descriptor inputDev;
+    boost::asio::deadline_timer waitTimer;
+    std::shared_ptr<boost::asio::streambuf> readBuf;
+    std::string path;
+    std::string pathRatedMax;
+    std::string pathRatedMin;
+    unsigned int sensorFactor;
+    uint8_t minMaxReadCounter;
+    void handleResponse(const boost::system::error_code& err);
+    void checkThresholds(void) override;
+    void updateMinMaxValues(void);
+
+    int fd;
+    static constexpr unsigned int sensorPollMs = 1000;
+    static constexpr size_t warnAfterErrorCount = 10;
+};
+
+class SoCProperty
+{
+  public:
+    SoCProperty(std::string name, double max, double min, unsigned int factor) :
+        labelTypeName(std::move(name)), maxReading(max), minReading(min),
+        sensorScaleFactor(factor)
+    {}
+    ~SoCProperty() = default;
+
+    std::string labelTypeName;
+    double maxReading;
+    double minReading;
+    unsigned int sensorScaleFactor;
+};
diff --git a/meson_options.txt b/meson_options.txt
index 918d206..7912a69 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -8,5 +8,6 @@ option('ipmb', type: 'feature', value: 'enabled', description: 'Enable IPMB sens
 option('mcu', type: 'feature', value: 'enabled', description: 'Enable MCU sensor.',)
 option('nvme', type: 'feature', value: 'disabled', description: 'Enable NVMe sensor.',)
 option('psu', type: 'feature', value: 'enabled', description: 'Enable PSU sensor.',)
+option('soc', type: 'feature', value: 'enabled', description: 'Enable SOC sensor.',)
 option('external', type: 'feature', value: 'enabled', description: 'Enable External sensor.',)
 option('tests', type: 'feature', description: 'Build tests.',)
diff --git a/service_files/meson.build b/service_files/meson.build
index 37bb261..4218aef 100644
--- a/service_files/meson.build
+++ b/service_files/meson.build
@@ -9,6 +9,7 @@ unit_files = [
     ['mcu', 'xyz.openbmc_project.mcutempsensor.service'],
     ['nvme', 'xyz.openbmc_project.nvmesensor.service'],
     ['psu', 'xyz.openbmc_project.psusensor.service'],
+    ['soc', 'xyz.openbmc_project.socsensor.service'],
     ['external', 'xyz.openbmc_project.externalsensor.service'],
 ]
 
diff --git a/service_files/xyz.openbmc_project.adcsensor.service b/service_files/xyz.openbmc_project.adcsensor.service
index 6ca7049..2780c31 100644
--- a/service_files/xyz.openbmc_project.adcsensor.service
+++ b/service_files/xyz.openbmc_project.adcsensor.service
@@ -2,6 +2,7 @@
 Description=Adc Sensor
 StopWhenUnneeded=false
 Before=xyz.openbmc_project.cpusensor.service
+Before=xyz.openbmc_project.socsensor.service
 Requires=xyz.openbmc_project.EntityManager.service
 After=xyz.openbmc_project.EntityManager.service
 
diff --git a/service_files/xyz.openbmc_project.socsensor.service b/service_files/xyz.openbmc_project.socsensor.service
new file mode 100644
index 0000000..b7be086
--- /dev/null
+++ b/service_files/xyz.openbmc_project.socsensor.service
@@ -0,0 +1,15 @@
+[Unit]
+Description=SoC Sensor
+StopWhenUnneeded=false
+Requires=xyz.openbmc_project.EntityManager.service
+After=xyz.openbmc_project.EntityManager.service
+Wants=xyz.openbmc_project.State.Host.service
+After=xyz.openbmc_project.State.Host.service
+
+[Service]
+Restart=always
+RestartSec=5
+ExecStart=/usr/bin/socsensor
+
+[Install]
+WantedBy=multi-user.target
diff --git a/src/AmpereSoC.cpp b/src/AmpereSoC.cpp
new file mode 100644
index 0000000..eb58eff
--- /dev/null
+++ b/src/AmpereSoC.cpp
@@ -0,0 +1,219 @@
+/*
+// Copyright 2021 Ampere Computing LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include <unistd.h>
+
+#include <AmpereSoC.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/asio/read_until.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+
+#include <iostream>
+#include <istream>
+#include <limits>
+#include <memory>
+#include <string>
+#include <vector>
+
+static constexpr const char* sensorPathPrefix = "/xyz/openbmc_project/sensors/";
+static constexpr unsigned int sensorScaleFactor = 1000;
+static constexpr double roundFactor = 10000;     // 3 decimal places
+
+static constexpr bool debug = false;
+
+SoCSensor::SoCSensor(const std::string& path, const std::string& objectType,
+                     sdbusplus::asio::object_server& objectServer,
+                     std::shared_ptr<sdbusplus::asio::connection>& conn,
+                     boost::asio::io_service& io, const std::string& sensorName,
+                     std::vector<thresholds::Threshold>&& thresholdsIn,
+                     const std::string& sensorConfiguration,
+                     std::string& sensorTypeName, unsigned int factor,
+                     double max, double min, const std::string& label,
+                     size_t tSize) :
+    Sensor(boost::replace_all_copy(sensorName, " ", "_"),
+           std::move(thresholdsIn), sensorConfiguration, objectType, max, min,
+           conn),
+    std::enable_shared_from_this<SoCSensor>(), objServer(objectServer),
+    inputDev(io), waitTimer(io), path(path), pathRatedMax(""), pathRatedMin(""),
+    sensorFactor(factor), minMaxReadCounter(0)
+{
+    if constexpr (debug)
+    {
+        std::cerr << "Constructed sensor: path " << path << " type "
+                  << objectType << " config " << sensorConfiguration
+                  << " typename " << sensorTypeName << " factor " << factor
+                  << " min " << min << " max " << max << " name \""
+                  << sensorName << "\"\n";
+    }
+
+    fd = open(path.c_str(), O_RDONLY);
+    if (fd < 0)
+    {
+        std::cerr << "SOC sensor failed to open file\n";
+        return;
+    }
+    inputDev.assign(fd);
+
+    std::string dbusPath = sensorPathPrefix + sensorTypeName + name;
+
+    sensorInterface = objectServer.add_interface(
+        dbusPath, "xyz.openbmc_project.Sensor.Value");
+
+    if (thresholds::hasWarningInterface(thresholds))
+    {
+        thresholdInterfaceWarning = objectServer.add_interface(
+            dbusPath, "xyz.openbmc_project.Sensor.Threshold.Warning");
+    }
+    if (thresholds::hasCriticalInterface(thresholds))
+    {
+        thresholdInterfaceCritical = objectServer.add_interface(
+            dbusPath, "xyz.openbmc_project.Sensor.Threshold.Critical");
+    }
+
+    // This should be called before initializing association.
+    // createInventoryAssoc() does add more associations before doing
+    // register and initialize "Associations" property.
+    if (label.empty() || tSize == thresholds.size())
+    {
+        setInitialProperties(conn);
+    }
+    else
+    {
+        setInitialProperties(conn, label, tSize);
+    }
+
+    association = objectServer.add_interface(dbusPath, association::interface);
+
+    createInventoryAssoc(conn, association, configurationPath);
+
+    if (auto fileParts = splitFileName(path))
+    {
+        auto& [type, nr, item] = *fileParts;
+        if (item.compare("input") == 0)
+        {
+            pathRatedMax = boost::replace_all_copy(path, item, "rated_max");
+            pathRatedMin = boost::replace_all_copy(path, item, "rated_min");
+        }
+    }
+    if constexpr (debug)
+    {
+        std::cerr << "File: " << pathRatedMax
+                  << " will be used to update MaxValue\n";
+        std::cerr << "File: " << pathRatedMin
+                  << " will be used to update MinValue\n";
+    }
+}
+
+SoCSensor::~SoCSensor()
+{
+    waitTimer.cancel();
+    inputDev.close();
+    objServer.remove_interface(sensorInterface);
+    objServer.remove_interface(thresholdInterfaceWarning);
+    objServer.remove_interface(thresholdInterfaceCritical);
+    objServer.remove_interface(association);
+}
+
+void SoCSensor::setupRead(void)
+{
+    std::shared_ptr<boost::asio::streambuf> buffer =
+        std::make_shared<boost::asio::streambuf>();
+    std::weak_ptr<SoCSensor> weakRef = weak_from_this();
+    boost::asio::async_read_until(
+        inputDev, *buffer, '\n',
+        [weakRef, buffer](const boost::system::error_code& ec,
+                          std::size_t /*bytes_transfered*/) {
+            std::shared_ptr<SoCSensor> self = weakRef.lock();
+            if (self)
+            {
+                self->readBuf = buffer;
+                self->handleResponse(ec);
+            }
+        });
+}
+
+void SoCSensor::updateMinMaxValues(void)
+{
+    if (auto newVal = readFile(pathRatedMin, sensorFactor))
+    {
+        updateProperty(sensorInterface, minValue, *newVal, "MinValue");
+    }
+
+    if (auto newVal = readFile(pathRatedMax, sensorFactor))
+    {
+        updateProperty(sensorInterface, maxValue, *newVal, "MaxValue");
+    }
+}
+
+void SoCSensor::handleResponse(const boost::system::error_code& err)
+{
+    if (!err)
+    {
+        std::string response;
+        try
+        {
+            std::istream responseStream(readBuf.get());
+            std::getline(responseStream, response);
+            rawValue = std::stod(response);
+            responseStream.clear();
+            double nvalue = (rawValue / sensorScaleFactor) / sensorFactor;
+            nvalue = std::round(nvalue * roundFactor) / roundFactor;
+
+            updateValue(nvalue);
+
+            if (minMaxReadCounter++ % 8 == 0)
+            {
+                updateMinMaxValues();
+            }
+        }
+        catch (const std::invalid_argument&)
+        {
+            std::cerr << "Could not parse " << response << "\n";
+        }
+    }
+    std::weak_ptr<SoCSensor> weakRef = weak_from_this();
+    int fd = open(path.c_str(), O_RDONLY);
+    if (fd < 0)
+    {
+        updateValue(std::numeric_limits<double>::quiet_NaN());
+    }
+    else
+    {
+        inputDev.close();
+        inputDev.assign(fd);
+    }
+    waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
+    waitTimer.async_wait([weakRef](const boost::system::error_code& ec) {
+        std::shared_ptr<SoCSensor> self = weakRef.lock();
+        if (ec == boost::asio::error::operation_aborted)
+        {
+            std::cerr << "Failed to reschedule\n";
+            return;
+        }
+        if (self)
+        {
+            self->setupRead();
+        }
+    });
+}
+
+void SoCSensor::checkThresholds(void)
+{
+    thresholds::checkThresholds(this);
+}
diff --git a/src/AmpereSoCMain.cpp b/src/AmpereSoCMain.cpp
new file mode 100644
index 0000000..d744fe9
--- /dev/null
+++ b/src/AmpereSoCMain.cpp
@@ -0,0 +1,865 @@
+/*
+// Copyright 2021 Ampere Computing LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include <AmpereSoC.hpp>
+#include <Utils.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_map.hpp>
+#include <boost/container/flat_set.hpp>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <sdbusplus/bus/match.hpp>
+
+#include <array>
+#include <cmath>
+#include <filesystem>
+#include <fstream>
+#include <functional>
+#include <iostream>
+#include <regex>
+#include <string>
+#include <string_view>
+#include <utility>
+#include <variant>
+#include <vector>
+
+static constexpr bool debug = false;
+
+static constexpr std::array<const char*, 1> sensorTypes = {
+    "xyz.openbmc_project.Configuration.smpro_hwmon"};
+
+static std::vector<std::string> busNames = {"smpro_hwmon"};
+
+namespace fs = std::filesystem;
+
+static boost::container::flat_map<std::string, std::shared_ptr<SoCSensor>>
+    sensors;
+static boost::container::flat_map<std::string, std::string> sensorTable;
+static boost::container::flat_map<std::string, SoCProperty> propMatch;
+static boost::container::flat_map<std::string, int> numSocSensors;
+
+static std::vector<SoCProperty> socProperties;
+static std::regex i2cDevRegex(R"((\d+)-([a-fA-F0-9]+))");
+
+bool removeAllSensors(void)
+{
+    std::vector<std::string> addedSensors;
+    if (sensors.size() == 0)
+    {
+        return false;
+    }
+
+    for (auto& sensor : sensors)
+    {
+        addedSensors.push_back(sensor.first);
+    }
+
+    for(std::string name : addedSensors)
+    {
+        if (sensors.find(name) == sensors.end())
+        {
+            continue;
+        }
+        sensors.erase(name);
+    }
+    return true;
+}
+
+bool getDeviceInfo(std::string devPath, size_t* bus, size_t* addr)
+{
+    std::smatch match;
+    std::regex_search(devPath, match, i2cDevRegex);
+
+    if (match.empty() || (match.size() != 3))
+    {
+        std::cerr << "found bad device path " << devPath << "\n";
+        return false;
+    }
+
+    std::string busStr = match[1];
+    std::string addrStr = match[2];
+
+    try
+    {
+        *bus = (size_t)std::stoi(busStr);
+        *addr = (size_t)std::stoi(addrStr, nullptr, 16);
+    }
+    catch (std::invalid_argument&)
+    {
+        std::cerr << "Error parsing bus " << busStr << " addr " << addrStr
+                    << "\n";
+        return false;
+    }
+
+    return true;
+}
+
+bool findMatchConfig(const ManagedObjectType& sensorConfigs,
+                     std::pair<std::string, boost::container::flat_map<
+                               std::string, BasicVariantType>>* baseConfig,
+                     SensorData* sensorData, std::string* interfacePath,
+                     std::string* sensorType, size_t* thresholdConfSize,
+                     size_t bus, size_t addr, std::string deviceName,
+                     std::string* socName)
+{
+    bool isMatch = false;
+
+    for (const std::pair<sdbusplus::message::object_path, SensorData>&
+                sensor : sensorConfigs)
+    {
+        *sensorData = sensor.second;
+        for (const char* type : sensorTypes)
+        {
+            auto sensorBase = sensorData->find(type);
+            if (sensorBase != sensorData->end())
+            {
+                *baseConfig = *sensorBase;
+                *sensorType = type;
+                break;
+            }
+        }
+        if (baseConfig == nullptr)
+        {
+            std::cerr << "error finding base configuration for " <<
+                deviceName << " Type " << *sensorType << "\n";
+            continue;
+        }
+
+        auto configBus = baseConfig->second.find("Bus");
+        auto configAddress = baseConfig->second.find("Address");
+
+        if (configBus == baseConfig->second.end() ||
+            configAddress == baseConfig->second.end())
+        {
+            std::cerr << "error finding necessary entry in configuration\n";
+            continue;
+        }
+
+        const uint64_t* confBus;
+        const uint64_t* confAddr;
+        if (!(confBus = std::get_if<uint64_t>(&(configBus->second))) ||
+            !(confAddr = std::get_if<uint64_t>(&(configAddress->second))))
+        {
+            std::cerr
+                << "Cannot get bus or address, invalid configuration\n";
+            continue;
+        }
+
+        if ((*confBus != bus) || (*confAddr != addr))
+        {
+            std::cerr << "Configuration skipping " << *confBus << "-"
+                        << *confAddr << " because not " << bus << "-" << addr
+                        << "\n";
+            continue;
+        }
+
+        auto findSOCName = baseConfig->second.find("Name");
+        if (findSOCName == baseConfig->second.end())
+        {
+            std::cerr << "could not determine configuration name for "
+                        << *interfacePath << "\n";
+            return false;
+        }
+        std::string name =
+                    std::visit(VariantToStringVisitor(), findSOCName->second);
+        if (std::empty(name))
+        {
+            std::cerr << "Cannot find soc name, invalid configuration\n";
+            return false;
+        }
+        *socName = std::regex_replace(name, illegalDbusRegex, "_");
+
+        std::vector<thresholds::Threshold> confThresholds;
+        if (!parseThresholdsFromConfig(*sensorData, confThresholds))
+        {
+            std::cerr << "error populating totoal thresholds\n";
+        }
+        *thresholdConfSize = confThresholds.size();
+        *interfacePath = sensor.first.str;
+
+        isMatch = true;
+        break;
+    }
+    if (!isMatch)
+    {
+        return false;
+    }
+
+    return true;
+}
+
+static bool rescanSensors(
+    const std::shared_ptr<boost::container::flat_set<std::string>>&
+        sensorsChanged,
+    const std::pair<std::string, boost::container::flat_map<
+                    std::string, BasicVariantType>>* baseConfig,
+    std::string socName)
+{
+    bool firstScan = false;
+
+    if (baseConfig == nullptr)
+    {
+        return false;
+    }
+    if (sensorsChanged == nullptr)
+    {
+        firstScan = true;
+    }
+
+    // on rescans, only update sensors we were signaled by
+    if (!firstScan)
+    {
+        std::string socNameStr = "/" + socName;
+        auto it =
+            std::find_if(sensorsChanged->begin(), sensorsChanged->end(),
+                            [socNameStr](std::string& s) {
+                                return boost::ends_with(s, socNameStr);
+                            });
+        if (it == sensorsChanged->end())
+        {
+            return false;
+        }
+        sensorsChanged->erase(it);
+    }
+
+    return true;
+}
+
+static bool matchSensor(
+    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+    const std::pair<std::string, boost::container::flat_map<
+                    std::string, BasicVariantType>>* baseConfig,
+    SensorData* sensorData, std::string* interfacePath, std::string sensorType,
+    size_t thresholdConfSize, fs::path sensorPath,
+    std::vector<std::string> socNames,
+    std::vector<std::string> findLabels)
+{
+    bool maxLabel = false;
+    std::regex sensorNameRegEx("([A-Za-z]+)[0-9]*_");
+    std::string sensorNameSubStr{""};
+    std::string sensorNameStr = sensorPath.filename();
+    std::string sensorPathStr = sensorPath.string();
+    std::smatch matches;
+    std::string labelHead;
+
+    if (std::regex_search(sensorNameStr, matches, sensorNameRegEx))
+    {
+        // hwmon *_input filename without number:
+        // in, curr, power, temp, ...
+        sensorNameSubStr = matches[1];
+    }
+    else
+    {
+        std::cerr << "Could not extract the alpha prefix from "
+                    << sensorNameStr;
+        return false;
+    }
+
+    std::string labelPath;
+
+    /* find and differentiate _max and _input to replace "label" */
+    size_t pos = sensorPathStr.find('_');
+    if (pos == std::string::npos)
+    {
+        return false;
+    }
+
+    std::string sensorPathStrMax = sensorPathStr.substr(pos);
+    if (sensorPathStrMax.compare("_max") == 0)
+    {
+        labelPath = boost::replace_all_copy(sensorPathStr, "max", "label");
+        maxLabel = true;
+    }
+    else
+    {
+        labelPath =
+            boost::replace_all_copy(sensorPathStr, "input", "label");
+        maxLabel = false;
+    }
+
+    std::ifstream labelFile(labelPath);
+    if (!labelFile.good())
+    {
+        if constexpr (debug)
+        {
+            std::cerr << "Input file " << sensorPath
+                        << " has no corresponding label file\n";
+        }
+        // hwmon *_input filename with number:
+        // temp1, temp2, temp3, ...
+        labelHead = sensorNameStr.substr(0, sensorNameStr.find('_'));
+    }
+    else
+    {
+        std::string label;
+        std::getline(labelFile, label);
+        labelFile.close();
+        auto findSensor = sensors.find(label);
+        if (findSensor != sensors.end())
+        {
+            return false;
+        }
+
+        // hwmon corresponding *_label file contents:
+        // vin1, vout1, ...
+        labelHead = label.substr(0, label.find(' '));
+    }
+
+    /* append "max" for label */
+    if (maxLabel)
+    {
+        labelHead.insert(0, "max");
+    }
+
+    if constexpr (debug)
+    {
+        std::cerr << "Sensor type=\"" << sensorNameSubStr
+                    << "\" label=\"" << labelHead << "\"\n";
+    }
+
+    if (!findLabels.empty())
+    {
+        /* Check if this labelHead is enabled in config file */
+        if (std::find(findLabels.begin(), findLabels.end(),
+                        labelHead) == findLabels.end())
+        {
+            if constexpr (debug)
+            {
+                std::cerr << "could not find " << labelHead
+                            << " in the Labels list\n";
+            }
+            return false;
+        }
+    }
+
+    auto findProperty = propMatch.find(sensorNameSubStr);
+    if (findProperty == propMatch.end())
+    {
+        if constexpr (debug)
+        {
+            std::cerr << "Could not find matching default property for "
+                        << labelHead << "\n";
+        }
+        return false;
+    }
+
+    findProperty->second;
+
+
+    // Protect the hardcoded propMatch list from changes,
+    // by making a copy and modifying that instead.
+    // Avoid bleedthrough of one device's customizations to
+    // the next device, as each should be independently customizable.
+    socProperties.push_back(findProperty->second);
+    auto socProperty = socProperties.rbegin();
+
+    // Use label head as prefix for reading from config file,
+    // example if temp1: temp1_Name, temp1_Scale, temp1_Min, ...
+    std::string keyName = labelHead + "_Name";
+    std::string keyScale = labelHead + "_Scale";
+    std::string keyMin = labelHead + "_Min";
+    std::string keyMax = labelHead + "_Max";
+
+    bool customizedName = false;
+    auto findCustomName = baseConfig->second.find(keyName);
+    if (findCustomName != baseConfig->second.end())
+    {
+        try
+        {
+            socProperty->labelTypeName = std::visit(
+                VariantToStringVisitor(), findCustomName->second);
+        }
+        catch (std::invalid_argument&)
+        {
+            std::cerr << "Unable to parse " << keyName << "\n";
+            return false;
+        }
+
+        // All strings are valid, including empty string
+        customizedName = true;
+    }
+
+    bool customizedScale = false;
+    auto findCustomScale = baseConfig->second.find(keyScale);
+    if (findCustomScale != baseConfig->second.end())
+    {
+        try
+        {
+            socProperty->sensorScaleFactor = std::visit(
+                VariantToUnsignedIntVisitor(), findCustomScale->second);
+        }
+        catch (std::invalid_argument&)
+        {
+            std::cerr << "Unable to parse " << keyScale << "\n";
+            return false;
+        }
+
+        // Avoid later division by zero
+        if (socProperty->sensorScaleFactor > 0)
+        {
+            customizedScale = true;
+        }
+        else
+        {
+            std::cerr << "Unable to accept " << keyScale << "\n";
+            return false;
+        }
+    }
+
+    auto findCustomMin = baseConfig->second.find(keyMin);
+    if (findCustomMin != baseConfig->second.end())
+    {
+        try
+        {
+            socProperty->minReading = std::visit(
+                VariantToDoubleVisitor(), findCustomMin->second);
+        }
+        catch (std::invalid_argument&)
+        {
+            std::cerr << "Unable to parse " << keyMin << "\n";
+            return false;
+        }
+    }
+
+    auto findCustomMax = baseConfig->second.find(keyMax);
+    if (findCustomMax != baseConfig->second.end())
+    {
+        try
+        {
+            socProperty->maxReading = std::visit(
+                VariantToDoubleVisitor(), findCustomMax->second);
+        }
+        catch (std::invalid_argument&)
+        {
+            std::cerr << "Unable to parse " << keyMax << "\n";
+            return false;
+        }
+    }
+
+    if (!(socProperty->minReading < socProperty->maxReading))
+    {
+        std::cerr << "Min must be less than Max\n";
+        return false;
+    }
+
+    // If the sensor name is being customized by config file,
+    // then prefix/suffix composition becomes not necessary,
+    // and in fact not wanted, because it gets in the way.
+    std::string socNameFromIndex;
+    if (!customizedName)
+    {
+        /* Find out sensor name index for this label */
+        std::regex rgx("[A-Za-z]+([0-9]+)");
+        size_t nameIndex{0};
+        if (std::regex_search(labelHead, matches, rgx))
+        {
+            nameIndex = std::stoi(matches[1]);
+
+            // Decrement to preserve alignment, because hwmon
+            // human-readable filenames and labels use 1-based
+            // numbering, but the "Name", "Name1", "Name2", etc. naming
+            // convention (the socNames vector) uses 0-based numbering.
+            if (nameIndex > 0)
+            {
+                --nameIndex;
+            }
+        }
+        else
+        {
+            nameIndex = 0;
+        }
+
+        if (socNames.size() <= nameIndex)
+        {
+            std::cerr << "Could not pair " << labelHead
+                        << " with a Name field\n";
+            return false;
+        }
+
+        socNameFromIndex = socNames[nameIndex];
+
+        if constexpr (debug)
+        {
+            std::cerr << "Sensor label head " << labelHead
+                        << " paired with " << socNameFromIndex
+                        << " at index " << nameIndex << "\n";
+        }
+    }
+
+    // Similarly, if sensor scaling factor is being customized,
+    // then the below power-of-10 constraint becomes unnecessary,
+    // as config should be able to specify an arbitrary divisor.
+    unsigned int factor = socProperty->sensorScaleFactor;
+    if (!customizedScale)
+    {
+        // Preserve existing usage of hardcoded labelMatch table below
+        factor = std::pow(10.0, factor);
+
+        /* Change first char of substring to uppercase */
+        char firstChar =
+            static_cast<char>(std::toupper(sensorNameSubStr[0]));
+        std::string strScaleFactor =
+            firstChar + sensorNameSubStr.substr(1) + "ScaleFactor";
+
+        // Preserve existing configs by accepting earlier syntax,
+        // example CurrScaleFactor, PowerScaleFactor, ...
+        auto findScaleFactor = baseConfig->second.find(strScaleFactor);
+        if (findScaleFactor != baseConfig->second.end())
+        {
+            factor = std::visit(VariantToIntVisitor(),
+                                findScaleFactor->second);
+        }
+
+        if constexpr (debug)
+        {
+            std::cerr << "Sensor scaling factor " << factor
+                        << " string " << strScaleFactor << "\n";
+        }
+    }
+
+    std::vector<thresholds::Threshold> sensorThresholds;
+    if (!parseThresholdsFromConfig(*sensorData, sensorThresholds,
+                                    &labelHead))
+    {
+        std::cerr << "error populating thresholds for "
+                    << sensorNameSubStr << "\n";
+    }
+
+    auto findSensorType = sensorTable.find(sensorNameSubStr);
+    if (findSensorType == sensorTable.end())
+    {
+        std::cerr << sensorNameSubStr
+                    << " is not a recognized sensor type\n";
+        return false;
+    }
+
+    if constexpr (debug)
+    {
+        std::cerr << "Sensor properties: Name \""
+                    << socProperty->labelTypeName << "\" Scale "
+                    << socProperty->sensorScaleFactor << " Min "
+                    << socProperty->minReading << " Max "
+                    << socProperty->maxReading << "\n";
+    }
+
+    std::string sensorName = socProperty->labelTypeName;
+    if (customizedName)
+    {
+        if (sensorName.empty())
+        {
+            // Allow selective disabling of an individual sensor,
+            // by customizing its name to an empty string.
+            std::cerr << "Sensor disabled, empty string\n";
+            return false;
+        }
+    }
+    else
+    {
+        // Sensor name not customized, do prefix/suffix composition,
+        // preserving default behavior by using socNameFromIndex.
+        sensorName =
+            socNameFromIndex + " " + socProperty->labelTypeName;
+    }
+
+    if constexpr (debug)
+    {
+        std::cerr << "Sensor name \"" << sensorName << "\" path \""
+                    << sensorPathStr << "\" type \"" << sensorType
+                    << "\"\n";
+    }
+
+    // destruct existing one first if already created
+    sensors[sensorName] = nullptr;
+    sensors[sensorName] = std::make_shared<SoCSensor>(
+        sensorPathStr, sensorType, objectServer, dbusConnection, io,
+        sensorName, std::move(sensorThresholds), *interfacePath,
+        findSensorType->second, factor, socProperty->maxReading,
+        socProperty->minReading, labelHead, thresholdConfSize);
+    sensors[sensorName]->setupRead();
+
+    return true;
+}
+
+static bool parseSensorConfig(
+    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+    const std::pair<std::string, boost::container::flat_map<
+                    std::string, BasicVariantType>>* baseConfig,
+    SensorData* sensorData, std::string* interfacePath, std::string sensorType,
+    size_t thresholdConfSize, fs::path directory,
+    int* numSensors)
+{
+    int numCreated = 0;
+
+    std::vector<fs::path> sensorPaths;
+    if (!findFiles(directory, R"(\w\d+_input$)", sensorPaths, 0))
+    {
+        std::cerr << "No SOC non-label sensor in SOC\n";
+        return false;
+    }
+
+    auto findSOCName = baseConfig->second.find("Name");
+    if (findSOCName == baseConfig->second.end())
+    {
+        std::cerr << "could not determine configuration name for "
+                    << *interfacePath << "\n";
+        return false;
+    }
+
+    /* Check if there are more sensors in the same interface */
+    int i = 1;
+    std::vector<std::string> socNames;
+    do
+    {
+        // Individual string fields: Name, Name1, Name2, Name3, ...
+        socNames.push_back(std::get<std::string>(findSOCName->second));
+        findSOCName = baseConfig->second.find("Name" + std::to_string(i++));
+    } while (findSOCName != baseConfig->second.end());
+
+    /* read max value in sysfs for in, curr, power, temp, ... */
+    if (!findFiles(directory, R"(\w\d+_max$)", sensorPaths, 0))
+    {
+        if constexpr (debug)
+        {
+            std::cerr << "No max name in SOC \n";
+        }
+    }
+
+    /* Find array of labels to be exposed if it is defined in config */
+    std::vector<std::string> findLabels;
+    auto findLabelObj = baseConfig->second.find("Labels");
+    if (findLabelObj != baseConfig->second.end())
+    {
+        findLabels = std::get<std::vector<std::string>>(findLabelObj->second);
+    }
+    bool ret = false;
+    for (const auto& sensorPath : sensorPaths)
+    {
+        ret = matchSensor(io, objectServer, dbusConnection, baseConfig,
+                          sensorData, interfacePath, sensorType,
+                          thresholdConfSize, sensorPath, socNames, findLabels);
+        if (!ret)
+        {
+            continue;
+        }
+        numCreated++;
+        if constexpr (debug)
+        {
+            std::cerr << "Created " << numCreated << " sensors so far\n";
+        }
+    }
+
+    *numSensors = numCreated;
+    return true;
+}
+
+static void createSensorsCallback(
+    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+    const ManagedObjectType& sensorConfigs,
+    const std::shared_ptr<boost::container::flat_set<std::string>>&
+        sensorsChanged)
+{
+    std::vector<fs::path> busPaths;
+
+    /* First sensor scan or scan when the host/power state is changed */
+    if (!sensorsChanged)
+    {
+        removeAllSensors();
+    }
+
+    if (!findFiles(fs::path("/sys/class/hwmon"), "name", busPaths))
+    {
+        std::cerr << "No SOC sensors in system\n";
+        return;
+    }
+
+    boost::container::flat_set<std::string> directories;
+    for (const auto& busPath : busPaths)
+    {
+        boost::container::flat_map<std::string, std::vector<std::string>>
+            eventPathList;
+        boost::container::flat_map<
+            std::string,
+            boost::container::flat_map<std::string, std::vector<std::string>>>
+            groupEventPathList;
+
+        std::ifstream nameFile(busPath);
+        if (!nameFile.good())
+        {
+            std::cerr << "Failure finding pmbus path " << busPath << "\n";
+            continue;
+        }
+
+        std::string busName;
+        std::getline(nameFile, busName);
+        nameFile.close();
+        if (std::find(busNames.begin(), busNames.end(), busName) ==
+            busNames.end())
+        {
+            // To avoid this error message, add your driver name to
+            // the busNames vector at the top of this file.
+            std::cerr << "Driver name " << busName
+                      << " not found in sensor whitelist\n";
+            continue;
+        }
+
+        auto directory = busPath.parent_path();
+
+        auto ret = directories.insert(directory.string());
+        if (!ret.second)
+        {
+            std::cerr << "Duplicate path " << directory.string() << "\n";
+            continue; // check if path has already been searched
+        }
+
+        size_t bus = 0;
+        size_t addr = 0;
+        fs::path device = directory / "device";
+        std::string devPath = fs::canonical(device);
+        if (!getDeviceInfo(devPath, &bus, &addr))
+        {
+            continue;
+        }
+
+        std::pair<std::string, boost::container::flat_map<
+                  std::string, BasicVariantType>>* baseConfig =
+        new std::pair<std::string, boost::container::flat_map<
+                      std::string, BasicVariantType>>;
+        SensorData* sensorData = new SensorData;
+        std::string* interfacePath = new std::string;
+        std::string socName;
+        std::string sensorType;
+        size_t thresholdConfSize = 0;
+        bool retVal = findMatchConfig(sensorConfigs, baseConfig, sensorData,
+                                   interfacePath, &sensorType,
+                                   &thresholdConfSize, bus, addr,
+                                   devPath, &socName);
+        if (!retVal)
+        {
+            std::cerr << "failed to find match for " << socName << "\n";
+            continue;
+        }
+
+        if ((numSocSensors.find(socName) != numSocSensors.end()) &&
+            (numSocSensors[socName] > 0))
+        {
+            retVal = rescanSensors(sensorsChanged, baseConfig, socName);
+            if (!retVal)
+            {
+                continue;
+            }
+        }
+
+        int numCreated = 0;
+        parseSensorConfig(io, objectServer, dbusConnection, baseConfig,
+                          sensorData,
+                          interfacePath, sensorType, thresholdConfSize,
+                          directory, &numCreated);
+        numSocSensors[socName] = numCreated;
+        if constexpr (debug)
+        {
+            std::cerr << "Device " << socName;
+            std::cerr << " created " << numCreated << " sensors \n";
+        }
+    }
+
+    return;
+}
+
+void createSensors(
+    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+    const std::shared_ptr<boost::container::flat_set<std::string>>&
+        sensorsChanged)
+{
+    auto getter = std::make_shared<GetSensorConfiguration>(
+        dbusConnection, [&io, &objectServer, &dbusConnection, sensorsChanged](
+                            const ManagedObjectType& sensorConfigs) {
+            if (sensorConfigs.size() > 0)
+            {
+                createSensorsCallback(io, objectServer, dbusConnection,
+                                      sensorConfigs, sensorsChanged);
+            }
+        });
+    getter->getConfiguration(
+        std::vector<std::string>(sensorTypes.begin(), sensorTypes.end()));
+}
+
+void propertyInitialize(void)
+{
+    sensorTable = {{"power", "power/"},
+                   {"curr", "current/"},
+                   {"temp", "temperature/"},
+                   {"in", "voltage/"}};
+
+    propMatch = {{"power", SoCProperty("Power Property", 30000, 0, 1)},
+                 {"curr", SoCProperty("Curr property", 30000, 0, 1)},
+                 {"temp", SoCProperty("Temp property", 255, 0, 1)},
+                 {"in", SoCProperty("Voltage property", 30000, 0, 1)}};
+}
+
+int main()
+{
+    boost::asio::io_service io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+
+    systemBus->request_name("xyz.openbmc_project.SoCSensor");
+    sdbusplus::asio::object_server objectServer(systemBus);
+    std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
+    auto sensorsChanged =
+        std::make_shared<boost::container::flat_set<std::string>>();
+
+    propertyInitialize();
+
+    io.post([&]() { createSensors(io, objectServer, systemBus, nullptr); });
+    boost::asio::deadline_timer filterTimer(io);
+    std::function<void(sdbusplus::message::message&)> eventHandler =
+        [&](sdbusplus::message::message& message) {
+            if (message.is_method_error())
+            {
+                std::cerr << "callback method error\n";
+                return;
+            }
+            sensorsChanged->insert(message.get_path());
+            filterTimer.expires_from_now(boost::posix_time::seconds(5));
+            filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                if (ec == boost::asio::error::operation_aborted)
+                {
+                    return;
+                }
+                if (ec)
+                {
+                    std::cerr << "timer error\n";
+                }
+                createSensors(io, objectServer, systemBus, sensorsChanged);
+            });
+        };
+
+    for (const char* type : sensorTypes)
+    {
+        auto match = std::make_unique<sdbusplus::bus::match::match>(
+            static_cast<sdbusplus::bus::bus&>(*systemBus),
+            "type='signal',member='PropertiesChanged',path_namespace='" +
+                std::string(inventoryPath) + "',arg0namespace='" + type + "'",
+            eventHandler);
+        matches.emplace_back(std::move(match));
+    }
+
+    io.run();
+}
diff --git a/src/meson.build b/src/meson.build
index dc11177..3dfcb9c 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -192,6 +192,26 @@ if get_option('psu').enabled()
     )
 endif
 
+if get_option('soc').enabled()
+    executable(
+        'socsensor',
+        'AmpereSoC.cpp',
+        'AmpereSoCMain.cpp',
+        dependencies: [
+            gpiodcxx,
+            sdbusplus,
+        ],
+        implicit_include_directories: false,
+        include_directories: '../include',
+        install: true,
+        link_with: [
+            pwmsensor_a,
+            thresholds_a,
+            utils_a,
+        ],
+    )
+endif
+
 if get_option('external').enabled()
     executable(
         'externalsensor',
-- 
2.17.1

