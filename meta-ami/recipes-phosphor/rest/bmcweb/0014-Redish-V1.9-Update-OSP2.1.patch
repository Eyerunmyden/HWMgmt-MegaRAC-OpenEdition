diff -Naur a/redfish-core/include/error_messages.hpp b/redfish-core/include/error_messages.hpp
--- a/redfish-core/include/error_messages.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/include/error_messages.hpp	2020-09-23 16:09:04.662878722 +0530
@@ -796,6 +796,9 @@
  * @param[in] arg2 Parameter of message that will replace %2 in its body.
  *
  * @returns Message DelayInActionCompletion formatted to JSON */
+nlohmann::json delayInActionCompletion(const std::string& arg1,
+                                       const std::string& arg2);
+
 void delayInActionCompletion(crow::Response& res, const std::string& arg1,
                              const std::string& arg2);
 
@@ -805,6 +808,8 @@
  *
  *
  * @returns Message NoContent formatted to JSON */
+nlohmann::json noContent(void);
+
 void noContent(crow::Response& res);
 
 
@@ -816,6 +821,8 @@
  * @param[in] arg1 Parameter of message that will replace %1 in its body.
  *
  * @returns Message InstanceInUse formatted to JSON */
+nlohmann::json instanceInUse(const std::string& arg1);
+
 void instanceInUse(crow::Response& res,const std::string& arg1);
 
 
@@ -828,6 +835,8 @@
  * @param[in] arg1 Parameter of message that will replace %1 in its body.
  *
  * @returns Message InstanceNotInUse formatted to JSON */
+nlohmann::json instanceNotInUse(const std::string& arg1);
+
 void instanceNotInUse(crow::Response& res,const std::string& arg1);
 
 } // namespace messages
diff -Naur a/redfish-core/include/registries/base_message_registry.hpp b/redfish-core/include/registries/base_message_registry.hpp
--- a/redfish-core/include/registries/base_message_registry.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/include/registries/base_message_registry.hpp	2020-09-23 16:05:15.426490061 +0530
@@ -23,18 +23,18 @@
 namespace redfish::message_registries::base
 {
 const Header header = {
-    "Copyright 2014-2020 DMTF. All rights reserved.",
-    "#MessageRegistry.v1_4_0.MessageRegistry",
-    "Base.1.8.1",
+    "Copyright 2014-2019 DMTF. All rights reserved.",
+    "#MessageRegistry.v1_3_1.MessageRegistry",
+    "Base.1.7.0",
     "Base Message Registry",
     "en",
     "This registry defines the base messages for Redfish",
     "Base",
-    "1.8.1",
+    "1.7.0",
     "DMTF",
 };
 constexpr const char* url =
-    "https://redfish.dmtf.org/registries/Base.1.8.1.json";
+    "https://redfish.dmtf.org/registries/Base.1.7.0.json";
 
 constexpr std::array<MessageEntry, 77> registry = {
     MessageEntry{
@@ -1130,6 +1130,7 @@
            "with requested instance. ",
             "The media has successfully mounted to Host machine.",
             "OK",
+            "OK",
             0,
             {},
             "None",
@@ -1140,6 +1141,7 @@
             "Indicates that Media has been ejected successfully",
             "The media has successfully unmounted to Host machine.",
             "OK",
+            "OK",
             0,
             {},
             "None",
@@ -1153,6 +1155,7 @@
             "The change to the requested Instance failed because the "
             "Instance is in use or in transition.",
             "Warning",
+            "Warning",
             0,
             {},
             "Try with another Instance or Eject the Media for this "
@@ -1167,6 +1170,7 @@
             "The change to the requested Instance failed because the "
             "Instance is not in use or not in transition.",
             "Warning",
+            "Warning",
             0,
             {},
             "Try with another Instance or Check the Status for this "
diff -Naur a/redfish-core/include/registries/openbmc_message_registry.hpp b/redfish-core/include/registries/openbmc_message_registry.hpp
--- a/redfish-core/include/registries/openbmc_message_registry.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/include/registries/openbmc_message_registry.hpp	2020-09-23 16:05:33.010522950 +0530
@@ -20,7 +20,7 @@
 {
 const Header header = {
     "Copyright 2018 OpenBMC. All rights reserved.",
-    "#MessageRegistry.v1_4_0.MessageRegistry",
+    "#MessageRegistry.v1_3_1.MessageRegistry",
     "OpenBMC.0.1.0",
     "OpenBMC Message Registry",
     "en",
diff -Naur a/redfish-core/include/registries/task_event_message_registry.hpp b/redfish-core/include/registries/task_event_message_registry.hpp
--- a/redfish-core/include/registries/task_event_message_registry.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/include/registries/task_event_message_registry.hpp	2020-09-23 16:05:56.278565538 +0530
@@ -23,19 +23,19 @@
 namespace redfish::message_registries::task_event
 {
 const Header header = {
-    "Copyright 2014-2020 DMTF in cooperation with the Storage Networking "
+    "Copyright 2014-2018 DMTF in cooperation with the Storage Networking "
     "Industry Association (SNIA). All rights reserved.",
-    "#MessageRegistry.v1_4_0.MessageRegistry",
-    "TaskEvent.1.0.2",
+    "#MessageRegistry.v1_3_1.MessageRegistry",
+    "TaskEvent.1.0.1",
     "Task Event Message Registry",
     "en",
     "This registry defines the messages for task related events.",
     "TaskEvent",
-    "1.0.2",
+    "1.0.1",
     "DMTF",
 };
 constexpr const char* url =
-    "https://redfish.dmtf.org/registries/TaskEvent.1.0.2.json";
+    "https://redfish.dmtf.org/registries/TaskEvent.1.0.1.json";
 
 constexpr std::array<MessageEntry, 9> registry = {
     MessageEntry{"TaskAborted",
diff -Naur a/redfish-core/include/utils/fw_utils.hpp b/redfish-core/include/utils/fw_utils.hpp
--- a/redfish-core/include/utils/fw_utils.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/include/utils/fw_utils.hpp	2020-09-23 16:08:43.730846411 +0530
@@ -1,8 +1,10 @@
 #pragma once
 #include <async_resp.hpp>
 
+#include <algorithm>
 #include <string>
 #include <variant>
+#include <vector>
 
 namespace redfish
 {
@@ -17,28 +19,28 @@
     "xyz.openbmc_project.Software.Version.VersionPurpose.BMC";
 
 /**
- * @brief Put fw version of input type into async response json structure
+ * @brief Populate the running firmware version and image links
  *
  * @param[i,o] aResp             Async response object
  * @param[i]   fwVersionPurpose  Indicates what target to look for
  * @param[i]   activeVersionPropName  Index in aResp->res.jsonValue to write
  * the running firmware version to
- * @param[i]   populateLinkToActiveImage  Populate aResp->res "Links"
- * "ActiveSoftwareImage" with a link to the running firmware image
+ * @param[i]   populateLinkToImages  Populate aResp->res "Links"
+ * "ActiveSoftwareImage" with a link to the running firmware image and
+ * "SoftwareImages" with a link to the all its firmware images
  *
  * @return void
  */
-void getActiveFwVersion(std::shared_ptr<AsyncResp> aResp,
-                        const std::string& fwVersionPurpose,
-                        const std::string& activeVersionPropName,
-                        const bool populateLinkToActiveImage)
+inline void populateFirmwareInformation(
+    std::shared_ptr<AsyncResp> aResp, const std::string& fwVersionPurpose,
+    const std::string& activeVersionPropName, const bool populateLinkToImages)
 {
-    // Get active FW images
+    // Used later to determine running (known on Redfish as active) FW images
     crow::connections::systemBus->async_method_call(
-        [aResp, fwVersionPurpose, activeVersionPropName,
-         populateLinkToActiveImage](
+	[aResp, fwVersionPurpose, activeVersionPropName, populateLinkToImages](
             const boost::system::error_code ec,
             const std::variant<std::vector<std::string>>& resp) {
+	    BMCWEB_LOG_DEBUG << "populateFirmwareInformation enter";
             if (ec)
             {
                 BMCWEB_LOG_ERROR << "error_code = " << ec;
@@ -46,76 +48,97 @@
                 messages::internalError(aResp->res);
                 return;
             }
+
             const std::vector<std::string>* functionalFw =
                 std::get_if<std::vector<std::string>>(&resp);
             if ((functionalFw == nullptr) || (functionalFw->size() == 0))
             {
+	    	// Could keep going and try to populate SoftwareImages but
+                // something is seriously wrong, so just fail
                 BMCWEB_LOG_ERROR << "Zero functional software in system";
                 messages::internalError(aResp->res);
                 return;
             }
+		
+	    std::vector<std::string> functionalFwIds;
             // example functionalFw:
             // v as 2 "/xyz/openbmc_project/software/ace821ef"
             //        "/xyz/openbmc_project/software/230fb078"
             for (auto& fw : *functionalFw)
             {
-                // if can't parse fw id then return
+
                 std::string::size_type idPos = fw.rfind("/");
                 if (idPos == std::string::npos)
                 {
-                    messages::internalError(aResp->res);
-                    BMCWEB_LOG_DEBUG << "Can't parse firmware ID!!";
-                    return;
+		    BMCWEB_LOG_DEBUG << "Can't parse firmware ID!";
+                    continue;
                 }
                 idPos++;
                 if (idPos >= fw.size())
                 {
-                    messages::internalError(aResp->res);
                     BMCWEB_LOG_DEBUG << "Invalid firmware ID";
-                    return;
+		    continue;
                 }
-                std::string swId = fw.substr(idPos);
+		functionalFwIds.push_back(fw.substr(idPos));
+            }
 
-                // Now find service that hosts it
-                crow::connections::systemBus->async_method_call(
-                    [aResp, fw, swId, fwVersionPurpose, activeVersionPropName,
-                     populateLinkToActiveImage](
-                        const boost::system::error_code ec,
-                        const std::vector<std::pair<
-                            std::string, std::vector<std::string>>>& objInfo) {
-                        if (ec)
+            crow::connections::systemBus->async_method_call(
+                [aResp, fwVersionPurpose, activeVersionPropName,
+                 populateLinkToImages, functionalFwIds](
+                    const boost::system::error_code ec2,
+                    const std::vector<
+                        std::pair<std::string,
+                                  std::vector<std::pair<
+                                      std::string, std::vector<std::string>>>>>&
+                        subtree) {
+                    if (ec2)
+                    {
+			BMCWEB_LOG_ERROR << "error_code = " << ec2;
+                        BMCWEB_LOG_ERROR << "error msg = " << ec2.message();
+                        messages::internalError(aResp->res);
+                        return;
+                    }
+
+                    BMCWEB_LOG_DEBUG << "Found " << subtree.size() << " images";
+			
+		    for (const std::pair<
+                         std::string,
+                         std::vector<std::pair<
+                             std::string, std::vector<std::string>>>>& obj :
+                         subtree)
+                    {
+                        // if can't parse fw id then return
+                        std::string::size_type idPos = obj.first.rfind("/");
+                        if (idPos == std::string::npos)
                         {
-                            BMCWEB_LOG_DEBUG << "error_code = " << ec;
-                            BMCWEB_LOG_DEBUG << "error msg = " << ec.message();
                             messages::internalError(aResp->res);
+			    BMCWEB_LOG_ERROR << "Can't parse firmware ID!!";
                             return;
                         }
-                        // Example objInfo
-                        // a{sas} 1 "org.open_power.Software.Host.Updater" 10
-                        // "org.freedesktop.DBus.Introspectable"
-                        // "org.freedesktop.DBus.Peer"
-                        // "org.freedesktop.DBus.Properties"
-                        // "org.openbmc.Associations"
-                        // "xyz.openbmc_project.Common.FilePath"
-                        // "xyz.openbmc_project.Object.Delete"
-                        // "xyz.openbmc_project.Software.Activation"
-                        // "xyz.openbmc_project.Software.ExtendedVersion"
-                        // "xyz.openbmc_project.Software.RedundancyPriority"
-                        // "xyz.openbmc_project.Software.Version"
-
-                        // Ensure we only got one service back
-                        if (objInfo.size() != 1)
+			idPos++;
+                        if (idPos >= obj.first.size())
                         {
-                            BMCWEB_LOG_ERROR << "Invalid Object Size "
-                                             << objInfo.size();
                             messages::internalError(aResp->res);
+			    BMCWEB_LOG_ERROR << "Invalid firmware ID";
                             return;
                         }
+			std::string swId = obj.first.substr(idPos);
+
+                        bool runningImage = false;
+                        // Look at Ids from
+                        // /xyz/openbmc_project/software/functional
+                        // to determine if this is a running image
+                        if (std::find(functionalFwIds.begin(),
+                                      functionalFwIds.end(),
+                                      swId) != functionalFwIds.end())
+                        {
+                            runningImage = true;
+                        }
 
                         // Now grab its version info
                         crow::connections::systemBus->async_method_call(
-                            [aResp, swId, fwVersionPurpose,
-                             activeVersionPropName, populateLinkToActiveImage](
+			    [aResp, swId, runningImage, fwVersionPurpose,
+                             activeVersionPropName, populateLinkToImages](
                                 const boost::system::error_code ec,
                                 const boost::container::flat_map<
                                     std::string,
@@ -142,7 +165,7 @@
                                     propertiesList.find("Purpose");
                                 if (it == propertiesList.end())
                                 {
-                                    BMCWEB_LOG_DEBUG
+				    BMCWEB_LOG_ERROR
                                         << "Can't find property \"Purpose\"!";
                                     messages::internalError(aResp->res);
                                     return;
@@ -151,37 +174,60 @@
                                     std::get_if<std::string>(&it->second);
                                 if (swInvPurpose == nullptr)
                                 {
-                                    BMCWEB_LOG_DEBUG << "wrong types for "
+                                    BMCWEB_LOG_ERROR << "wrong types for "
                                                         "property \"Purpose\"!";
                                     messages::internalError(aResp->res);
                                     return;
                                 }
+				
+				BMCWEB_LOG_DEBUG << "Image ID: " << swId;
+                                BMCWEB_LOG_DEBUG << "Image purpose: "
+                                                 << *swInvPurpose;
+                                BMCWEB_LOG_DEBUG << "Running image: "
+                                                 << runningImage;
 
                                 if (*swInvPurpose != fwVersionPurpose)
                                 {
                                     // Not purpose we're looking for
                                     return;
                                 }
-                                if (populateLinkToActiveImage)
+                                if (populateLinkToImages)
                                 {
+				    nlohmann::json& softwareImageMembers =
+                                        aResp->res.jsonValue["Links"]
+                                                            ["SoftwareImages"];
                                     // Firmware images are at
                                     // /redfish/v1/UpdateService/FirmwareInventory/<Id>
                                     // e.g. .../FirmwareInventory/82d3ec86
-                                    // Create the link to the running one
-                                    aResp->res
-                                        .jsonValue["Links"]
-                                                  ["ActiveSoftwareImage"] = {
-                                        {"@odata.id",
-                                         "/redfish/v1/UpdateService/"
-                                         "FirmwareInventory/" +
-                                             swId}};
+				    softwareImageMembers.push_back(
+                                        {{"@odata.id",
+                                          "/redfish/v1/UpdateService/"
+                                          "FirmwareInventory/" +
+                                              swId}});
+                                    aResp->res.jsonValue
+                                        ["Links"]
+                                        ["SoftwareImages@odata.count"] =
+                                        softwareImageMembers.size();
+
+                                    if (runningImage)
+                                    {  
+					// Create the link to the running image
+                                        aResp->res
+                                            .jsonValue["Links"]
+                                                      ["ActiveSoftwareImage"] =
+                                            {{"@odata.id",
+                                              "/redfish/v1/UpdateService/"
+                                              "FirmwareInventory/" +
+                                                  swId}};
+                                    }
                                 }
-                                if (!activeVersionPropName.empty())
+                                if (!activeVersionPropName.empty() &&
+				    runningImage)
                                 {
                                     it = propertiesList.find("Version");
                                     if (it == propertiesList.end())
                                     {
-                                        BMCWEB_LOG_DEBUG
+                                        BMCWEB_LOG_ERROR
                                             << "Can't find property "
                                                "\"Version\"!";
                                         messages::internalError(aResp->res);
@@ -191,7 +237,7 @@
                                         std::get_if<std::string>(&it->second);
                                     if (version == nullptr)
                                     {
-                                        BMCWEB_LOG_DEBUG
+                                        BMCWEB_LOG_ERROR
                                             << "Error getting fw version";
                                         messages::internalError(aResp->res);
                                         return;
@@ -202,16 +248,17 @@
                                         *version;
                                 }
                             },
-                            objInfo[0].first, fw,
+                            obj.second[0].first, obj.first,
                             "org.freedesktop.DBus.Properties", "GetAll",
                             "xyz.openbmc_project.Software.Version");
-                    },
-                    "xyz.openbmc_project.ObjectMapper",
-                    "/xyz/openbmc_project/object_mapper",
-                    "xyz.openbmc_project.ObjectMapper", "GetObject", fw,
-                    std::array<const char*, 1>{
-                        "xyz.openbmc_project.Software.Activation"});
-            }
+			    }
+                },
+                "xyz.openbmc_project.ObjectMapper",
+                "/xyz/openbmc_project/object_mapper",
+                "xyz.openbmc_project.ObjectMapper", "GetSubTree",
+                "/xyz/openbmc_project/software", static_cast<int32_t>(0),
+                std::array<const char*, 1>{
+                    "xyz.openbmc_project.Software.Version"});
         },
         "xyz.openbmc_project.ObjectMapper",
         "/xyz/openbmc_project/software/functional",
diff -Naur a/redfish-core/lib/account_service.hpp b/redfish-core/lib/account_service.hpp
--- a/redfish-core/lib/account_service.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/account_service.hpp	2020-09-23 16:12:02.615134146 +0530
@@ -58,6 +58,7 @@
     std::string uri{};
     std::string bindDN{};
     std::string baseDN{};
+    std::string bindDNPassword{};
     std::string searchScope{};
     std::string serverType{};
     bool serviceEnabled = false;
@@ -134,14 +135,14 @@
                "xyz.openbmc_project.User.Common.Error.UserNameExists") == 0)
     {
         messages::resourceAlreadyExists(asyncResp->res,
-                                        "#ManagerAccount.v1_4_0.ManagerAccount",
+                                        "#ManagerAccount.v1_5_0.ManagerAccount",
                                         "UserName", newUser);
     }
     else if (strcmp(errorMessage, "xyz.openbmc_project.User.Common.Error."
                                   "UserNameDoesNotExist") == 0)
     {
         messages::resourceNotFound(
-            asyncResp->res, "#ManagerAccount.v1_4_0.ManagerAccount", username);
+            asyncResp->res, "#ManagerAccount.v1_5_0.ManagerAccount", username);
     }
     else if (strcmp(errorMessage,
                     "xyz.openbmc_project.Common.Error.InvalidArgument") == 0)
@@ -176,9 +177,11 @@
     nlohmann::json ldap ;
     if(confData.serviceEnabled == false)
     {
-//       nlohmann::json ldap = {
-                        ldap = {
-           {"AccountProviderType", service},
+          ldap = {
+           // Removing "AccountProviderType" Property,
+	   // as this proeprty is deprecated in
+	   // AccountService.v1_7_0.AccountService
+           //{"AccountProviderType", service},
            {"ServiceEnabled", confData.serviceEnabled},
            {"ServiceAddresses", nlohmann::json::array({""})},
            {"Authentication",
@@ -191,14 +194,15 @@
                 nlohmann::json::array({""})},
                {"UsernameAttribute", ""},
                {"GroupsAttribute", ""}}}}},
-       };
-
+          };
     }
     else
     {
-//       nlohmann::json ldap = {
-                        ldap = {
-           {"AccountProviderType", service},
+          ldap = {
+           // Removing "AccountProviderType" Property,
+	   // as this proeprty is deprecated in
+	   // AccountService.v1_7_0.AccountService
+           //{"AccountProviderType", service},
            {"ServiceEnabled", confData.serviceEnabled},
            {"ServiceAddresses", nlohmann::json::array({confData.uri})},
            {"Authentication",
@@ -211,9 +215,17 @@
                 nlohmann::json::array({confData.baseDN})},
                {"UsernameAttribute", confData.userNameAttribute},
                {"GroupsAttribute", confData.groupAttribute}}}}},
-       };
+          };
     }
 
+    if (confData.bindDNPassword.empty())
+    {
+        json_response[ldapType]["PasswordSet"] = false;
+    }
+    else
+    {
+        json_response[ldapType]["PasswordSet"] = true;
+    }
 
     json_response[ldapType].update(std::move(ldap));
 
@@ -540,7 +552,12 @@
                                     {
                                         confData.serverType = *strValue;
                                     }
-                                }
+                                    else if (property.first == 
+					     "LDAPBindDNPassword")
+                                    {
+                                        confData.bindDNPassword = *strValue;
+                                    }
+				}
                             }
                             else if (interface.first ==
                                      "xyz.openbmc_project.User."
@@ -1163,12 +1180,15 @@
         res.jsonValue = {
             {"@odata.id", "/redfish/v1/AccountService"},
             {"@odata.type", "#AccountService."
-                            "v1_5_0.AccountService"},
+                            "v1_7_0.AccountService"},
+            {"@odata.context", "/redfish/v1/$metadata#"
+		    		"AccountService.AccountService"},
             {"Id", "AccountService"},
             {"Name", "Account Service"},
             {"Description", "Account Service"},
             {"ServiceEnabled", true},
             {"MaxPasswordLength", 20},
+            {"AccountLockoutCounterResetEnabled", true},
             {"Accounts",
              {{"@odata.id", "/redfish/v1/AccountService/Accounts"}}},
             {"Roles", {{"@odata.id", "/redfish/v1/AccountService/Roles"}}},
@@ -1222,6 +1242,8 @@
                         {
                             asyncResp->res.jsonValue["AccountLockoutDuration"] =
                                 *value;
+                            asyncResp->res.jsonValue["AccountLockoutCounterResetAfter"] =
+                                *value;
                         }
                     }
                     if (property.first == "MaxLoginAttemptBeforeLockout")
@@ -1247,6 +1269,11 @@
 
         getLDAPConfigData("LDAP", callback);
         getLDAPConfigData("ActiveDirectory", callback);
+         
+	res.jsonValue["Status"]["State"] = "Enabled";
+        res.jsonValue["Status"]["Health"] = "OK";
+        //res.jsonValue =	{"Status", {{"Health", "ok"},
+	//			    {"State", "Enabled"}}};
 
 	res.addHeader(boost::beast::http::field::allow,
 		                redfish::Header::GetAllowHeaders("AccountService_v1.xml"));
@@ -1258,6 +1285,7 @@
         auto asyncResp = std::make_shared<AsyncResp>(res);
 
         std::optional<uint32_t> unlockTimeout;
+        std::optional<uint32_t> unlockResetTimeout;
         std::optional<uint16_t> lockoutThreshold;
         std::optional<uint16_t> minPasswordLength;
         std::optional<uint16_t> maxPasswordLength;
@@ -1270,7 +1298,8 @@
                 "AccountLockoutThreshold", lockoutThreshold,
                 "MaxPasswordLength", maxPasswordLength, "MinPasswordLength",
                 minPasswordLength, "LDAP", ldapObject, "ActiveDirectory",
-                activeDirectoryObject, "Oem", oemObject))
+                activeDirectoryObject, "Oem", oemObject,
+		"AccountLockoutCounterResetAfter", unlockResetTimeout))
         {
             return;
         }
@@ -1312,8 +1341,16 @@
                             "ActiveDirectory");
         }
 
-        if (unlockTimeout)
+        if (unlockTimeout || unlockResetTimeout)
         {
+            std::optional<uint32_t> CounterTimeoutVal;
+	    if (unlockTimeout) {
+	        CounterTimeoutVal = unlockTimeout;
+	    }
+	    else if (unlockResetTimeout) {
+		CounterTimeoutVal = unlockResetTimeout;
+	    }
+
             crow::connections::systemBus->async_method_call(
                 [asyncResp](const boost::system::error_code ec) {
                     if (ec)
@@ -1326,7 +1363,7 @@
                 "xyz.openbmc_project.User.Manager", "/xyz/openbmc_project/user",
                 "org.freedesktop.DBus.Properties", "Set",
                 "xyz.openbmc_project.User.AccountPolicy",
-                "AccountUnlockTimeout", std::variant<uint32_t>(*unlockTimeout));
+                "AccountUnlockTimeout", std::variant<uint32_t>(*CounterTimeoutVal));
         }
         if (lockoutThreshold)
         {
@@ -1383,6 +1420,9 @@
         res.jsonValue = {{"@odata.id", "/redfish/v1/AccountService/Accounts"},
                          {"@odata.type", "#ManagerAccountCollection."
                                          "ManagerAccountCollection"},
+        	         {"@odata.context", "/redfish/v1/$metadata#"
+		    		            "ManagerAccountCollection."
+		    		            "ManagerAccountCollection"},
                          {"Name", "Accounts Collection"},
                          {"Description", "BMC User Accounts"}};
 
@@ -1616,7 +1656,9 @@
                 }
 
                 asyncResp->res.jsonValue = {
-                    {"@odata.type", "#ManagerAccount.v1_4_0.ManagerAccount"},
+                    {"@odata.type", "#ManagerAccount.v1_5_0.ManagerAccount"},
+                    {"@odata.context", "/redfish/v1/$metadata#"
+		    		       "ManagerAccount.ManagerAccount"},
                     {"Name", "User Account"},
                     {"Description", "User Account"},
                     {"Password", nullptr},
@@ -1817,7 +1859,7 @@
                 if (!rc)
                 {
                     messages::resourceNotFound(
-                        asyncResp->res, "#ManagerAccount.v1_4_0.ManagerAccount",
+                        asyncResp->res, "#ManagerAccount.v1_5_0.ManagerAccount",
                         username);
                     return;
                 }
@@ -1830,7 +1872,7 @@
                     {
                         messages::resourceNotFound(
                             asyncResp->res,
-                            "#ManagerAccount.v1_4_0.ManagerAccount", username);
+                            "#ManagerAccount.v1_5_0.ManagerAccount", username);
                     }
                     else if (retval == PAM_AUTHTOK_ERR)
                     {
@@ -1966,7 +2008,7 @@
                 if (ec)
                 {
                     messages::resourceNotFound(
-                        asyncResp->res, "#ManagerAccount.v1_4_0.ManagerAccount",
+                        asyncResp->res, "#ManagerAccount.v1_5_0.ManagerAccount",
                         username);
                     return;
                 }
diff -Naur a/redfish-core/lib/bios.hpp b/redfish-core/lib/bios.hpp
--- a/redfish-core/lib/bios.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/bios.hpp	2020-09-23 16:12:17.571154226 +0530
@@ -26,6 +26,8 @@
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Systems/system/Bios";
         asyncResp->res.jsonValue["@odata.type"] = "#Bios.v1_1_0.Bios";
+        asyncResp->res.jsonValue["@odata.context"] = 
+	    "/redfish/v1/$metadata#Bios.Bios";
         asyncResp->res.jsonValue["Name"] = "BIOS Configuration";
         asyncResp->res.jsonValue["Description"] = "BIOS Configuration Service";
         asyncResp->res.jsonValue["Id"] = "BIOS";
@@ -34,7 +36,9 @@
              "/redfish/v1/Systems/system/Bios/Actions/Bios.ResetBios"}};
 
         // Get the ActiveSoftwareImage
-        fw_util::getActiveFwVersion(asyncResp, fw_util::biosPurpose, "", true);
+	fw_util::populateFirmwareInformation(asyncResp, fw_util::biosPurpose,
+        	                             "", true);
+
 	asyncResp->res.addHeader(boost::beast::http::field::allow,
                                  redfish::Header::GetAllowHeaders("Bios_v1.xml"));
     }
diff -Naur a/redfish-core/lib/certificate_service.hpp b/redfish-core/lib/certificate_service.hpp
--- a/redfish-core/lib/certificate_service.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/certificate_service.hpp	2020-09-23 15:57:33.677336887 +0530
@@ -74,7 +74,9 @@
                const std::vector<std::string>& params) override
     {
         res.jsonValue = {
-            {"@odata.type", "#CertificateService.v1_0_0.CertificateService"},
+            {"@odata.type", "#CertificateService.v1_0_2.CertificateService"},
+            {"@odata.context", "/redfish/v1/$metadata#"
+		    		"CertificateService.CertificateService"},
             {"@odata.id", "/redfish/v1/CertificateService"},
             {"Id", "CertificateService"},
             {"Name", "Certificate Service"},
@@ -603,10 +605,12 @@
             }
             asyncResp->res.jsonValue = {
                 {"@odata.id", certURL},
-                {"@odata.type", "#Certificate.v1_0_0.Certificate"},
+                {"@odata.context", "/redfish/v1/$metadata#Certificate.Certificate"},
+                {"@odata.type", "#Certificate.v1_1_1.Certificate"},
                 {"Id", std::to_string(certId)},
                 {"Name", name},
-                {"Description", name}};
+                {"Description", name},
+                {"CertificateType", "PEM"}};
             for (const auto& property : properties)
             {
                 if (property.first == "CertificateString")
@@ -886,6 +890,8 @@
         res.jsonValue = {
             {"@odata.id",
              "/redfish/v1/Managers/bmc/NetworkProtocol/HTTPS/Certificates"},
+            {"@odata.context", "/redfish/v1/$metadata#"
+		    		"CertificateCollection.CertificateCollection"},
             {"@odata.type", "#CertificateCollection.CertificateCollection"},
             {"Name", "HTTPS Certificates Collection"},
             {"Description", "A Collection of HTTPS certificate instances"}};
@@ -1003,8 +1009,10 @@
         res.jsonValue = {
             {"@odata.id",
              "/redfish/v1/CertificateService/CertificateLocations"},
+            {"@odata.context", "/redfish/v1/$metadata#"
+		    		"CertificateLocations.CertificateLocations"},
             {"@odata.type",
-             "#CertificateLocations.v1_0_0.CertificateLocations"},
+             "#CertificateLocations.v1_0_2.CertificateLocations"},
             {"Name", "Certificate Locations"},
             {"Id", "CertificateLocations"},
             {"Description",
@@ -1024,6 +1032,8 @@
         getCertificateLocations(
             asyncResp, "/redfish/v1/Managers/bmc/Truststore/Certificates/",
             certs::authorityObjectPath, certs::authorityServiceName);
+	asyncResp->res.addHeader(boost::beast::http::field::allow,
+                                 redfish::Header::GetAllowHeaders("CertificateLocations_v1.xml"));
     }
     /**
      * @brief Retrieve the certificates installed list and append to the
@@ -1091,6 +1101,8 @@
     {
         res.jsonValue = {
             {"@odata.id", "/redfish/v1/AccountService/LDAP/Certificates"},
+            {"@odata.context", "/redfish/v1/$metadata#"
+		    		"CertificateCollection.CertificateCollection"},
             {"@odata.type", "#CertificateCollection.CertificateCollection"},
             {"Name", "LDAP Certificates Collection"},
             {"Description", "A Collection of LDAP certificate instances"}};
@@ -1119,6 +1131,9 @@
                 }
                 asyncResp->res.jsonValue["Members@odata.count"] =
                     members.size();
+
+		asyncResp->res.addHeader(boost::beast::http::field::allow,
+                                         redfish::Header::GetAllowHeaders("CertificateCollection_v1.xml"));
             },
             certs::ldapServiceName, certs::ldapObjectPath,
             certs::dbusObjManagerIntf, "GetManagedObjects");
@@ -1160,6 +1175,10 @@
                 std::string certURL =
                     "/redfish/v1/AccountService/LDAP/Certificates/" +
                     std::to_string(certId);
+
+		asyncResp->res.addHeader(boost::beast::http::field::allow,
+                                         redfish::Header::GetAllowHeaders("CertificateCollection_v1.xml"));
+
                 getCertificateProperties(asyncResp, objectPath,
                                          certs::ldapServiceName, certId,
                                          certURL, "LDAP Certificate");
@@ -1237,6 +1256,8 @@
         res.jsonValue = {
             {"@odata.id", "/redfish/v1/Managers/bmc/Truststore/Certificates/"},
             {"@odata.type", "#CertificateCollection.CertificateCollection"},
+            {"@odata.context", "/redfish/v1/$metadata#"
+		    		"CertificateCollection.CertificateCollection"},
             {"Name", "TrustStore Certificates Collection"},
             {"Description",
              "A Collection of TrustStore certificate instances"}};
diff -Naur a/redfish-core/lib/chassis.hpp b/redfish-core/lib/chassis.hpp
--- a/redfish-core/lib/chassis.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/chassis.hpp	2020-09-23 15:57:33.693336939 +0530
@@ -21,7 +21,7 @@
 #include "headers.hpp"
 
 #include <boost/container/flat_map.hpp>
-
+#include <utils/systemd_utils.hpp>
 #include <variant>
 
 namespace redfish
@@ -105,7 +105,7 @@
 
             const std::string* status = std::get_if<std::string>(&value);
 
-            if (status == nullptr)
+            if (status == nullptr || *status == "unknown")
             {
                 BMCWEB_LOG_ERROR << "intrusion status read error \n";
                 return;
@@ -115,7 +115,7 @@
                 {"IntrusionSensorNumber", 1}, {"IntrusionSensor", *status}};
         },
         service, objPath, "org.freedesktop.DBus.Properties", "Get",
-        "xyz.openbmc_project.Chassis.Intrusion", "Status");
+        "xyz.openbmc_project.Sensor.Value", "Status");
 }
 
 /**
@@ -180,6 +180,8 @@
                const std::vector<std::string>& params) override
     {
         res.jsonValue["@odata.type"] = "#ChassisCollection.ChassisCollection";
+        res.jsonValue["@odata.context"] = "/redfish/v1/$metadata#"
+		                          "ChassisCollection.ChassisCollection";
         res.jsonValue["@odata.id"] = "/redfish/v1/Chassis";
         res.jsonValue["Name"] = "Chassis Collection";
 
@@ -321,7 +323,9 @@
                     }
 
                     asyncResp->res.jsonValue["@odata.type"] =
-                        "#Chassis.v1_10_0.Chassis";
+                        "#Chassis.v1_11_0.Chassis";
+                    asyncResp->res.jsonValue["@odata.context"] = 
+			"/redfish/v1/$metadata#Chassis.Chassis";
                     asyncResp->res.jsonValue["@odata.id"] =
                         "/redfish/v1/Chassis/" + chassisId;
                     asyncResp->res.jsonValue["Name"] = "Chassis Collection";
@@ -335,6 +339,7 @@
                     asyncResp->res.jsonValue["PCIeDevices"] = {
                         {"@odata.id",
                          "/redfish/v1/Systems/system/PCIeDevices"}};
+                    asyncResp->res.jsonValue["UUID"] = systemd_utils::getUuid();
 
                     const std::string& connectionName =
                         connectionNames[0].first;
@@ -345,6 +350,20 @@
                         "xyz.openbmc_project.Inventory.Item.Panel",
                         "xyz.openbmc_project.Inventory.Item.Board.Motherboard"};
 
+		    crow::connections::systemBus->async_method_call(
+                        [asyncResp](const boost::system::error_code ec,
+                                 std::variant<std::string>& resp) {
+                            if (ec)
+                            {
+                                return; // no AssestTag
+                            }
+			    std::string *AssetTag = std::get_if<std::string>(&resp);
+                            asyncResp->res.jsonValue["AssetTag"] = std::move(*AssetTag);
+                        },
+                        connectionName, path, "org.freedesktop.DBus.Properties",
+			"Get", 
+                        "xyz.openbmc_project.Inventory.Decorator.AssetTag", "AssetTag");
+
                     for (const char* interface : hasIndicatorLed)
                     {
                         if (std::find(interfaces.begin(), interfaces.end(),
@@ -384,6 +403,7 @@
                             }
                             asyncResp->res.jsonValue["Name"] = chassisId;
                             asyncResp->res.jsonValue["Id"] = chassisId;
+                            asyncResp->res.jsonValue["Description"] = "Chassis Bmc";
                             asyncResp->res.jsonValue["Thermal"] = {
                                 {"@odata.id", "/redfish/v1/Chassis/" +
                                                   chassisId + "/Thermal"}};
@@ -402,8 +422,13 @@
                             asyncResp->res
                                 .jsonValue["Links"]["ComputerSystems"] = {
                                 {{"@odata.id", "/redfish/v1/Systems/system"}}};
+			    asyncResp->res.jsonValue["Links"]
+				    ["ComputerSystems@odata.count"] = 1;
                             asyncResp->res.jsonValue["Links"]["ManagedBy"] = {
                                 {{"@odata.id", "/redfish/v1/Managers/bmc"}}};
+			    asyncResp->res.jsonValue["Links"]
+				    ["ManagedBy@odata.count"] = 1;
+
                             getChassisState(asyncResp);
 			    asyncResp->res.addHeader(boost::beast::http::field::allow,
                 	                             redfish::Header::GetAllowHeaders("Chassis_v1.xml"));
@@ -416,14 +441,16 @@
 
                 // Couldn't find an object with that name.  return an error
                 messages::resourceNotFound(
-                    asyncResp->res, "#Chassis.v1_10_0.Chassis", chassisId);
+                    asyncResp->res, "#Chassis.v1_11_0.Chassis", chassisId);
             },
             "xyz.openbmc_project.ObjectMapper",
             "/xyz/openbmc_project/object_mapper",
             "xyz.openbmc_project.ObjectMapper", "GetSubTree",
             "/xyz/openbmc_project/inventory", 0, interfaces);
 
-        getPhysicalSecurityData(asyncResp);
+	getIntrusionByService(asyncResp, 
+		"xyz.openbmc_project.IntrusionSensor",
+		"/xyz/openbmc_project/sensors/Intrusion/Chassis_Intrusion");
     }
 
     void doPatch(crow::Response& res, const crow::Request& req,
@@ -522,7 +549,7 @@
                 }
 
                 messages::resourceNotFound(
-                    asyncResp->res, "#Chassis.v1_10_0.Chassis", chassisId);
+                    asyncResp->res, "#Chassis.v1_11_0.Chassis", chassisId);
             },
             "xyz.openbmc_project.ObjectMapper",
             "/xyz/openbmc_project/object_mapper",
@@ -644,6 +671,8 @@
         res.jsonValue = {{"@odata.type", "#ActionInfo.v1_1_2.ActionInfo"},
                          {"@odata.id", "/redfish/v1/Chassis/" + chassisId +
                                            "/ResetActionInfo"},
+                         {"@odata.context", "/redfish/v1/$metadata#"
+				 	    "ActionInfo.ActionInfo"},
                          {"Name", "Reset Action Info"},
                          {"Id", "ResetActionInfo"},
                          {"Parameters",
diff -Naur a/redfish-core/lib/cpudimm.hpp b/redfish-core/lib/cpudimm.hpp
--- a/redfish-core/lib/cpudimm.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/cpudimm.hpp	2020-09-23 15:57:33.677336887 +0530
@@ -582,6 +582,8 @@
     {
         res.jsonValue["@odata.type"] =
             "#ProcessorCollection.ProcessorCollection";
+        res.jsonValue["@odata.context"] =
+	   "/redfish/v1/$metadata#ProcessorCollection.ProcessorCollection";
         res.jsonValue["Name"] = "Processor Collection";
 
         res.jsonValue["@odata.id"] = "/redfish/v1/Systems/system/Processors/";
@@ -631,6 +633,8 @@
         }
         const std::string& processorId = params[0];
         res.jsonValue["@odata.type"] = "#Processor.v1_7_0.Processor";
+        res.jsonValue["@odata.context"] =
+	   "/redfish/v1/$metadata#Processor.Processor";
         res.jsonValue["@odata.id"] =
             "/redfish/v1/Systems/system/Processors/" + processorId;
 
@@ -671,6 +675,8 @@
                const std::vector<std::string>& params) override
     {
         res.jsonValue["@odata.type"] = "#MemoryCollection.MemoryCollection";
+        res.jsonValue["@odata.context"] =
+	   "/redfish/v1/$metadata#MemoryCollection.MemoryCollection";
         res.jsonValue["Name"] = "Memory Module Collection";
         res.jsonValue["@odata.id"] = "/redfish/v1/Systems/system/Memory/";
         auto asyncResp = std::make_shared<AsyncResp>(res);
@@ -718,13 +724,15 @@
         const std::string& dimmId = params[0];
 
         res.jsonValue["@odata.type"] = "#Memory.v1_6_0.Memory";
+        res.jsonValue["@odata.context"] =
+	   "/redfish/v1/$metadata#Memory.Memory";
         res.jsonValue["@odata.id"] =
             "/redfish/v1/Systems/system/Memory/" + dimmId;
         auto asyncResp = std::make_shared<AsyncResp>(res);
 
         getDimmData(asyncResp, dimmId);
 	asyncResp->res.addHeader(boost::beast::http::field::allow,
-                                 redfish::Header::GetAllowHeaders("MemoryCollection_v1.xml"));
+                                 redfish::Header::GetAllowHeaders("Memory_v1.xml"));
     }
 };
 
diff -Naur a/redfish-core/lib/ethernet.hpp b/redfish-core/lib/ethernet.hpp
--- a/redfish-core/lib/ethernet.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/ethernet.hpp	2020-09-23 15:57:33.677336887 +0530
@@ -128,6 +128,7 @@
     std::string default_gateway;
     std::string ipv6_default_gateway;
     std::string mac_address;
+    std::string linkLocal;
     std::vector<std::uint32_t> vlan_id;
     std::vector<std::string> nameServers;
     std::vector<std::string> staticNameServers;
@@ -141,6 +142,7 @@
     std::optional<bool> useNTPServers;
     std::optional<bool> useUseDomainName;
     std::optional<std::string> dhcpv6OperatingMode;
+    std::optional<std::string> fallbackAddress;
 };
 
 // Helper function that changes bits netmask notation (i.e. /24)
@@ -271,7 +273,49 @@
 
 ////// 
 
+inline std::string
+    translateLinkLocalDbusToRedfish(const std::string &inputLinkLocal)
+{
+    if (inputLinkLocal ==
+        "xyz.openbmc_project.Network.EthernetInterface.LinkLocalConf.fallback")
+    {
+        return "AutoConfig";
+    }
+    else if (inputLinkLocal ==
+             "xyz.openbmc_project.Network.EthernetInterface.LinkLocalConf.none")
+    {
+        return "None";
+    }
+    else if (inputLinkLocal ==
+             "xyz.openbmc_project.Network.EthernetInterface.LinkLocalConf.both")
+    {
+        return "Static";
+    }
 
+    return "None";
+}
+
+inline std::string
+    translateLinkLocalRedfishToDbus(const std::string &inputLinkLocal)
+{
+    if (inputLinkLocal == "AutoConfig")
+    {
+        return "xyz.openbmc_project.Network.EthernetInterface.LinkLocalConf."
+               "fallback";
+    }
+    else if (inputLinkLocal == "None")
+    {
+        return "xyz.openbmc_project.Network.EthernetInterface.LinkLocalConf."
+               "none";
+    }
+    else if (inputLinkLocal == "Static")
+    {
+        return "xyz.openbmc_project.Network.EthernetInterface.LinkLocalConf."
+               "both";
+    }
+
+    return "";
+}
 
 inline bool extractEthernetInterfaceData(const std::string& ethiface_id,
                                          const GetManagedObjects& dbus_data,
@@ -399,6 +443,17 @@
                                 ethData.domainnames = std::move(*domainNames);
                             }
                         }
+			else if (propertyPair.first == "LinkLocalAutoConf")
+                        {
+                            const std::string *linkLocalConf =
+                                std::get_if<std::string>(&propertyPair.second);
+                            if (linkLocalConf != nullptr)
+                            {
+                                ethData.linkLocal =
+                                    translateLinkLocalDbusToRedfish(
+                                        *linkLocalConf);
+                            }
+                        }
                     }
                 }
             }
@@ -1097,6 +1152,8 @@
             "#EthernetInterfaceCollection.EthernetInterfaceCollection";
         res.jsonValue["@odata.id"] =
             "/redfish/v1/Managers/bmc/EthernetInterfaces";
+        res.jsonValue["@odata.context"] =
+	    "/redfish/v1/$metadata#EthernetInterfaceCollection.EthernetInterfaceCollection";
         res.jsonValue["Name"] = "Ethernet Network Interface Collection";
         res.jsonValue["Description"] =
             "Collection of EthernetInterfaces for this Manager";
@@ -1326,6 +1383,34 @@
             std::variant<bool>{value});
     }
 
+
+    void setDHCPFallback(const std::string &ifaceId, const std::string &value,
+                         const std::shared_ptr<AsyncResp> asyncResp)
+    {
+        std::string linkLocalConf = translateLinkLocalRedfishToDbus(value);
+        if (linkLocalConf.empty())
+        {
+            messages::propertyValueNotInList(asyncResp->res, value,
+                                             "FallbackAddress");
+            return;
+        }
+
+        crow::connections::systemBus->async_method_call(
+            [asyncResp](const boost::system::error_code ec) {
+                if (ec)
+                {
+                    BMCWEB_LOG_ERROR << "D-Bus responses error: " << ec;
+                    messages::internalError(asyncResp->res);
+                    return;
+                }
+            },
+            "xyz.openbmc_project.Network",
+            "/xyz/openbmc_project/network/" + ifaceId,
+            "org.freedesktop.DBus.Properties", "Set",
+            "xyz.openbmc_project.Network.EthernetInterface",
+            "LinkLocalAutoConf", std::variant<std::string>(linkLocalConf));
+    }
+
     void setDHCPv4Config(const std::string& propertyName, const bool& value,
                          const std::shared_ptr<AsyncResp> asyncResp)
     {
@@ -1454,7 +1539,12 @@
         BMCWEB_LOG_DEBUG << "set NTPEnabled...";
         setDHCPv4Config("NTPEnabled", nextNTP, asyncResp);
         BMCWEB_LOG_DEBUG << "set HostNameEnabled...";
-        setDHCPv4Config("HostNameEnabled", nextUseDomain, asyncResp);
+	setDHCPv4Config("HostNameEnabled", nextUseDomain, asyncResp);
+	if (v4dhcpParms.fallbackAddress)
+	{
+            BMCWEB_LOG_DEBUG << "set DHCPFallbackAddress...";
+            setDHCPFallback(ifaceId,*v4dhcpParms.fallbackAddress,asyncResp);
+	}
     }
 
     boost::container::flat_set<IPv4AddressData>::const_iterator
@@ -1851,6 +1941,7 @@
         json_response["MACAddress"] = ethData.mac_address;
         json_response["DHCPv4"]["DHCPEnabled"] =
             translateDHCPEnabledToBool(ethData.DHCPEnabled, true);
+	json_response["DHCPv4"]["FallbackAddress"] = ethData.linkLocal;
         json_response["DHCPv4"]["UseNTPServers"] = ethData.NTPEnabled;
         json_response["DHCPv4"]["UseDNSServers"] = ethData.DNSEnabled;
         json_response["DHCPv4"]["UseDomainName"] = ethData.HostNameEnabled;
@@ -1968,7 +2059,9 @@
                 }
 
                 asyncResp->res.jsonValue["@odata.type"] =
-                    "#EthernetInterface.v1_4_1.EthernetInterface";
+                    "#EthernetInterface.v1_5_1.EthernetInterface";
+                asyncResp->res.jsonValue["@odata.context"] =
+	            "/redfish/v1/$metadata#EthernetInterface.EthernetInterface";
                 asyncResp->res.jsonValue["Name"] = "Manager Ethernet Interface";
                 asyncResp->res.jsonValue["Description"] =
                     "Management Network Interface";
@@ -2022,7 +2115,8 @@
                                      v4dhcpParms.dhcpv4Enabled, "UseDNSServers",
                                      v4dhcpParms.useDNSServers, "UseNTPServers",
                                      v4dhcpParms.useNTPServers, "UseDomainName",
-                                     v4dhcpParms.useUseDomainName))
+                                     v4dhcpParms.useUseDomainName,"FallbackAddress",
+                                     v4dhcpParms.fallbackAddress))
             {
                 return;
             }
@@ -2213,6 +2307,8 @@
         const std::string& iface_id = params[1];
         res.jsonValue["@odata.type"] =
             "#VLanNetworkInterface.v1_1_0.VLanNetworkInterface";
+        res.jsonValue["@odata.context"] = 
+	    "/redfish/v1/$metadata#VLanNetworkInterface.VLanNetworkInterface";
         res.jsonValue["Name"] = "VLAN Network Interface";
 
         if (!verifyNames(parent_iface_id, iface_id))
@@ -2450,6 +2546,9 @@
                 asyncResp->res.jsonValue["@odata.type"] =
                     "#VLanNetworkInterfaceCollection."
                     "VLanNetworkInterfaceCollection";
+        	asyncResp->res.jsonValue["@odata.context"] = 
+	             "/redfish/v1/$metadata#"
+		     "VLanNetworkInterfaceCollection.VLanNetworkInterfaceCollection";
                 asyncResp->res.jsonValue["Name"] =
                     "VLAN Network Interface Collection";
 
diff -Naur a/redfish-core/lib/event_service.hpp b/redfish-core/lib/event_service.hpp
--- a/redfish-core/lib/event_service.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/event_service.hpp	2020-09-23 15:57:33.681336900 +0530
@@ -50,6 +50,7 @@
         auto asyncResp = std::make_shared<AsyncResp>(res);
         res.jsonValue = {
             {"@odata.type", "#EventService.v1_5_0.EventService"},
+            {"@odata.context", "/redfish/v1/$metadata#EventService.EventService"},
             {"Id", "EventService"},
             {"Name", "Event Service"},
             {"ServerSentEventUri",
@@ -200,6 +201,7 @@
         res.jsonValue = {
             {"@odata.type",
              "#EventDestinationCollection.EventDestinationCollection"},
+            {"@odata.context", "/redfish/v1/$metadata#EventDestinationCollection.EventDestinationCollection"},
             {"@odata.id", "/redfish/v1/EventService/Subscriptions"},
             {"Name", "Event Destination Collections"}};
 
@@ -567,6 +569,8 @@
             {"Protocol", "Redfish"}};
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/EventService/Subscriptions/" + id;
+        asyncResp->res.jsonValue["@odata.context"] =
+	    "/redfish/v1/$metadata#EventDestination.EventDestination";
         asyncResp->res.jsonValue["Id"] = id;
         asyncResp->res.jsonValue["Name"] = "Event Destination " + id;
         asyncResp->res.jsonValue["Destination"] = subValue->destinationUrl;
diff -Naur a/redfish-core/lib/led.hpp b/redfish-core/lib/led.hpp
--- a/redfish-core/lib/led.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/led.hpp	2020-09-23 15:57:33.681336900 +0530
@@ -33,6 +33,12 @@
 void getIndicatorLedState(std::shared_ptr<AsyncResp> aResp)
 {
     BMCWEB_LOG_DEBUG << "Get led groups";
+    aResp->res.jsonValue["IndicatorLED@Redfish.AllowableValues"] = 
+    		{
+    		  "Lit",
+		  "Blinking",
+		  "Off"
+    		};
     crow::connections::systemBus->async_method_call(
         [aResp](const boost::system::error_code ec,
                 const std::variant<bool> asserted) {
@@ -154,4 +160,4 @@
         "xyz.openbmc_project.Led.Group", "Asserted",
         std::variant<bool>(ledBlinkng));
 }
-} // namespace redfish
\ No newline at end of file
+} // namespace redfish
diff -Naur a/redfish-core/lib/log_services.hpp b/redfish-core/lib/log_services.hpp
--- a/redfish-core/lib/log_services.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/log_services.hpp	2020-09-23 15:57:33.677336887 +0530
@@ -517,6 +517,8 @@
         // it has a duplicate entry for members
         asyncResp->res.jsonValue["@odata.type"] =
             "#LogServiceCollection.LogServiceCollection";
+        asyncResp->res.jsonValue["@odata.context"] =
+	    "/redfish/v1/$metadata#LogServiceCollection.LogServiceCollection";
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Systems/system/LogServices";
         asyncResp->res.jsonValue["Name"] = "System Log Services Collection";
@@ -597,14 +599,22 @@
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Systems/system/LogServices/EventLog";
         asyncResp->res.jsonValue["@odata.type"] =
-            "#LogService.v1_1_0.LogService";
+            "#LogService.v1_1_3.LogService";
+        asyncResp->res.jsonValue["@odata.context"] =
+	    "/redfish/v1/$metadata#LogService.LogService";
         asyncResp->res.jsonValue["Name"] = "Event Log Service";
-        res.jsonValue["DateTime"] = crow::utility::dateTimeNow();
+        std::string DateTime = crow::utility::dateTimeNow();
+        asyncResp->res.jsonValue["DateTime"] = DateTime;
+	asyncResp->res.jsonValue["DateTimeLocalOffset"] =
+	    			  DateTime.substr(DateTime.rfind("+"));
         asyncResp->res.jsonValue["Description"] = "System Event Log Service";
         asyncResp->res.jsonValue["Id"] = "EventLog";
         asyncResp->res.jsonValue["LogEntryType"] = "Event";
         asyncResp->res.jsonValue["MaxNumberOfRecords"] = 150;
         asyncResp->res.jsonValue["OverWritePolicy"] = "WrapsWhenFull";
+        asyncResp->res.jsonValue["ServiceEnabled"] = true;
+        asyncResp->res.jsonValue["Status"]["Health"] = "OK";
+        asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
         asyncResp->res.jsonValue["Entries"] = {
             {"@odata.id",
              "/redfish/v1/Systems/system/LogServices/EventLog/Entries"}};
@@ -750,7 +760,7 @@
 
     // Fill in the log entry with the gathered data
     logEntryJson = {
-        {"@odata.type", "#LogEntry.v1_4_0.LogEntry"},
+        {"@odata.type", "#LogEntry.v1_5_1.LogEntry"},
         {"@odata.id",
          "/redfish/v1/Systems/system/LogServices/EventLog/Entries/" +
              logEntryID},
@@ -802,6 +812,8 @@
             "#LogEntryCollection.LogEntryCollection";
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Systems/system/LogServices/EventLog/Entries";
+        asyncResp->res.jsonValue["@odata.context"] =
+	    "/redfish/v1/$metadata#LogEntryCollection.LogEntryCollection";
         asyncResp->res.jsonValue["Name"] = "System Event Log Entries";
         asyncResp->res.jsonValue["Description"] =
             "Collection of System Event Log Entries";
@@ -1066,7 +1078,7 @@
                             }
                         }
                         thisEntry = {
-                            {"@odata.type", "#LogEntry.v1_4_0.LogEntry"},
+                            {"@odata.type", "#LogEntry.v1_5_1.LogEntry"},
                             {"@odata.id",
                              "/redfish/v1/Systems/system/LogServices/EventLog/"
                              "Entries/" +
@@ -1194,7 +1206,7 @@
                     return;
                 }
                 asyncResp->res.jsonValue = {
-                    {"@odata.type", "#LogEntry.v1_4_0.LogEntry"},
+                    {"@odata.type", "#LogEntry.v1_5_1.LogEntry"},
                     {"@odata.id",
                      "/redfish/v1/Systems/system/LogServices/EventLog/"
                      "Entries/" +
@@ -1288,6 +1300,8 @@
             "#LogServiceCollection.LogServiceCollection";
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Managers/bmc/LogServices";
+        asyncResp->res.jsonValue["@odata.context"] =
+            "/redfish/v1/$metadata#LogServiceCollection.LogServiceCollection";
         asyncResp->res.jsonValue["Name"] = "Open BMC Log Services Collection";
         asyncResp->res.jsonValue["Description"] =
             "Collection of LogServices for this Manager";
@@ -1326,9 +1340,11 @@
     {
         std::shared_ptr<AsyncResp> asyncResp = std::make_shared<AsyncResp>(res);
         asyncResp->res.jsonValue["@odata.type"] =
-            "#LogService.v1_1_0.LogService";
+            "#LogService.v1_1_3.LogService";
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Managers/bmc/LogServices/Journal";
+        asyncResp->res.jsonValue["@odata.context"] =
+            "/redfish/v1/$metadata#LogService.LogService";
         asyncResp->res.jsonValue["Name"] = "Open BMC Journal Log Service";
         asyncResp->res.jsonValue["Description"] = "BMC Journal Log Service";
         asyncResp->res.jsonValue["Id"] = "BMC Journal";
@@ -1373,7 +1389,7 @@
 
     // Fill in the log entry with the gathered data
     bmcJournalLogEntryJson = {
-        {"@odata.type", "#LogEntry.v1_4_0.LogEntry"},
+        {"@odata.type", "#LogEntry.v1_5_1.LogEntry"},
         {"@odata.id", "/redfish/v1/Managers/bmc/LogServices/Journal/Entries/" +
                           bmcJournalLogEntryID},
         {"Name", "BMC Journal Entry"},
@@ -1425,8 +1441,8 @@
             "#LogEntryCollection.LogEntryCollection";
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Managers/bmc/LogServices/Journal/Entries";
-        asyncResp->res.jsonValue["@odata.id"] =
-            "/redfish/v1/Managers/bmc/LogServices/Journal/Entries";
+        asyncResp->res.jsonValue["@odata.context"] =
+            "/redfish/v1/$metadata#LogEntryCollection.LogEntryCollection";
         asyncResp->res.jsonValue["Name"] = "Open BMC Journal Entries";
         asyncResp->res.jsonValue["Description"] =
             "Collection of BMC Journal Entries";
@@ -1608,7 +1624,9 @@
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Systems/system/LogServices/System";
         asyncResp->res.jsonValue["@odata.type"] =
-            "#LogService.v1_1_0.LogService";
+            "#LogService.v1_1_3.LogService";
+        asyncResp->res.jsonValue["@odata.context"] =
+            "/redfish/v1/$metadata#LogService.LogService";
         asyncResp->res.jsonValue["Name"] = "Dump Log Service";
         asyncResp->res.jsonValue["Description"] = "System Dump Log Service";
         asyncResp->res.jsonValue["Id"] = "System";
@@ -1659,6 +1677,8 @@
             "#LogEntryCollection.LogEntryCollection";
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Systems/system/LogServices/System/Entries";
+        asyncResp->res.jsonValue["@odata.context"] =
+            "/redfish/v1/$metadata#LogEntryCollection.LogEntryCollection";
         asyncResp->res.jsonValue["Name"] = "System Dump Entries";
         asyncResp->res.jsonValue["Description"] =
             "Collection of System Dump Entries";
@@ -1817,7 +1837,7 @@
                         }
                     }
                     asyncResp->res.jsonValue = {
-                        {"@odata.type", "#LogEntry.v1_4_0.LogEntry"},
+                        {"@odata.type", "#LogEntry.v1_5_1.LogEntry"},
                         {"@odata.id",
                          "/redfish/v1/Systems/system/LogServices/System/"
                          "Entries/" +
@@ -2003,7 +2023,9 @@
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Systems/system/LogServices/Crashdump";
         asyncResp->res.jsonValue["@odata.type"] =
-            "#LogService.v1_1_0.LogService";
+            "#LogService.v1_1_3.LogService";
+        asyncResp->res.jsonValue["@odata.context"] =
+            "/redfish/v1/$metadata#LogService.LogService";
         asyncResp->res.jsonValue["Name"] = "Open BMC Oem Crashdump Service";
         asyncResp->res.jsonValue["Description"] = "Oem Crashdump Service";
         asyncResp->res.jsonValue["Id"] = "Oem Crashdump";
@@ -2111,7 +2133,7 @@
             std::string crashdumpURI =
                 "/redfish/v1/Systems/system/LogServices/Crashdump/Entries/" +
                 logID + "/" + filename;
-            logEntryJson = {{"@odata.type", "#LogEntry.v1_4_0.LogEntry"},
+            logEntryJson = {{"@odata.type", "#LogEntry.v1_5_1.LogEntry"},
                             {"@odata.id", "/redfish/v1/Systems/system/"
                                           "LogServices/Crashdump/Entries/" +
                                               logID},
@@ -2174,6 +2196,8 @@
                 "#LogEntryCollection.LogEntryCollection";
             asyncResp->res.jsonValue["@odata.id"] =
                 "/redfish/v1/Systems/system/LogServices/Crashdump/Entries";
+            asyncResp->res.jsonValue["@odata.context"] =
+                "/redfish/v1/$metadata#LogEntryCollection.LogEntryCollection";
             asyncResp->res.jsonValue["Name"] = "Open BMC Crashdump Entries";
             asyncResp->res.jsonValue["Description"] =
                 "Collection of Crashdump Entries";
@@ -2672,7 +2696,7 @@
 
         asyncResp->res.jsonValue = {
             {"@odata.id", "/redfish/v1/Systems/system/LogServices/PostCodes"},
-            {"@odata.type", "#LogService.v1_1_0.LogService"},
+            {"@odata.type", "#LogService.v1_1_3.LogService"},
             {"@odata.context", "/redfish/v1/$metadata#LogService.LogService"},
             {"Name", "POST Code Log Service"},
             {"Description", "POST Code Log Service"},
@@ -2835,7 +2859,7 @@
         logEntryArray.push_back({});
         nlohmann::json& bmcLogEntry = logEntryArray.back();
         bmcLogEntry = {
-            {"@odata.type", "#LogEntry.v1_4_0.LogEntry"},
+            {"@odata.type", "#LogEntry.v1_5_3.LogEntry"},
             {"@odata.context", "/redfish/v1/$metadata#LogEntry.LogEntry"},
             {"@odata.id", "/redfish/v1/Systems/system/LogServices/"
                           "PostCodes/Entries/" +
@@ -3077,7 +3101,7 @@
                              << params[0];
         }
 
-        asyncResp->res.jsonValue["@odata.type"] = "#LogEntry.v1_4_0.LogEntry";
+        asyncResp->res.jsonValue["@odata.type"] = "#LogEntry.v1_5_3.LogEntry";
         asyncResp->res.jsonValue["@odata.context"] =
             "/redfish/v1/$metadata#LogEntry.LogEntry";
         asyncResp->res.jsonValue["@odata.id"] =
diff -Naur a/redfish-core/lib/managers.hpp b/redfish-core/lib/managers.hpp
--- a/redfish-core/lib/managers.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/managers.hpp	2020-09-23 15:57:33.681336900 +0530
@@ -1680,7 +1680,8 @@
                const std::vector<std::string>& params) override
     {
         res.jsonValue["@odata.id"] = "/redfish/v1/Managers/bmc";
-        res.jsonValue["@odata.type"] = "#Manager.v1_9_0.Manager";
+        res.jsonValue["@odata.context"] = "/redfish/v1/$metadata#Manager.Manager";
+        res.jsonValue["@odata.type"] = "#Manager.v1_7_0.Manager";
         res.jsonValue["Id"] = "bmc";
         res.jsonValue["Name"] = "OpenBmc Manager";
         res.jsonValue["Description"] = "Baseboard Management Controller";
@@ -1705,6 +1706,10 @@
 
         res.jsonValue["SerialInterfaces"] = {
             {"@odata.id", "/redfish/v1/Managers/bmc/SerialInterface"}};
+	
+        res.jsonValue["RemoteAccountService"] = {
+            {"@odata.id", "/redfish/v1/AccountService"}};
+
         // default oem data
 /*        nlohmann::json& oem = res.jsonValue["Oem"];
         nlohmann::json& oemOpenbmc = oem["OpenBmc"];
@@ -1734,7 +1739,9 @@
             "/redfish/v1/Managers/bmc/Actions/Manager.ResetToDefaults";
         resetToDefaults["ResetType@Redfish.AllowableValues"] = {"ResetAll"};
 
-        res.jsonValue["DateTime"] = crow::utility::dateTimeNow();
+	std::string DateTime = crow::utility::dateTimeNow();
+        res.jsonValue["DateTime"] = DateTime;
+	res.jsonValue["DateTimeLocalOffset"] = DateTime.substr(DateTime.rfind("+"));
 
         // Fill in SerialConsole info
         res.jsonValue["SerialConsole"]["ServiceEnabled"] = true;
@@ -1744,7 +1751,7 @@
 #ifdef BMCWEB_ENABLE_KVM
         // Fill in GraphicalConsole info
         res.jsonValue["GraphicalConsole"]["ServiceEnabled"] = true;
-        res.jsonValue["GraphicalConsole"]["MaxConcurrentSessions"] = 4;
+        res.jsonValue["GraphicalConsole"]["MaxConcurrentSessions"] = 1;
         res.jsonValue["GraphicalConsole"]["ConnectTypesSupported"] = {"KVMIP"};
 #endif // BMCWEB_ENABLE_KVM
 
@@ -1758,14 +1765,22 @@
         health->isManagersHealth = true;
         health->populate();
 
-        fw_util::getActiveFwVersion(asyncResp, fw_util::bmcPurpose,
-                                    "FirmwareVersion", true);
+	fw_util::populateFirmwareInformation(asyncResp, fw_util::bmcPurpose,
+        	                             "FirmwareVersion", true);
 
-        getLastResetTime(asyncResp);
+	/**
+         * Commenting "LastResetTime" Property,
+         * as using Manager.v1_7_0.Manager
+         */
+        //getLastResetTime(asyncResp);
 
 //        auto pids = std::make_shared<GetPIDValues>(asyncResp);
 //        pids->run();
 
+	// Get the Board detials from FRU
+	// like Manufacturer, PartNumber, SerialNumber
+	getBoardiDetails(asyncResp);
+
         getMainChassisId(asyncResp, [](const std::string& chassisId,
                                        const std::shared_ptr<AsyncResp> aRsp) {
             aRsp->res.jsonValue["Links"]["ManagerForChassis@odata.count"] = 1;
@@ -1946,6 +1961,48 @@
         }
     }
 
+    void getBoardiDetails(std::shared_ptr<AsyncResp> aResp)
+    {
+        BMCWEB_LOG_DEBUG << "Getting Manager Board Details";
+
+        crow::connections::systemBus->async_method_call(
+            [aResp](const boost::system::error_code ec,
+                    const std::vector<std::pair<std::string,
+		   	  VariantType>>& propertiesList) {
+	            for (const std::pair<std::string, VariantType>&
+                                     property : propertiesList)
+                    {
+                        const std::string& propertyName =
+                             	   property.first;
+		        const std::string* value =
+                              	   std::get_if<std::string>(
+                              	   &property.second);
+			std::string key = "";
+
+		 	if (propertyName == "BOARD_MANUFACTURER")			 
+			{
+			    key = "Manufacturer";    	
+			}
+			else if (propertyName == "BOARD_PART_NUMBER")			 
+			{
+			    key = "PartNumber";    	
+			}
+			else if (propertyName == "BOARD_SERIAL_NUMBER")			 
+			{
+			    key = "SerialNumber";    	
+			}
+
+			if(value != nullptr && !(key.empty()))
+			{	
+			    aResp->res.jsonValue[key] = *value;
+			}
+                    }
+            },
+            "xyz.openbmc_project.FruDevice", "/xyz/openbmc_project/FruDevice/S2600WFT",
+            "org.freedesktop.DBus.Properties", "GetAll",
+            "xyz.openbmc_project.FruDevice");
+    }
+
     std::string uuid;
 };
 
@@ -1970,6 +2027,7 @@
         // Collections don't include the static data added by SubRoute
         // because it has a duplicate entry for members
         res.jsonValue["@odata.id"] = "/redfish/v1/Managers";
+        res.jsonValue["@odata.context"] = "/redfish/v1/$metadata#ManagerCollection.ManagerCollection";
         res.jsonValue["@odata.type"] = "#ManagerCollection.ManagerCollection";
         res.jsonValue["Name"] = "Manager Collection";
         res.jsonValue["Members@odata.count"] = 1;
diff -Naur a/redfish-core/lib/message_registries.hpp b/redfish-core/lib/message_registries.hpp
--- a/redfish-core/lib/message_registries.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/message_registries.hpp	2020-09-23 15:57:33.693336939 +0530
@@ -56,6 +56,8 @@
             {"@odata.type",
              "#MessageRegistryFileCollection.MessageRegistryFileCollection"},
             {"@odata.id", "/redfish/v1/Registries"},
+            {"@odata.context", 
+             "/redfish/v1/$metadata#MessageRegistryFileCollection.MessageRegistryFileCollection"},
             {"Name", "MessageRegistryFile Collection"},
             {"Description", "Collection of MessageRegistryFiles"},
             {"Members@odata.count", 3},
@@ -65,7 +67,7 @@
               {{"@odata.id", "/redfish/v1/Registries/OpenBMC"}}}}};
 
 	res.addHeader(boost::beast::http::field::allow,
-                      redfish::Header::GetAllowHeaders("MessageRegistryCollection_v1.xml"));
+                      redfish::Header::GetAllowHeaders("MessageRegistryFileCollection_v1.xml"));
 	
         res.end();
     }
@@ -121,7 +123,7 @@
         else
         {
             messages::resourceNotFound(
-                res, "#MessageRegistryFile.v1_1_0.MessageRegistryFile",
+                res, "#MessageRegistryFile.v1_1_3.MessageRegistryFile",
                 registry);
             res.end();
             return;
@@ -129,7 +131,9 @@
 
         res.jsonValue = {
             {"@odata.id", "/redfish/v1/Registries/" + registry},
-            {"@odata.type", "#MessageRegistryFile.v1_1_0.MessageRegistryFile"},
+            {"@odata.type", "#MessageRegistryFile.v1_1_3.MessageRegistryFile"},
+            {"@odata.context", 
+             "/redfish/v1/$metadata#MessageRegistryFile.MessageRegistryFile"},
             {"Name", registry + " Message Registry File"},
             {"Description",
              dmtf + registry + " Message Registry File Location"},
diff -Naur a/redfish-core/lib/network_protocol.hpp b/redfish-core/lib/network_protocol.hpp
--- a/redfish-core/lib/network_protocol.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/network_protocol.hpp	2020-09-23 15:57:33.681336900 +0530
@@ -60,7 +60,8 @@
 const static boost::container::flat_map<const char*, std::string>
     protocolToDBus{{"SSH", "dropbear"},
                    {"HTTPS", "bmcweb"},
-                   {"IPMI", "phosphor-ipmi-net"}};
+                   {"IPMI", "phosphor-ipmi-net"},
+    		   {"KVMIP", "start-ipkvm"}};
 
 inline void
     extractNTPServersAndDomainNamesData(const GetManagedObjects& dbus_data,
@@ -199,6 +200,8 @@
             "#ManagerNetworkProtocol.v1_5_0.ManagerNetworkProtocol";
         asyncResp->res.jsonValue["@odata.id"] =
             "/redfish/v1/Managers/bmc/NetworkProtocol";
+        asyncResp->res.jsonValue["@odata.context"] =
+	    "/redfish/v1/$metadata#ManagerNetworkProtocol.ManagerNetworkProtocol";
         asyncResp->res.jsonValue["Id"] = "NetworkProtocol";
         asyncResp->res.jsonValue["Name"] = "Manager Network Protocol";
         asyncResp->res.jsonValue["Description"] = "Manager Network Service";
@@ -241,6 +244,11 @@
             asyncResp->res.jsonValue[protocol.first]["ProtocolEnabled"] = false;
         }
 
+ 	// Add Virtual Media details manually,
+	// as it dont use any service socket.	
+        asyncResp->res.jsonValue["VirtualMedia"]["Port"] = 443;
+        asyncResp->res.jsonValue["VirtualMedia"]["ProtocolEnabled"] = true;
+
         std::string hostName = getHostName();
 
         asyncResp->res.jsonValue["HostName"] = hostName;
@@ -290,7 +298,10 @@
                     std::string unitName = std::get<NET_PROTO_UNIT_NAME>(unit);
                     if (!boost::ends_with(unitName, ".socket"))
                     {
-                        continue;
+		        if (unitName != "start-ipkvm.service")
+			{
+                            continue;
+			}
                     }
 
                     for (auto& kv : protocolToDBus)
@@ -312,60 +323,71 @@
                             (unitState == "running") ||
                             (unitState == "listening");
 
-                        crow::connections::systemBus->async_method_call(
-                            [asyncResp,
-                             rfServiceKey{std::string(rfServiceKey)}](
-                                const boost::system::error_code ec,
-                                const std::variant<std::vector<std::tuple<
-                                    std::string, std::string>>>& resp) {
-                                if (ec)
-                                {
-                                    messages::internalError(asyncResp->res);
-                                    return;
-                                }
-                                const std::vector<
-                                    std::tuple<std::string, std::string>>*
-                                    responsePtr = std::get_if<std::vector<
-                                        std::tuple<std::string, std::string>>>(
-                                        &resp);
-                                if (responsePtr == nullptr ||
-                                    responsePtr->size() < 1)
-                                {
-                                    return;
-                                }
-
-                                const std::string& listenStream =
-                                    std::get<NET_PROTO_LISTEN_STREAM>(
-                                        (*responsePtr)[0]);
-                                std::size_t lastColonPos =
-                                    listenStream.rfind(":");
-                                if (lastColonPos == std::string::npos)
-                                {
-                                    // Not a port
-                                    return;
-                                }
-                                std::string portStr =
-                                    listenStream.substr(lastColonPos + 1);
-                                if (portStr.empty())
-                                {
+			if (std::string("KVMIP").compare(rfServiceKey))
+			{	
+                            crow::connections::systemBus->async_method_call(
+                                [asyncResp,
+                                 rfServiceKey{std::string(rfServiceKey)}](
+                                    const boost::system::error_code ec,
+                                    const std::variant<std::vector<std::tuple<
+                                        std::string, std::string>>>& resp) {
+                                    if (ec)
+                                    {
+                                        messages::internalError(asyncResp->res);
+                                        return;
+                                    }
+                                    const std::vector<
+                                        std::tuple<std::string, std::string>>*
+                                        responsePtr = std::get_if<std::vector<
+                                            std::tuple<std::string, std::string>>>(
+                                            &resp);
+                                    if (responsePtr == nullptr ||
+                                        responsePtr->size() < 1)
+                                    {
+                                        return;
+                                    }
+
+                                    const std::string& listenStream =
+                                        std::get<NET_PROTO_LISTEN_STREAM>(
+                                            (*responsePtr)[0]);
+                                    std::size_t lastColonPos =
+                                        listenStream.rfind(":");
+                                    if (lastColonPos == std::string::npos)
+                                    {
+                                        // Not a port
+                                        return;
+                                    }
+                                    std::string portStr =
+                                        listenStream.substr(lastColonPos + 1);
+                                    if (portStr.empty())
+                                    {
+                                        return;
+                                    }
+                                    char* endPtr = nullptr;
+                                    errno = 0;
+                                    // Use strtol instead of stroi to avoid
+                                    // exceptions
+                                    long port =
+                                        std::strtol(portStr.c_str(), &endPtr, 10);
+                                    if ((errno == 0) && (*endPtr == '\0'))
+                                    {
+                                        asyncResp->res
+                                            .jsonValue[rfServiceKey]["Port"] = port;
+                                    }
                                     return;
-                                }
-                                char* endPtr = nullptr;
-                                errno = 0;
-                                // Use strtol instead of stroi to avoid
-                                // exceptions
-                                long port =
-                                    std::strtol(portStr.c_str(), &endPtr, 10);
-                                if ((errno == 0) && (*endPtr == '\0'))
-                                {
-                                    asyncResp->res
-                                        .jsonValue[rfServiceKey]["Port"] = port;
-                                }
-                                return;
-                            },
-                            "org.freedesktop.systemd1", socketPath,
-                            "org.freedesktop.DBus.Properties", "Get",
-                            "org.freedesktop.systemd1.Socket", "Listen");
+                                },
+                                "org.freedesktop.systemd1", socketPath,
+                                "org.freedesktop.DBus.Properties", "Get",
+                                "org.freedesktop.systemd1.Socket", "Listen");
+			}
+			else
+			{
+			    // As KVM runs with libvncserver port,
+			    // so dont have seperate socket file,
+			    // so add the Port manaully. 
+			    asyncResp->res
+				.jsonValue[rfServiceKey]["Port"] = 5900;
+			}
 
                         // We found service, break the inner loop.
                         break;
diff -Naur a/redfish-core/lib/pcie.hpp b/redfish-core/lib/pcie.hpp
--- a/redfish-core/lib/pcie.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/pcie.hpp	2020-09-23 15:57:33.681336900 +0530
@@ -96,10 +96,11 @@
     {
         std::shared_ptr<AsyncResp> asyncResp = std::make_shared<AsyncResp>(res);
         asyncResp->res.jsonValue = {
+            {"@odata.context", "/redfish/v1/$metadata#PCIeDeviceCollection.PCIeDeviceCollection"},
             {"@odata.type", "#PCIeDeviceCollection.PCIeDeviceCollection"},
             {"@odata.id", "/redfish/v1/Systems/system/PCIeDevices"},
             {"Name", "PCIe Device Collection"},
-            {"Description", "Collection of PCIe Devices"},
+            {"Description", "The Collection of PCIe Devices"},
             {"Members", nlohmann::json::array()},
             {"Members@odata.count", 0}};
         getPCIeDeviceList(asyncResp, "Members");
@@ -161,11 +162,13 @@
                 }
 
                 asyncResp->res.jsonValue = {
+                    {"@odata.context", "/redfish/v1/$metadata#PCIeDevice.PCIeDevice"},
                     {"@odata.type", "#PCIeDevice.v1_4_0.PCIeDevice"},
                     {"@odata.id",
                      "/redfish/v1/Systems/system/PCIeDevices/" + device},
-                    {"Name", "PCIe Device"},
-                    {"Id", device}};
+                    {"Name", device + " PCIe Device"},
+                    {"Id", device},
+                    {"Description", device + " PCIe Device"}};
 
                 if (std::string* property = std::get_if<std::string>(
                         &pcieDevProperties["Manufacturer"]);
@@ -185,6 +188,9 @@
                     {"@odata.id", "/redfish/v1/Systems/system/PCIeDevices/" +
                                       device + "/PCIeFunctions"}};
 
+        	asyncResp->res.jsonValue["Status"]["Health"] = "OK";
+		asyncResp->res.jsonValue["Status"]["State"] = "Enabled";
+
 		asyncResp->res.addHeader(boost::beast::http::field::allow,
         	                         redfish::Header::GetAllowHeaders("PCIeDevice_v1.xml"));
             };
@@ -228,12 +234,14 @@
         }
         const std::string& device = params[0];
         asyncResp->res.jsonValue = {
+	    {"@odata.context",
+	     "/redfish/v1/$metadata#PCIeFunctionCollection.PCIeFunctionCollection"},
             {"@odata.type", "#PCIeFunctionCollection.PCIeFunctionCollection"},
             {"@odata.id", "/redfish/v1/Systems/system/PCIeDevices/" + device +
                               "/PCIeFunctions"},
             {"Name", "PCIe Function Collection"},
             {"Description",
-             "Collection of PCIe Functions for PCIe Device " + device}};
+             "The Collection of PCIe Functions for PCIe Device " + device}};
 
         auto getPCIeDeviceCallback =
             [asyncResp,
@@ -360,10 +368,12 @@
             }
 
             asyncResp->res.jsonValue = {
-                {"@odata.type", "#PCIeFunction.v1_2_0.PCIeFunction"},
+                {"@odata.context", "/redfish/v1/$metadata#PCIeFunction.PCIeFunction"},
+                {"@odata.type", "#PCIeFunction.v1_2_3.PCIeFunction"},
                 {"@odata.id", "/redfish/v1/Systems/system/PCIeDevices/" +
                                   device + "/PCIeFunctions/" + function},
-                {"Name", "PCIe Function"},
+                {"Name", "PCIe Function " + function},
+                {"Description", "The PCIe Function " + function},
                 {"Id", function},
                 {"FunctionId", std::stoi(function)},
                 {"Links",
@@ -371,6 +381,9 @@
                    {{"@odata.id",
                      "/redfish/v1/Systems/system/PCIeDevices/" + device}}}}}};
 
+                asyncResp->res.jsonValue["Status"] ["Health"] = "OK";
+                asyncResp->res.jsonValue["Status"] ["State"] = "Enabled";
+
             if (std::string* property = std::get_if<std::string>(
                     &pcieDevProperties["Function" + function + "DeviceId"]);
                 property)
diff -Naur a/redfish-core/lib/power.hpp b/redfish-core/lib/power.hpp
--- a/redfish-core/lib/power.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/power.hpp	2020-09-23 15:57:33.681336900 +0530
@@ -234,11 +234,12 @@
                         // Mandatory properties odata.id and MemberId
                         // A warning without a odata.type
                         tempArray.push_back(
-                            {{"@odata.type", "#Power.v1_0_0.PowerControl"},
+                            {{"@odata.type", "#Power.v1_6_0.PowerControl"},
                              {"@odata.id", "/redfish/v1/Chassis/" +
                                                sensorAsyncResp->chassisId +
                                                "/Power#/PowerControl/0"},
                              {"Name", "Chassis Power Control"},
+                             {"PhysicalContext", "Intake"},
                              {"MemberId", "0"}});
                     }
 
diff -Naur a/redfish-core/lib/redfish_sessions.hpp b/redfish-core/lib/redfish_sessions.hpp
--- a/redfish-core/lib/redfish_sessions.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/redfish_sessions.hpp	2020-09-23 15:57:33.681336900 +0530
@@ -61,7 +61,9 @@
         res.jsonValue["UserName"] = session->username;
         res.jsonValue["@odata.id"] =
             "/redfish/v1/SessionService/Sessions/" + session->uniqueId;
-        res.jsonValue["@odata.type"] = "#Session.v1_0_2.Session";
+        res.jsonValue["@odata.context"] =
+	   "/redfish/v1/$metadata#Session.Session";
+        res.jsonValue["@odata.type"] = "#Session.v1_2_1.Session";
         res.jsonValue["Name"] = "User Session";
         res.jsonValue["Description"] = "Manager User Session";
         res.jsonValue["Oem"]["OpenBMC"]["@odata.type"] =
@@ -70,6 +72,8 @@
         res.jsonValue["Oem"]["OpenBMC"]["ClientID"] = session->clientId;
 #endif
         res.jsonValue["Oem"]["OpenBMC"]["ClientOriginIP"] = session->clientIp;
+        res.jsonValue["Password"] = nullptr;
+        res.jsonValue["SessionType"] = "Redfish";
 	res.addHeader(boost::beast::http::field::allow,
                       redfish::Header::GetAllowHeaders("Session_v1.xml"));
         res.end();
@@ -166,6 +170,7 @@
         res.jsonValue["Members@odata.count"] = sessionIds.size();
         res.jsonValue["@odata.type"] = "#SessionCollection.SessionCollection";
         res.jsonValue["@odata.id"] = "/redfish/v1/SessionService/Sessions/";
+        res.jsonValue["@odata.context"] = "/redfish/v1/$metadata#SessionCollection.SessionCollection";
         res.jsonValue["Name"] = "Session Collection";
         res.jsonValue["Description"] = "Session Collection";
 	res.addHeader(boost::beast::http::field::allow,
@@ -287,8 +292,10 @@
     void doGet(crow::Response& res, const crow::Request& req,
                const std::vector<std::string>& params) override
     {
-        res.jsonValue["@odata.type"] = "#SessionService.v1_0_2.SessionService";
+        res.jsonValue["@odata.type"] = "#SessionService.v1_1_6.SessionService";
         res.jsonValue["@odata.id"] = "/redfish/v1/SessionService/";
+        res.jsonValue["@odata.context"] = 
+		"/redfish/v1/$metadata#SessionService.SessionService";
         res.jsonValue["Name"] = "Session Service";
         res.jsonValue["Id"] = "SessionService";
         res.jsonValue["Description"] = "Session Service";
@@ -300,6 +307,8 @@
         res.jsonValue["Sessions"] = {
             {"@odata.id", "/redfish/v1/SessionService/Sessions"}};
 
+	res.jsonValue["Status"]["Health"] = "OK";
+	res.jsonValue["Status"]["State"] = "Enabled";
 	res.addHeader(boost::beast::http::field::allow,
                       redfish::Header::GetAllowHeaders("SessionService_v1.xml"));
 
diff -Naur a/redfish-core/lib/roles.hpp b/redfish-core/lib/roles.hpp
--- a/redfish-core/lib/roles.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/roles.hpp	2020-09-23 15:57:33.681336900 +0530
@@ -105,7 +105,9 @@
         }
 
         res.jsonValue = {
-            {"@odata.type", "#Role.v1_2_2.Role"},
+            {"@odata.type", "#Role.v1_2_4.Role"},
+            {"@odata.context", "/redfish/v1/$metadata#"
+		    		"Role.Role"},
             {"Name", "User Role"},
             {"Description", roleId + " User Role"},
             {"OemPrivileges", nlohmann::json::array()},
@@ -114,6 +116,8 @@
             {"RoleId", roleId},
             {"@odata.id", "/redfish/v1/AccountService/Roles/" + roleId},
             {"AssignedPrivileges", std::move(privArray)}};
+	res.addHeader(boost::beast::http::field::allow,
+                      redfish::Header::GetAllowHeaders("Role_v1.xml"));
         res.end();
     }
 };
@@ -139,6 +143,8 @@
     {
         auto asyncResp = std::make_shared<AsyncResp>(res);
         res.jsonValue = {{"@odata.id", "/redfish/v1/AccountService/Roles"},
+            		 {"@odata.context", "/redfish/v1/$metadata#"
+		    		            "RoleCollection.RoleCollection"},
                          {"@odata.type", "#RoleCollection.RoleCollection"},
                          {"Name", "Roles Collection"},
                          {"Description", "BMC User Roles"}};
@@ -173,6 +179,9 @@
                 }
                 asyncResp->res.jsonValue["Members@odata.count"] =
                     memberArray.size();
+
+		asyncResp->res.addHeader(boost::beast::http::field::allow,
+        	          	         redfish::Header::GetAllowHeaders("RoleCollection_v1.xml"));
             },
             "xyz.openbmc_project.User.Manager", "/xyz/openbmc_project/user",
             "org.freedesktop.DBus.Properties", "Get",
diff -Naur a/redfish-core/lib/sensors.hpp b/redfish-core/lib/sensors.hpp
--- a/redfish-core/lib/sensors.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/sensors.hpp	2020-09-23 15:57:33.693336939 +0530
@@ -26,6 +26,7 @@
 
 #include <cmath>
 #include <variant>
+#include <intel-ipmi-oem/sdrutils.hpp>
 
 #include "headers.hpp"
 
@@ -37,13 +38,15 @@
               std::vector<std::pair<std::string, std::vector<std::string>>>>>;
 
 using SensorVariant =
-    std::variant<int64_t, double, uint32_t, bool, std::string>;
+    std::variant<int64_t, double, uint32_t, bool, std::string, uint8_t>;
 
 using ManagedObjectsVectorType = std::vector<std::pair<
     sdbusplus::message::object_path,
     boost::container::flat_map<
         std::string, boost::container::flat_map<std::string, SensorVariant>>>>;
 
+constexpr char const *SensorObjPath = "/xyz/openbmc_project/sensors/";
+
 namespace sensors
 {
 namespace node
@@ -467,12 +470,16 @@
         if (chassisSubNode == sensors::node::power)
         {
             sensorsAsyncResp->res.jsonValue["@odata.type"] =
-                "#Power.v1_5_2.Power";
+                "#Power.v1_6_0.Power";
+            sensorsAsyncResp->res.jsonValue["@odata.context"] =
+	        "/redfish/v1/$metadata#Power.Power";
         }
         else if (chassisSubNode == sensors::node::thermal)
         {
             sensorsAsyncResp->res.jsonValue["@odata.type"] =
-                "#Thermal.v1_4_0.Thermal";
+                "#Thermal.v1_6_0.Thermal";
+            sensorsAsyncResp->res.jsonValue["@odata.context"] =
+	        "/redfish/v1/$metadata#Thermal.Thermal";
             sensorsAsyncResp->res.jsonValue["Fans"] = nlohmann::json::array();
             sensorsAsyncResp->res.jsonValue["Temperatures"] =
                 nlohmann::json::array();
@@ -481,6 +488,8 @@
         {
             sensorsAsyncResp->res.jsonValue["@odata.type"] =
                 "#SensorCollection.SensorCollection";
+            sensorsAsyncResp->res.jsonValue["@odata.context"] =
+	        "/redfish/v1/$metadata#SensorCollection.SensorCollection";
             sensorsAsyncResp->res.jsonValue["Description"] =
                 "Collection of Sensors for this Chassis";
             sensorsAsyncResp->res.jsonValue["Members"] =
@@ -841,6 +850,41 @@
         sensor_json["Name"] = boost::replace_all_copy(sensorName, "_", " ");
     }
 
+    // Get the SensorNumber from SDR,
+    // Check for the type of the sensor and set the object path accordingly,
+    // Send the sensor object path to the ipmi-oem/getSensorNumberFromPath()
+    // And add the sensor number in decimal format.
+    if (sensorType == "voltage")
+    {
+        sensor_json["SensorNumber"] = getSensorNumberFromPath (SensorObjPath +
+                                         std::string("voltage/") + sensorName);
+    }
+    else if (sensorType == "temperature")
+    {
+        sensor_json["SensorNumber"] = getSensorNumberFromPath (SensorObjPath +
+                                         std::string("temperature/") + sensorName);
+    }
+    else if (sensorType == "fan")
+    {
+        sensor_json["SensorNumber"] = getSensorNumberFromPath (SensorObjPath +
+                                         std::string("fan/") + sensorName);
+    }
+    else if (sensorType == "fan_tach")
+    {
+        sensor_json["SensorNumber"] = getSensorNumberFromPath (SensorObjPath +
+                                         std::string("fan_tach/") + sensorName);
+    }
+    else if (sensorType == "fan_pwm")
+    {
+        sensor_json["SensorNumber"] = getSensorNumberFromPath (SensorObjPath +
+                                         std::string("fan_pwm/") + sensorName);
+    }
+    else if (sensorType == "power")
+    {
+        sensor_json["SensorNumber"] = getSensorNumberFromPath (SensorObjPath +
+                                         std::string("power/") + sensorName);
+    }
+
     sensor_json["Status"]["State"] = getState(inventoryItem);
     sensor_json["Status"]["Health"] =
         getHealth(sensor_json, interfacesDict, inventoryItem);
@@ -853,7 +897,7 @@
     nlohmann::json::json_pointer unit("/Reading");
     if (sensorsAsyncResp->chassisSubNode == sensors::node::sensors)
     {
-        sensor_json["@odata.type"] = "#Sensor.v1_0_0.Sensor";
+        sensor_json["@odata.type"] = "#Sensor.v1_1_0.Sensor";
         if (sensorType == "power")
         {
             sensor_json["ReadingUnits"] = "Watts";
@@ -870,7 +914,8 @@
     else if (sensorType == "temperature")
     {
         unit = "/ReadingCelsius"_json_pointer;
-        sensor_json["@odata.type"] = "#Thermal.v1_3_0.Temperature";
+        sensor_json["@odata.type"] = "#Thermal.v1_6_0.Temperature";
+    	sensor_json["PhysicalContext"] = "Intake";
         // TODO(ed) Documentation says that path should be type fan_tach,
         // implementation seems to implement fan
     }
@@ -878,7 +923,8 @@
     {
         unit = "/Reading"_json_pointer;
         sensor_json["ReadingUnits"] = "RPM";
-        sensor_json["@odata.type"] = "#Thermal.v1_3_0.Fan";
+        sensor_json["@odata.type"] = "#Thermal.v1_6_0.Fan";
+    	sensor_json["PhysicalContext"] = "Fan";
         setLedState(sensor_json, inventoryItem);
         forceToInt = true;
     }
@@ -886,14 +932,16 @@
     {
         unit = "/Reading"_json_pointer;
         sensor_json["ReadingUnits"] = "Percent";
-        sensor_json["@odata.type"] = "#Thermal.v1_3_0.Fan";
+        sensor_json["@odata.type"] = "#Thermal.v1_6_0.Fan";
+    	sensor_json["PhysicalContext"] = "Fan";
         setLedState(sensor_json, inventoryItem);
         forceToInt = true;
     }
     else if (sensorType == "voltage")
     {
         unit = "/ReadingVolts"_json_pointer;
-        sensor_json["@odata.type"] = "#Power.v1_0_0.Voltage";
+        sensor_json["@odata.type"] = "#Power.v1_6_0.Voltage";
+    	sensor_json["PhysicalContext"] = "VoltageRegulator";
     }
     else if (sensorType == "power")
     {
@@ -902,7 +950,7 @@
 
         if (!sensorName.compare("total_power"))
         {
-            sensor_json["@odata.type"] = "#Power.v1_0_0.PowerControl";
+            sensor_json["@odata.type"] = "#Power.v1_6_0.PowerControl";
             // Put multiple "sensors" into a single PowerControl, so have
             // generic names for MemberId and Name. Follows Redfish mockup.
             sensor_json["MemberId"] = "0";
@@ -917,6 +965,8 @@
         {
             unit = "/PowerOutputWatts"_json_pointer;
         }
+    	
+	sensor_json["PhysicalContext"] = "Intake";
     }
     else
     {
@@ -986,6 +1036,11 @@
                                 "/MaxReadingRange"_json_pointer);
     }
 
+    // Adding the owenrLUN property as oem implementation.
+    properties.emplace_back("xyz.openbmc_project.Sensor.Value", "OwnerLun",
+	    		    "/OwnerLUN"_json_pointer);	    
+
+
     for (const std::tuple<const char*, const char*,
                           nlohmann::json::json_pointer>& p : properties)
     {
@@ -1006,7 +1061,10 @@
 
                 const double* doubleValue = std::get_if<double>(&valueVariant);
                 const uint32_t* uValue = std::get_if<uint32_t>(&valueVariant);
+                const uint8_t* ByteValue = std::get_if<uint8_t>(&valueVariant);
                 double temp = 0.0;
+		std::string PropertyName = std::get<1>(p);
+
                 if (int64Value != nullptr)
                 {
                     temp = static_cast<double>(*int64Value);
@@ -1019,21 +1077,31 @@
                 {
                     temp = *uValue;
                 }
+                else if (ByteValue != nullptr)
+                {
+		    sensor_json["Oem"]["Ami"] = {
+		    	{"@odata.type","#OemAMIChassisPowerThermal.v1_0_0.OemAMIChassisPowerThermal"},
+		    	{"OwnerLUN", *ByteValue}};
+                }
                 else
                 {
                     BMCWEB_LOG_ERROR
                         << "Got value interface that wasn't int or double";
                     continue;
                 }
-                temp = temp * std::pow(10, scaleMultiplier);
-                if (forceToInt)
-                {
-                    sensor_json[key] = static_cast<int64_t>(temp);
-                }
-                else
-                {
-                    sensor_json[key] = temp;
-                }
+
+		if(PropertyName != "OwnerLun")
+		{
+                    temp = temp * std::pow(10, scaleMultiplier);
+                    if (forceToInt)
+                    {
+                        sensor_json[key] = static_cast<int64_t>(temp);
+                    }
+                    else
+                    {
+                       sensor_json[key] = temp;
+                    }
+		}
             }
         }
     }
diff -Naur a/redfish-core/lib/serial_interface.hpp b/redfish-core/lib/serial_interface.hpp
--- a/redfish-core/lib/serial_interface.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/serial_interface.hpp	2020-09-23 15:57:33.681336900 +0530
@@ -218,7 +218,7 @@
 	asyncResp->res.jsonValue["Id"] =
 	    SerialInstance; 
 	asyncResp->res.jsonValue["InterfaceEnabled"] =
-	    "true";
+	    true;
         asyncResp->res.jsonValue["Name"] =
             SerialInstance;
 
diff -Naur a/redfish-core/lib/service_root.hpp b/redfish-core/lib/service_root.hpp
--- a/redfish-core/lib/service_root.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/service_root.hpp	2020-09-23 15:57:33.681336900 +0530
@@ -43,8 +43,10 @@
     void doGet(crow::Response& res, const crow::Request& req,
                const std::vector<std::string>& params) override
     {
-        res.jsonValue["@odata.type"] = "#ServiceRoot.v1_5_0.ServiceRoot";
-        res.jsonValue["@odata.id"] = "/redfish/v1";
+        res.jsonValue["@odata.type"] = "#ServiceRoot.v1_6_0.ServiceRoot";
+        res.jsonValue["@odata.context:"] =
+                      "/redfish/v1/$metadata#ServiceRoot.ServiceRoot";
+        res.jsonValue["@odata.id"] = "/redfish/v1/";
         res.jsonValue["Id"] = "RootService";
         res.jsonValue["Name"] = "Root Service";
         res.jsonValue["RedfishVersion"] = "1.9.0";
@@ -70,52 +72,11 @@
         res.jsonValue["Tasks"] = {{"@odata.id", "/redfish/v1/TaskService"}};
         res.jsonValue["EventService"] = {
             {"@odata.id", "/redfish/v1/EventService"}};
+	res.jsonValue["Description"] = "The service root for all Redfish requests on this host.";
+        res.jsonValue["Product"] = "AMI OSP Redfish Server";
+        res.jsonValue["Vendor"] = "AMI";
 
-#if 0
-	std::vector <std::string> allow_header;
-
-	allow_header.emplace_back("GET");
-
-	std::ifstream fileWriter;
-        fileWriter.open("/usr/share/www/redfish/v1/schema/ServiceRoot_v1.xml");
-        std::string temp_buf;
-
-	const char *ptr[3] = {"Insertable","Updatable","Deletable"};
-	const char *ptr2[3] = {"POST","PATCH","DELETE"};
-	for(int i=0; i<3; i++) {
-            while(std::getline(fileWriter,temp_buf))
-            {
-               if(temp_buf.find(ptr[i]) != std::string::npos)
-               {
-                  if(temp_buf.find("true") != std::string::npos)
-                  {
-	             allow_header.emplace_back(std::string(",") + ptr2[i]);	
-	             break;
-                  }
-               }
-            }
-	    fileWriter.clear();
-            fileWriter.seekg(0);
-	}
-        fileWriter.close();
-
-
-
-	//std::string temp1 = "GET";
-	//std::string temp2 = "PATCH";
-	//allow_header.emplace_back(temp1);
-	//allow_header.emplace_back(temp2);
-
-	std::string result;
-	for (auto const&s : allow_header)
-	{
-	   result += s;
-	}
-	
-	//std::string newstr ="PATCH,POST";
-#endif
 	res.addHeader(boost::beast::http::field::allow, redfish::Header::GetAllowHeaders("ServiceRoot_v1.xml"));
-	//res.addHeader(boost::beast::http::field::allow, result);
         res.end();
     }
 
diff -Naur a/redfish-core/lib/storage.hpp b/redfish-core/lib/storage.hpp
--- a/redfish-core/lib/storage.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/storage.hpp	2020-09-23 15:57:33.681336900 +0530
@@ -44,6 +44,8 @@
                const std::vector<std::string>& params) override
     {
         res.jsonValue["@odata.type"] = "#StorageCollection.StorageCollection";
+        res.jsonValue["@odata.context"] =
+	          "/redfish/v1/$metadata#StorageCollection.StorageCollection";
         res.jsonValue["@odata.id"] = "/redfish/v1/Systems/system/Storage";
         res.jsonValue["Name"] = "Storage Collection";
         res.jsonValue["Members"] = {
@@ -74,6 +76,8 @@
                const std::vector<std::string>& params) override
     {
         res.jsonValue["@odata.type"] = "#Storage.v1_7_1.Storage";
+        res.jsonValue["@odata.context"] =
+	          "/redfish/v1/$metadata#Storage.Storage";
         res.jsonValue["@odata.id"] = "/redfish/v1/Systems/system/Storage/1";
         res.jsonValue["Name"] = "Storage";
         res.jsonValue["Id"] = "1";
@@ -338,6 +342,8 @@
                 asyncResp->res.jsonValue["@odata.type"] = "#Drive.v1_7_0.Drive";
                 asyncResp->res.jsonValue["@odata.id"] =
                     "/redfish/v1/Systems/system/Storage/1/Drives/" + driveId;
+        	asyncResp->res.jsonValue["@odata.context"] =
+		    "/redfish/v1/$metadata#Drive.Drive";
                 asyncResp->res.jsonValue["Name"] = driveId;
                 asyncResp->res.jsonValue["Id"] = driveId;
 
@@ -355,6 +361,7 @@
                                   std::shared_ptr<AsyncResp> aRsp) {
                         aRsp->res.jsonValue["Links"]["Chassis"] = {
                             {"@odata.id", "/redfish/v1/Chassis/" + chassisId}};
+                        aRsp->res.jsonValue["Links"]["Chassis@odata.count"] = 1;
                     });
 
                 const std::string& connectionName = connectionNames[0].first;
diff -Naur a/redfish-core/lib/systems.hpp b/redfish-core/lib/systems.hpp
--- a/redfish-core/lib/systems.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/systems.hpp	2020-09-23 15:57:33.693336939 +0530
@@ -534,7 +534,7 @@
                                     }
 
                                     // Grab the bios version
-                                    fw_util::getActiveFwVersion(
+                                    fw_util::populateFirmwareInformation(
                                         aResp, fw_util::biosPurpose,
                                         "BiosVersion", false);
                                 },
@@ -600,8 +600,11 @@
                 const std::variant<std::string>& hostState) {
             if (ec)
             {
+                aResp->res.jsonValue["PowerState"] = "Off";
+                aResp->res.jsonValue["Status"]["State"] = "Disabled";
+
                 BMCWEB_LOG_DEBUG << "DBUS response error " << ec;
-                messages::internalError(aResp->res);
+                //messages::internalError(aResp->res);
                 return;
             }
 
@@ -802,6 +805,9 @@
 
             // TODO (Santosh): Do we need to support override mode?
             aResp->res.jsonValue["Boot"]["BootSourceOverrideMode"] = "Legacy";
+            aResp->res.jsonValue["Boot"]["BootSourceOverrideMode@"
+		    			 "Redfish.AllowableValues"] =
+						{"Legacy", "UEFI"};
             aResp->res.jsonValue["Boot"]["BootSourceOverrideTarget@Redfish."
                                          "AllowableValues"] = {
                 "None", "Pxe", "Hdd", "Cd", "Diags", "BiosSetup", "Usb"};
@@ -849,6 +855,10 @@
     BMCWEB_LOG_DEBUG << "Is one time: " << oneTimeEnabled;
     aResp->res.jsonValue["Boot"]["BootSourceOverrideEnabled"] =
         (oneTimeEnabled) ? "Once" : "Continuous";
+    aResp->res.jsonValue["Boot"] ["BootSourceOverrideEnabled@"
+	    			  "Redfish.AllowableValues"] =
+	   {"Disabled", "Once", "Continuous"};
+
 
     crow::connections::systemBus->async_method_call(
         [aResp, bootDbusObj](const boost::system::error_code ec,
@@ -1667,6 +1677,8 @@
         std::shared_ptr<AsyncResp> asyncResp = std::make_shared<AsyncResp>(res);
         res.jsonValue["@odata.type"] =
             "#ComputerSystemCollection.ComputerSystemCollection";
+        res.jsonValue["@odata.context"] =
+	    "/redfish/v1/$metadata#ComputerSystemCollection.ComputerSystemCollection";
         res.jsonValue["@odata.id"] = "/redfish/v1/Systems";
         res.jsonValue["Name"] = "Computer System Collection";
 
@@ -1892,7 +1904,9 @@
     void doGet(crow::Response& res, const crow::Request& req,
                const std::vector<std::string>& params) override
     {
-        res.jsonValue["@odata.type"] = "#ComputerSystem.v1_12_0.ComputerSystem";
+        res.jsonValue["@odata.type"] = "#ComputerSystem.v1_10_0.ComputerSystem";
+        res.jsonValue["@odata.context"] = 
+	    "/redfish/v1/$metadata#ComputerSystem.ComputerSystem";
         res.jsonValue["Name"] = "system";
         res.jsonValue["Id"] = "system";
         res.jsonValue["SystemType"] = "Physical";
@@ -1924,6 +1938,7 @@
 
         res.jsonValue["Links"]["ManagedBy"] = {
             {{"@odata.id", "/redfish/v1/Managers/bmc"}}};
+        res.jsonValue["Links"]["ManagedBy@odata.count"] = 1;
 
         res.jsonValue["Status"] = {
             {"Health", "OK"},
@@ -1960,6 +1975,7 @@
                                        std::shared_ptr<AsyncResp> aRsp) {
             aRsp->res.jsonValue["Links"]["Chassis"] = {
                 {{"@odata.id", "/redfish/v1/Chassis/" + chassisId}}};
+            aRsp->res.jsonValue["Links"]["Chassis@odata.count"] = 1;
         });
 
         getIndicatorLedState(asyncResp);
@@ -1970,7 +1986,11 @@
         getHostWatchdogTimer(asyncResp);
         getPowerRestorePolicy(asyncResp);
         getAutomaticRetry(asyncResp);
-        getLastResetTime(asyncResp);
+	/**
+	 * Commenting "LastResetTime" Property,
+	 * as using ComputerSystem.v1_10_0.ComputerSystem
+	 */
+        //getLastResetTime(asyncResp);
 #ifdef BMCWEB_ENABLE_REDFISH_PROVISIONING_FEATURE
         getProvisioningStatus(asyncResp);
 #endif
diff -Naur a/redfish-core/lib/task.hpp b/redfish-core/lib/task.hpp
--- a/redfish-core/lib/task.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/task.hpp	2020-09-23 15:57:33.693336939 +0530
@@ -148,6 +148,7 @@
             std::string uri = "/redfish/v1/TaskService/Tasks/" + strIdx;
             res.jsonValue = {{"@odata.id", uri},
                              {"@odata.type", "#Task.v1_4_3.Task"},
+	    		     {"@odata.context", "/redfish/v1/$metadata#Task.Task"},
                              {"Id", strIdx},
                              {"TaskState", state},
                              {"TaskStatus", status}};
@@ -353,6 +354,8 @@
         std::shared_ptr<task::TaskData>& ptr = *find;
 
         asyncResp->res.jsonValue["@odata.type"] = "#Task.v1_4_3.Task";
+        asyncResp->res.jsonValue["@odata.context"] =
+	    "/redfish/v1/$metadata#Task.Task";
         asyncResp->res.jsonValue["Id"] = strParam;
         asyncResp->res.jsonValue["Name"] = "Task " + strParam;
         asyncResp->res.jsonValue["TaskState"] = ptr->state;
@@ -402,6 +405,8 @@
         auto asyncResp = std::make_shared<AsyncResp>(res);
         asyncResp->res.jsonValue["@odata.type"] =
             "#TaskCollection.TaskCollection";
+        asyncResp->res.jsonValue["@odata.context"] =
+	    "/redfish/v1/$metadata#TaskCollection.TaskCollection";
         asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/TaskService/Tasks";
         asyncResp->res.jsonValue["Name"] = "Task Collection";
         asyncResp->res.jsonValue["Members@odata.count"] = task::tasks.size();
@@ -445,6 +450,8 @@
         auto asyncResp = std::make_shared<AsyncResp>(res);
         asyncResp->res.jsonValue["@odata.type"] =
             "#TaskService.v1_1_4.TaskService";
+        asyncResp->res.jsonValue["@odata.context"] =
+	    "/redfish/v1/$metadata#TaskService.TaskService";
         asyncResp->res.jsonValue["@odata.id"] = "/redfish/v1/TaskService";
         asyncResp->res.jsonValue["Name"] = "Task Service";
         asyncResp->res.jsonValue["Id"] = "TaskService";
diff -Naur a/redfish-core/lib/update_service.hpp b/redfish-core/lib/update_service.hpp
--- a/redfish-core/lib/update_service.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/update_service.hpp	2020-09-23 15:57:33.693336939 +0530
@@ -21,6 +21,7 @@
 #include <utils/fw_utils.hpp>
 
 #include <variant>
+#include <sys/statvfs.h>
 
 #include "headers.hpp"
 
@@ -371,6 +372,30 @@
         });
 }
 
+
+/**
+ * Get the Free Ram size for the /tmp dir
+ * and update the MaxImageSizeBytes property value.
+ */
+inline void getMemorySize(std::shared_ptr<AsyncResp> asyncResp)
+{
+    int ret;
+    uint64_t upload_t;
+    uint64_t keep_block = 1024;
+    struct statvfs stat_buf;
+
+    ret = statvfs("/tmp", &stat_buf);
+    if (ret != 0) {
+      // error happens, just quits here
+      BMCWEB_LOG_ERROR << 
+	    "Unable to get the MaxImageSizeBytes";
+      return;
+    }
+
+    upload_t = (stat_buf.f_bavail - keep_block) * stat_buf.f_bsize;
+    asyncResp->res.jsonValue ["MaxImageSizeBytes"] = upload_t;
+}
+
 /**
  * UpdateServiceActionsSimpleUpdate class supports handle POST method for
  * SimpleUpdate action.
@@ -524,7 +549,9 @@
                const std::vector<std::string>& params) override
     {
         std::shared_ptr<AsyncResp> aResp = std::make_shared<AsyncResp>(res);
-        res.jsonValue["@odata.type"] = "#UpdateService.v1_4_0.UpdateService";
+        res.jsonValue["@odata.type"] = "#UpdateService.v1_8_0.UpdateService";
+        res.jsonValue["@odata.context"] = 
+		"/redfish/v1/$metadata#UpdateService.UpdateService";
         res.jsonValue["@odata.id"] = "/redfish/v1/UpdateService";
         res.jsonValue["Id"] = "UpdateService";
         res.jsonValue["Description"] = "Service for Software Update";
@@ -532,6 +559,12 @@
         res.jsonValue["HttpPushUri"] = "/redfish/v1/UpdateService";
         // UpdateService cannot be disabled
         res.jsonValue["ServiceEnabled"] = true;
+        res.jsonValue["Status"] ["Health"] = "OK";
+        res.jsonValue["Status"] ["State"] = "Enabled";
+
+	//Get the MaxImageSizeBytes 
+	getMemorySize(aResp);
+
         res.jsonValue["FirmwareInventory"] = {
             {"@odata.id", "/redfish/v1/UpdateService/FirmwareInventory"}};
 #ifdef BMCWEB_INSECURE_ENABLE_REDFISH_FW_TFTP_UPDATE
@@ -716,6 +749,8 @@
             "#SoftwareInventoryCollection.SoftwareInventoryCollection";
         res.jsonValue["@odata.id"] =
             "/redfish/v1/UpdateService/FirmwareInventory";
+        res.jsonValue["@odata.context"] =
+	    "/redfish/v1/$metadata#SoftwareInventoryCollection.SoftwareInventoryCollection";
         res.jsonValue["Name"] = "Software Inventory Collection";
 
         crow::connections::systemBus->async_method_call(
@@ -829,6 +864,8 @@
 
         res.jsonValue["@odata.id"] =
             "/redfish/v1/UpdateService/FirmwareInventory/" + *swId;
+        res.jsonValue["@odata.context"] =
+	    "/redfish/v1/$metadata#SoftwareInventory.SoftwareInventory";
 
         crow::connections::systemBus->async_method_call(
             [asyncResp, swId](
@@ -961,7 +998,7 @@
                     return;
                 }
                 asyncResp->res.jsonValue["@odata.type"] =
-                    "#SoftwareInventory.v1_1_0.SoftwareInventory";
+                    "#SoftwareInventory.v1_2_3.SoftwareInventory";
                 asyncResp->res.jsonValue["Name"] = "Software Inventory";
                 asyncResp->res.jsonValue["Status"]["HealthRollup"] = "OK";
 
diff -Naur a/redfish-core/lib/virtual_media.hpp b/redfish-core/lib/virtual_media.hpp
--- a/redfish-core/lib/virtual_media.hpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/lib/virtual_media.hpp	2020-09-23 15:57:33.693336939 +0530
@@ -247,7 +247,7 @@
                 asyncResp->res.jsonValue = {
                     {"@odata.context",
                      "/redfish/v1/$metadata#VirtualMedia.VirtualMedia"},
-                    {"@odata.type", "#VirtualMedia.v1_3_1.VirtualMedia"},
+                    {"@odata.type", "#VirtualMedia.v1_3_2.VirtualMedia"},
                     {"Name", "Virtual Media Interface " + instanceName},
                     {"Description", "Virtual Media Instance redirected to host via this Manager"},
                     {"TransferMethod", "Stream"},
@@ -303,6 +303,7 @@
                 }
 
                asyncResp->res.jsonValue["UserName"] = UserName;
+               asyncResp->res.jsonValue["Password"] = nullptr;
                asyncResp->res.jsonValue["MediaTypes"] = { "CD" ,
                                                           "USBStick"};
                 asyncResp->res.jsonValue["@odata.id"] =
@@ -683,7 +684,7 @@
                     return;
                 }
 
-               messages::delayInActionCompletion(asyncResp->res, Instance,
+                messages::delayInActionCompletion(asyncResp->res, Instance,
                                                   "/redfish/v1/Managers/bmc/VirtualMedia" +Instance);
 
             },
diff -Naur a/redfish-core/src/error_messages.cpp b/redfish-core/src/error_messages.cpp
--- a/redfish-core/src/error_messages.cpp	2020-09-23 16:02:58.434212070 +0530
+++ b/redfish-core/src/error_messages.cpp	2020-09-23 15:57:33.693336939 +0530
@@ -1757,20 +1757,25 @@
  * See header file for more information
  * @endinternal
  */
-void delayInActionCompletion(crow::Response& res,const std::string& arg1,const std::string& arg2)
+nlohmann::json delayInActionCompletion(const std::string& arg1,
+				       const std::string& arg2)
+{
+    return nlohmann::json{
+        {"@odata.type", "/redfish/v1/$metadata#Message.v1_0_0.Message"},
+        {"MessageId", "Base.1.4.0.DelayInActionCompletion"},
+        {"Message", arg1 + " InsertMedia action has been initiated successfully."
+            "Please allow upto 4-5 secs and verify the value of Redirection Status property in "
+            +arg2},
+        {"MessageArgs", {arg1, arg2}},
+        {"Severity", "OK"},
+        {"Resolution", "Check the property value update after 4-5 seconds"}};
+}
+
+void delayInActionCompletion(crow::Response& res, const std::string& arg1,
+                   	     const std::string& arg2)
 {
     res.result(boost::beast::http::status::ok);
-    addMessageToJsonRoot(
-        res.jsonValue,
-        nlohmann::json{
-            {"@odata.type", "/redfish/v1/$metadata#Message.v1_0_0.Message"},
-            {"MessageId", "Base.1.4.0.DelayInActionCompletion"},
-            {"Message", arg1 + " InsertMedia action has been initiated successfully."
-                "Please allow upto 4-5 secs and verify the value of Redirection Status property in "
-                +arg2},
-            {"MessageArgs", {arg1, arg2}},
-            {"Severity", "OK"},
-            {"Resolution", "Check the property value update after 4-5 seconds"}});
+    addMessageToErrorJson(res.jsonValue, delayInActionCompletion(arg1, arg2));
 }
 
 /**
@@ -1780,11 +1785,15 @@
  * See header file for more information
  * @endinternal
  */
+nlohmann::json noContent(void)
+{
+    return nlohmann::json{0,0,0,0,0,0};
+}
+
 void noContent(crow::Response& res)
 {
     res.result(boost::beast::http::status::no_content);
-    addMessageToJsonRoot(
-        res.jsonValue,nlohmann::json{0,0,0,0,0,0});
+    addMessageToErrorJson(res.jsonValue, noContent());
 }
 
 /**
@@ -1794,19 +1803,22 @@
  * See header file for more information
  * @endinternal
  */
-void instanceInUse(crow::Response& res,const std::string& arg1)
+nlohmann::json instanceInUse(const std::string& arg1)
+{
+    return nlohmann::json{
+           {"@odata.type", "/redfish/v1/$metadata#Message.v1_0_0.Message"},
+           {"MessageId", "Base.1.4.0.InstanceInUse"},
+           {"Message", "Virtual Media Redirection for Instance " +arg1+ " is already in running state."},
+           {"MessageArgs", {arg1}},
+           {"Severity", "Warning"},
+           {"Resolution", "Please try with another Instnace or"
+                          "Eject the Media for " +arg1+ " and try again."}};
+}
+
+void instanceInUse(crow::Response& res, const std::string& arg1)
 {
     res.result(boost::beast::http::status::service_unavailable);
-    addMessageToErrorJson(
-        res.jsonValue,
-        nlohmann::json{
-            {"@odata.type", "/redfish/v1/$metadata#Message.v1_0_0.Message"},
-            {"MessageId", "Base.1.4.0.InstanceInUse"},
-            {"Message", "Virtual Media Redirection for Instance " +arg1+ " is already in running state."},
-            {"MessageArgs", {arg1}},
-            {"Severity", "Warning"},
-            {"Resolution", "Please try with another Instnace or"
-                          "Eject the Media for " +arg1+ " and try again."}});
+    addMessageToErrorJson(res.jsonValue, instanceInUse(arg1));
 }
 
 /**
@@ -1816,20 +1828,23 @@
  * See header file for more information
  * @endinternal
  */
+nlohmann::json instanceNotInUse(const std::string& arg1)
+{
+    return nlohmann::json{
+           {"@odata.type", "/redfish/v1/$metadata#Message.v1_0_0.Message"},
+           {"MessageId", "Base.1.4.0.InstanceIsNotInUse"},
+           {"Message", "Eject Media Action has been failed because "
+                      "Virtual Media Redirection is not running for the requested Instance " +arg1+
+                      ". Please Check the Status for " +arg1+ " using /redfish/v1/Managers/Self/VirtualMedia/" +arg1},
+           {"MessageArgs", {arg1}},
+           {"Severity", "Warning"},
+           {"Resolution", "Please try with another Instnace or first perform InsertMedia Action and try again"}};
+}
+
 void instanceNotInUse(crow::Response& res,const std::string& arg1)
 {
     res.result(boost::beast::http::status::bad_request);
-    addMessageToErrorJson(
-        res.jsonValue,
-        nlohmann::json{
-            {"@odata.type", "/redfish/v1/$metadata#Message.v1_0_0.Message"},
-            {"MessageId", "Base.1.4.0.InstanceIsNotInUse"},
-            {"Message", "Eject Media Action has been failed because "
-                       "Virtual Media Redirection is not running for the requested Instance " +arg1+
-                       ". Please Check the Status for " +arg1+ " using /redfish/v1/Managers/Self/VirtualMedia/" +arg1},
-            {"MessageArgs", {arg1}},
-            {"Severity", "Warning"},
-            {"Resolution", "Please try with another Instnace or first perform InsertMedia Action and try again"}});
+    addMessageToErrorJson(res.jsonValue, instanceNotInUse(arg1));
 }
 
 } // namespace messages
diff -Naur a/scripts/update_schemas.py b/scripts/update_schemas.py
--- a/scripts/update_schemas.py	2020-09-23 16:02:58.434212070 +0530
+++ b/scripts/update_schemas.py	2020-09-23 15:57:33.745337107 +0530
@@ -151,6 +151,12 @@
     metadata_index.write("        <edmx:Include Namespace=\"OemSession.v1_0_0\"/>\n")
     metadata_index.write("    </edmx:Reference>\n")
 
+    metadata_index.write(
+        "    <edmx:Reference Uri=\"/redfish/v1/schema/OemAMIChassisPowerThermal_v1.xml\">\n")
+    metadata_index.write("        <edmx:Include Namespace=\"OemAMIChassisPowerThermal\"/>\n")
+    metadata_index.write("        <edmx:Include Namespace=\"OemAMIChassisPowerThermal.v1_0_0\"/>\n")
+    metadata_index.write("    </edmx:Reference>\n")
+
     metadata_index.write("</edmx:Edmx>\n")
 
 schema_files = {}
diff -Naur a/static/redfish/v1/JsonSchemas/OemAMIChassisPowerThermal/index.json b/static/redfish/v1/JsonSchemas/OemAMIChassisPowerThermal/index.json
--- a/static/redfish/v1/JsonSchemas/OemAMIChassisPowerThermal/index.json	1970-01-01 05:30:00.000000000 +0530
+++ b/static/redfish/v1/JsonSchemas/OemAMIChassisPowerThermal/index.json	2020-09-23 15:57:33.837337408 +0530
@@ -0,0 +1,34 @@
+{
+  "$schema": "http://redfish.dmtf.org/schemas/v1/redfish-schema.v1_1_0.json",
+  "title": "#OemAMIChassisPowerThermal.v1_0_0.OemAMIChassisPowerThermal",
+  "$ref": "#/definitions/OemAMIChassisPowerThermal",
+  "definitions": {
+    "OemAMIChassisPowerThermal": {
+      "type": "object",
+      "patternProperties": {
+        "^([a-zA-Z_][a-zA-Z0-9_]*)?@(odata|Redfish|Message|Privileges)\\.[a-zA-Z_][a-zA-Z0-9_.]+$": {
+          "type": [
+            "array",
+            "boolean",
+            "number",
+            "null",
+            "object",
+            "string"
+          ],
+          "description": "This property shall specify a valid odata or Redfish property."
+        }
+      },
+      "additionalProperties": false,
+      "properties": {
+		    "@odata.type": {
+          "$ref": "http://redfish.dmtf.org/schemas/v1/odata.4.0.0.json#/definitions/type"
+        },
+		    "OwnerLUN":{
+			    "type": "number",
+			    "description": "This property shall specify the LUN number of a Temperature/Fan/Voltage Sensor."
+		    }
+      }
+    }
+  }
+}
+
diff -Naur a/static/redfish/v1/$metadata/index.xml b/static/redfish/v1/$metadata/index.xml
--- a/static/redfish/v1/$metadata/index.xml	2020-09-23 16:02:58.434212070 +0530
+++ b/static/redfish/v1/$metadata/index.xml	2020-09-23 15:57:33.821337357 +0530
@@ -2528,4 +2528,8 @@
         <edmx:Include Namespace="OemSession"/>
         <edmx:Include Namespace="OemSession.v1_0_0"/>
     </edmx:Reference>
+    <edmx:Reference Uri="/redfish/v1/schema/OemAMIChassisPowerThermal_v1.xml">
+        <edmx:Include Namespace="OemAMIChassisPowerThermal"/>
+        <edmx:Include Namespace="OemAMIChassisPowerThermal.v1_0_0"/>
+    </edmx:Reference>
 </edmx:Edmx>
diff -Naur a/static/redfish/v1/schema/OemAMIChassisPowerThermal_v1.xml b/static/redfish/v1/schema/OemAMIChassisPowerThermal_v1.xml
--- a/static/redfish/v1/schema/OemAMIChassisPowerThermal_v1.xml	1970-01-01 05:30:00.000000000 +0530
+++ b/static/redfish/v1/schema/OemAMIChassisPowerThermal_v1.xml	2020-09-23 15:57:33.997337941 +0530
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!---->
+<!--################################################################################       -->
+<!--# Redfish Schema:  OemAMIChassisPowerThermal  v1.0.0                                              -->
+<!--#                                                                                      -->
+<!--# Copyright American Megatrends, Inc. (AMI).                                           -->
+<!--################################################################################       -->
+<!---->
+<edmx:Edmx xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx" Version="4.0">
+	<edmx:Reference Uri="http://docs.oasis-open.org/odata/odata/v4.0/errata03/csd01/complete/vocabularies/Org.OData.Core.V1.xml">
+    	<edmx:Include Namespace="Org.OData.Core.V1" Alias="OData"/>
+    </edmx:Reference>
+    <edmx:Reference Uri="http://docs.oasis-open.org/odata/odata/v4.0/errata03/csd01/complete/vocabularies/Org.OData.Capabilities.V1.xml">
+    	<edmx:Include Namespace="Org.OData.Capabilities.V1" Alias="Capabilities"/>
+	</edmx:Reference>
+	<edmx:Reference Uri="http://redfish.dmtf.org/schemas/v1/Resource_v1.xml">
+		<edmx:Include Namespace="Resource"/>
+		<edmx:Include Namespace="Resource.v1_0_0"/>
+	</edmx:Reference>
+	<edmx:DataServices>
+		<Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="OemAMIChassisPowerThermal">
+			<EntityType Name="OemAMIChassisPowerThermal" Bool="false">
+				<Annotation Term="OData.Description" String="This is the schema definition for the OEM section under Chassis Power/Thermal URIs."/>
+				<Annotation Term="OData.LongDescription" String="This resource shall be used to represent the OEM attributes available under Chassis Power/Thermal URIs"/>
+				<Record>
+				    <PropertyValue Property="Insertable" Bool="false"/>
+				</Record>
+				</Annotation>
+				<Annotation Term="Capabilities.UpdateRestrictions">
+				<Record>
+			    	<PropertyValue Property="Updatable" Bool="false"/>
+				</Record>
+				</Annotation>
+				<Annotation Term="Capabilities.DeleteRestrictions">
+				<Record>
+				    <PropertyValue Property="Deletable" Bool="false"/>
+				</Record>
+				</Annotation>
+			</EntityType>
+		</Schema>
+		<Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="OemAMIChassisPowerThermal.v1_0_0">
+			<Annotation Term="Redfish.OwningEntity" String="AMI"/>
+			<EntityType Name="OemAMIChassisPowerThermal" BaseType="OemAMIChassisPowerThermal.OemAMIChassisPowerThermal">
+				<Annotation Term="OData.Description" String="This property shall specify a valid odata or Redfish property."/>
+				<Annotation Term="OData.LongDescription" String="This property shall specify a valid odata or Redfish property."/>
+				<Property Name="OwnerLUN" Type="Edm.Int64" Nullable="false">
+					<Annotation Term="OData.Permissions" EnumMember="OData.Permission/Read"/>
+					<Annotation Term="OData.Description" String="The LUN number of a Temperature/Fan/Voltage Sensor."/>
+					<Annotation Term="OData.LongDescription" String="The value of this property shall specify the LUN number of a Temperature/Fan/Voltage Sensor."/>
+				</Property>
+			</EntityType>
+		</Schema>
+	</edmx:DataServices>
+</edmx:Edmx>
+
