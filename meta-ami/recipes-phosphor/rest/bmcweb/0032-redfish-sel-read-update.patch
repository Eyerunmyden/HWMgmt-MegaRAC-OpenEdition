--- a/redfish-core/lib/log_services.hpp	2021-04-29 10:17:34.719228753 -0400
+++ b/redfish-core/lib/log_services.hpp	2021-04-29 10:15:49.596744575 -0400
@@ -20,6 +20,7 @@
 #include "registries/base_message_registry.hpp"
 #include "registries/openbmc_message_registry.hpp"
 #include "task.hpp"
+#include <xyz/openbmc_project/Common/error.hpp>
 
 #include <systemd/sd-journal.h>
 
@@ -38,6 +39,7 @@
 namespace redfish
 {
 
+using namespace phosphor::logging;
 constexpr char const* crashdumpObject = "com.intel.crashdump";
 constexpr char const* crashdumpPath = "/com/intel/crashdump";
 constexpr char const* crashdumpInterface = "com.intel.crashdump";
@@ -153,7 +155,9 @@
         "Version Change",
         "FRUState"
 	}; 
-	
+
+std::string logfileformat = "/var/sellog/redfish.";
+
 inline std::string translateSeverityDbusToRedfish(const std::string& s)
 {
     if ((s == "xyz.openbmc_project.Logging.Entry.Level.Alert") ||
@@ -476,8 +480,40 @@
 
 }
 
+bool customsort(string s1, string s2)
+{
+       int i , j;
+       size_t pos1, pos2;
+
+       pos1 = s1.find(logfileformat);
+       pos2 = s2.find(logfileformat);
+       if (pos1 != std::string::npos)
+       {
+               s1.erase(pos1,logfileformat.length());
+               i=std::stoi(s1);
+       }
+       else
+       {
+               i=0;
+       }
+       if (pos2 != std::string::npos)
+       {
+               s2.erase(pos2,logfileformat.length());
+               j=std::stoi(s2);
+       }
+       else
+       {
+               j=0;
+       }
+       if ( i==j)
+               return i > j;
+       else
+               return i < j;
+}
+
+
 static bool
-    getRedfishLogFiles(std::vector<std::filesystem::path>& redfishLogFiles)
+    getRedfishLogFiles(std::vector<std::string>& redfishLogFiles, unsigned int* fileindex)
 {
     static const std::filesystem::path redfishLogDir = "/var/sellog";
     static const std::string redfishLogFilename = "redfish";
@@ -491,17 +527,17 @@
         if (boost::starts_with(filename, redfishLogFilename))
         {
             redfishLogFiles.emplace_back(redfishLogDir / filename);
+	    *fileindex=*fileindex+1;
         }
     }
     // As the log files rotate, they are appended with a ".#" that is higher for
-    // the older logs. Since we don't expect more than 10 log files, we
-    // can just sort the list to get them in order from newest to oldest
-    std::sort(redfishLogFiles.begin(), redfishLogFiles.end());
+    // the older logs.
+    std::sort(redfishLogFiles.begin(), redfishLogFiles.end(), customsort);
 
     return !redfishLogFiles.empty();
 }
 
-static bool
+/*static bool
     getIpmiSelLogFiles(std::vector<std::filesystem::path>& IpmiSelLogFiles)
 {
     static const std::filesystem::path IpmiSelLogDir = "/var/sellog";
@@ -525,7 +561,7 @@
 
     return !IpmiSelLogFiles.empty();
 }
-
+*/
 
 inline void getDumpEntryCollection(std::shared_ptr<AsyncResp>& asyncResp,
                                    const std::string& dumpType)
@@ -1148,7 +1184,7 @@
         asyncResp->res.jsonValue["DateTimeLocalOffset"] =
                                  DateTime.substr(DateTime.rfind("+"));	
         asyncResp->res.jsonValue["LogEntryType"] = "Event";
-        asyncResp->res.jsonValue["MaxNumberOfRecords"] = 1000;	
+        asyncResp->res.jsonValue["MaxNumberOfRecords"] = OBMC_MAX_SEL_RECORDS;	
         asyncResp->res.jsonValue["ServiceEnabled"] = true;
         asyncResp->res.jsonValue["Status"]["Health"] = "OK";
         asyncResp->res.jsonValue["Status"]["State"] = "Enabled";	
@@ -1184,32 +1220,24 @@
     void doPost(crow::Response& res, const crow::Request&,
                 const std::vector<std::string>&) override
     {
+	    unsigned int fileindex = 0;
         std::shared_ptr<AsyncResp> asyncResp = std::make_shared<AsyncResp>(res);
 
-	// Clear the IPMI SEL Log by deleting the log files
-        std::vector<std::filesystem::path> IpmiSelLogFiles;
-        if (getIpmiSelLogFiles(IpmiSelLogFiles))
-        {
-            for (const std::filesystem::path& file : IpmiSelLogFiles)
-            {
-                std::error_code ec;
-                std::filesystem::remove(file, ec);
-            }
-        }
-
         // Clear the EventLog by deleting the log files
-        std::vector<std::filesystem::path> redfishLogFiles;
-        if (getRedfishLogFiles(redfishLogFiles))
-        {
-            for (const std::filesystem::path& file : redfishLogFiles)
-            {
-                std::error_code ec;
-                std::filesystem::remove(file, ec);
-            }
-        }
+        std::ofstream clearfile("/tmp/sel_busy");
+        std::vector<std::string> redfishLogFiles;
+        if (getRedfishLogFiles(redfishLogFiles, &fileindex))
+	{
+                       for (auto it = redfishLogFiles.begin(); it < redfishLogFiles.end();it++)
+                       {
+                              std::remove(it->c_str());
+                       }
 
+                       messages::success(asyncResp->res);
+        }
+        std::remove("/tmp/sel_busy");
         // Reload rsyslog so it knows to start new log files
-        crow::connections::systemBus->async_method_call(
+/*        crow::connections::systemBus->async_method_call(
             [asyncResp](const boost::system::error_code ec) {
                 if (ec)
                 {
@@ -1222,7 +1250,7 @@
             },
             "org.freedesktop.systemd1", "/org/freedesktop/systemd1",
             "org.freedesktop.systemd1.Manager", "ReloadUnit", "rsyslog.service",
-            "replace");
+            "replace");*/
 	genevent();
     }
 };
@@ -1493,19 +1521,85 @@
         nlohmann::json& logEntryArray = asyncResp->res.jsonValue["Members"];
         logEntryArray = nlohmann::json::array();
         // Go through the log files and create a unique ID for each entry
-        std::vector<std::filesystem::path> redfishLogFiles;
-        getRedfishLogFiles(redfishLogFiles);
-        uint64_t entryCount = 0;
-        std::string logEntry;
-		
-		unsigned int rec_id = 0;		
-		unsigned int MaxNumberOfRecords = 1000;
- 		unsigned int required_index = 0;
-		unsigned int i = 0;
-		std::vector<std::string> logEntryVector;
+        std::vector<std::string> redfishLogFiles;
+        unsigned int filecount = 0;
+        //check if resource busy
+        if(!access("/tmp/sel_busy",F_OK) || !access("/tmp/selrotate",F_OK))
+        {
+            messages::serviceTemporarilyUnavailable(asyncResp->res,"10");
+            return;
+        }
+        getRedfishLogFiles(redfishLogFiles, &filecount);
+	uint64_t entryCount = 0;
+	std::string logEntry, tempbuf;
+        unsigned int rec_id = 0, id_start = 0, required_index = 0, i = 0, j = 0, firstFileNumber = 0, index = 0, rot = 0;
+	std::vector<std::string> logEntryVector;
+
+               if(filecount != 1)
+               {
+                       try
+                       {
+                               index = std::stoul(redfishLogFiles.back().substr(20), nullptr,0);
+                       }
+                       catch(const std::exception& e)
+                       {
+                               log<level::ERR>(e.what());
+                       }
+               }
+
+               if (( rot == 0 ) && (filecount > 1))
+               {
+                       index = index + 1;
+                       if (index > MAX_FILE_INDEX)
+                       {
+                               for ( i = 1 ; i < filecount - 1 ; i++)
+                               {
+                                       try
+                                       {
+                                               index = std::stoul(redfishLogFiles[i].substr(20), nullptr,0);
+                                       }
+                                       catch(const std::exception& e)
+                                       {
+                                               log<level::ERR>(e.what());
+                                       }
+                                       if (index > filecount)
+                                               break;
+                               }
+                               rot = i - 1;
+                       }
+               }
+               // Oldest logs are in the file with least number. 'redfish' is the buffer file and contains latest records. So need to put 'redfish' in the end of the array
+               rotate(redfishLogFiles.begin(), redfishLogFiles.begin()+1, redfishLogFiles.end());
+               //if the file name crossess redfish.1024, the next file wil be redfish.1
+               if(rot > 0)
+               {
+                       rotate(redfishLogFiles.begin(), redfishLogFiles.begin()+static_cast<int>(rot), redfishLogFiles.end()-1);
+               }
+
+
+               if(filecount != 1)
+               {
+                       try
+                       {
+                               firstFileNumber = std::stoul(redfishLogFiles.front().substr(20), nullptr,0);
+                       }
+                       catch(const std::exception& e)
+                       {
+                               log<level::ERR>(e.what());
+                       }
+               }
+
+               //Set the starting record ID
+               if(filecount == 1 || firstFileNumber == 1)
+               {
+                       id_start = 1;
+               }
+               else if(firstFileNumber > 1)
+               {
+                       id_start = (firstFileNumber-1) * RECORDS_PER_FILE + 1;
+               }
 
-        // Oldest logs are in the last file, so start there and loop backwards
-        for (auto it = redfishLogFiles.rbegin(); it < redfishLogFiles.rend();
+        for (auto it = redfishLogFiles.begin(); it < redfishLogFiles.end();
              it++)
         {
             std::ifstream logStream(*it);
@@ -1514,47 +1608,26 @@
                 continue;
             }
 
-            // Reset the unique ID on the first entry
-            //bool firstEntry = true;
             while (std::getline(logStream, logEntry))
             {
                 entryCount++;
 				logEntryVector.push_back(logEntry);
-                // Handle paging using skip (number of entries to skip from the
-                // start) and top (number of entries to display)
-                /* if (entryCount <= skip || entryCount > skip + top)
-                {
-                    continue;
-                }
-
-                std::string idStr;
-                if (!getUniqueEntryID(logEntry, idStr, firstEntry))
-                {
-                    continue;
-                }
-
-                if (firstEntry)
-                {
-                    firstEntry = false;
-                }
-
-                logEntryArray.push_back({});
-                nlohmann::json& bmcLogEntry = logEntryArray.back();
-                if (fillEventLogEntryJson(idStr, logEntry, bmcLogEntry) != 0)
-                {
-                    messages::internalError(asyncResp->res);
-                    return;
-                } */
             }
         }
-		if(MaxNumberOfRecords >= entryCount)
+		if(OBMC_MAX_SEL_RECORDS >= entryCount)
 		{
-			required_index = 0;	
+			required_index = 0;
+			rec_id = 0;	
 		}
 		else 
 		{
-			required_index = static_cast<unsigned int>(entryCount) - MaxNumberOfRecords; 
+			required_index = static_cast<unsigned int>(entryCount) - OBMC_MAX_SEL_RECORDS; 
+			rec_id = required_index;
 		}
+
+               i = 0;
+               rec_id = rec_id + id_start;
+
 		for (auto it = logEntryVector.begin()+static_cast<int>(required_index); it < logEntryVector.end();
              it++, i++)
 			 {
@@ -1565,9 +1638,14 @@
 				}
 
 				std::string idStr;
+                                if(rec_id == 0xFFFF)
+                                {
+                                        rec_id = 1;
+                                }
 				idStr = std::to_string(rec_id);
 				rec_id++;
-				if (rec_id <= skip || rec_id > skip + top)
+                                j++;
+                                if (j <= skip || j > skip + top)
                 {
                     continue;
                 }
@@ -1580,8 +1658,16 @@
                 }
 				 
 			 }
-        asyncResp->res.jsonValue["Members@odata.count"] = rec_id;
-         if (skip + top < rec_id)
+               if(j > maxEntriesPerPage)
+               {
+                       asyncResp->res.jsonValue["Members@odata.count"] = maxEntriesPerPage;
+               }
+               else
+               {
+                       asyncResp->res.jsonValue["Members@odata.count"] = j;
+               }
+
+        if (skip + top < j)
         {
             asyncResp->res.jsonValue["Members@odata.nextLink"] =
                 "/redfish/v1/Systems/system/LogServices/EventLog/"
@@ -1593,6 +1679,285 @@
     }
 };
 
+static unsigned int CheckLatestTimestamp()
+{
+       struct stat st;
+       long int timediff;
+       long int newmod_time;
+       stat(SelInfo.FileName, &st);
+       newmod_time = st.st_mtime;
+
+       timediff = newmod_time - SelInfo.mod_time;
+       if (timediff)
+       {
+               SelInfo.mod_time = newmod_time;
+               return 1;
+       }
+       else
+               return 0;
+
+}
+
+
+static int CheckandLoadSELTable()
+{
+       std::vector<std::string> selLogFiles;
+       unsigned int ret=0,linecount=0,tempcount=0,fileindex=0,i=0,filecount = 0;
+       unsigned selindex[1024]={0};
+       std::string tempbuf;
+       std::string databuf;
+       size_t pos;
+       struct stat st;
+       unsigned int ignorerecord =0;
+       //get the filecount
+       getRedfishLogFiles(selLogFiles,&filecount);
+       totalfiles=filecount;
+
+       if ( filecount == 0 )
+               return 0;
+       else
+       {
+               if ( SelInfo.mod_time == 0 )
+               {
+                       strcpy(SelInfo.FileName,selLogFiles[0].c_str());
+                       stat(SelInfo.FileName, &st);
+                       SelInfo.mod_time=st.st_mtime;
+                       std::ifstream logStream(SelInfo.FileName);
+                       if (!logStream.is_open())
+                       {
+                               std::cout << "Error opening file" << endl;
+                       }
+                       while (std::getline(logStream, databuf))
+                               linecount++;
+                       SelInfo.SELEntries = linecount;
+                       logStream.close();
+
+                       //Calculate Total SEL Entries
+                       totalSELEntries = (filecount-1) * RECORDS_PER_FILE;
+                       totalSELEntries = totalSELEntries + SelInfo.SELEntries;
+                       //Calcuate First and Last SEL ID
+                       if (filecount > 1 )
+                       {
+
+                               tempbuf = selLogFiles[filecount-1];
+                               pos = tempbuf.find(logfileformat);
+                               if (pos != std::string::npos)
+                               {
+                                       tempbuf.erase(pos,logfileformat.length());
+                               }
+                               try
+                               {
+                                       fileindex=std::stoul(tempbuf);
+                               }
+                               catch (const std::exception& e)
+                               {
+                                         log<level::ERR>(e.what());
+                               }
+
+                               if ( fileindex == MAX_FILE_INDEX)
+                               {
+                                       MaxFlag =1;
+                                       totalSELEntries = totalSELEntries -2;
+                                       for ( i=1 ; i < filecount -1 ; i++)
+                                       {
+                                               tempbuf.clear();
+                                               tempbuf = selLogFiles[i];
+                                               pos = tempbuf.find(logfileformat);
+                                               if (pos != std::string::npos)
+                                               {
+                                                       tempbuf.erase(pos,logfileformat.length());
+                                               }
+                                               try
+                                               {
+                                                       fileindex=std::stoul(tempbuf);
+                                               }
+                                               catch(const std::exception& e)
+                                               {
+                                                        log<level::ERR>(e.what());
+                                               }
+
+                                               selindex[i]=fileindex;
+                                               if (fileindex > OBMC_MAX_SEL_RECORDS/RECORDS_PER_FILE)                                  
+                                                       break;
+                                       }
+                                       FirstSelId = ((fileindex - 1 ) * RECORDS_PER_FILE) + 1;
+                                       tempcount = i-1;
+                                       LastSelId = (selindex[tempcount] * RECORDS_PER_FILE) + SelInfo.SELEntries;
+                                       if (LastSelId == 0 )
+                                               LastSelId = maxRecordId;
+                               }
+                               else
+                               {
+                                       MaxFlag = 0;
+                                       LastSelId = (fileindex * RECORDS_PER_FILE) + SelInfo.SELEntries;
+                               }
+
+                               tempbuf.clear();
+                               tempbuf = selLogFiles[1];
+                               pos = tempbuf.find(logfileformat);
+                               if (pos != std::string::npos)
+                               {
+                                       tempbuf.erase(pos,logfileformat.length());
+                               }
+                               try
+                               {
+                                       fileindex=std::stoul(tempbuf);
+                               }
+                               catch (const std::exception& e)
+                               {
+                                       log<level::ERR>(e.what());
+                               }
+
+                               if (MaxFlag != 1)
+                               {
+                                       FirstSelId = ((fileindex - 1 ) * RECORDS_PER_FILE) + 1;
+                               }
+                       }
+                       else
+                       {
+                               FirstSelId = 1;
+                               LastSelId = SelInfo.SELEntries;
+                       }
+                       if ( totalSELEntries > OBMC_MAX_SEL_RECORDS)
+                       {
+                               ignorerecord = totalSELEntries - OBMC_MAX_SEL_RECORDS;
+                               FirstSelId = ignorerecord + FirstSelId;
+                       }
+
+               }
+               else
+               {
+                       ret = CheckLatestTimestamp();
+                       if ( ret == 1)
+                       {
+                               std::ifstream logStream(SelInfo.FileName);
+                               if (!logStream.is_open())
+                               {
+                                       std::cout << "Error opening file" << endl;
+                               }
+                               while (std::getline(logStream, databuf))
+                                       linecount++;
+                               SelInfo.SELEntries = linecount;
+                               logStream.close();
+
+                               //Calculate Total SEL Entries
+                               totalSELEntries = (filecount-1) * RECORDS_PER_FILE;
+                               totalSELEntries = totalSELEntries + SelInfo.SELEntries;
+                               //Calcuate First and Last SEL ID
+                               if (filecount > 1 )
+                               {
+
+                                       tempbuf = selLogFiles[filecount-1];
+                                       pos = tempbuf.find(logfileformat);
+                                       if (pos != std::string::npos)
+                                       {
+                                               tempbuf.erase(pos,logfileformat.length());
+                                       }
+                                       try
+                                       {
+                                               fileindex=std::stoul(tempbuf);
+                                       }
+                                       catch (const std::exception& e)
+                                        {
+                                                 log<level::ERR>(e.what());
+                                        }
+
+                                       if ( fileindex == MAX_FILE_INDEX)
+                                       {
+                                               MaxFlag =1;
+                                               totalSELEntries = totalSELEntries -2;
+                                               tempbuf = selLogFiles[filecount-1];
+                                               pos = tempbuf.find(logfileformat);
+                                               if (pos != std::string::npos)
+                                               {
+                                                       tempbuf.erase(pos,logfileformat.length());
+                                               }
+                                               try
+                                               {
+                                                       fileindex=std::stoul(tempbuf);
+                                               }
+                                               catch (const std::exception& e)
+                                               {
+                                                       log<level::ERR>(e.what());
+                                               }
+
+                                               for ( i=1 ; i < filecount -1 ; i++)
+                                               {
+                                                       tempbuf.clear();
+                                                       tempbuf = selLogFiles[i];
+                                                       pos = tempbuf.find(logfileformat);
+                                                       if (pos != std::string::npos)
+                                                       {
+                                                               tempbuf.erase(pos,logfileformat.length());
+                                                       }
+                                                       try
+                                                       {
+                                                               fileindex=std::stoul(tempbuf);
+                                                       }
+                                                       catch (const std::exception& e)
+                                                       {
+                                                               log<level::ERR>(e.what());
+                                                       }
+
+                                                       selindex[i]=fileindex;
+                                                       if (fileindex > OBMC_MAX_SEL_RECORDS/RECORDS_PER_FILE)                          
+                                                               break;
+                                               }
+                                               FirstSelId = ((fileindex - 1 ) * RECORDS_PER_FILE) + 1;
+                                               tempcount = i-1;
+                                               LastSelId = (selindex[tempcount] * RECORDS_PER_FILE) + SelInfo.SELEntries;
+
+                                               if (LastSelId == 0 )
+                                                       LastSelId = maxRecordId;
+
+                                       }
+                                       else
+                                       {
+                                               MaxFlag = 0;
+                                               LastSelId = (fileindex * RECORDS_PER_FILE) + SelInfo.SELEntries;
+                                       }
+
+                                       tempbuf.clear();
+                                       tempbuf = selLogFiles[1];
+                                       pos = tempbuf.find(logfileformat);
+                                       if (pos != std::string::npos)
+                                       {
+                                               tempbuf.erase(pos,logfileformat.length());
+                                       }
+                                       try
+                                       {
+                                               fileindex=std::stoul(tempbuf);
+                                       }
+                                       catch(const std::exception& e)
+                                        {
+                                                log<level::ERR>(e.what());
+                                        }
+
+                                       if (MaxFlag != 1 )
+                                       {
+                                               FirstSelId = ((fileindex - 1 ) * RECORDS_PER_FILE) + 1;
+                                       }
+                               }
+                               else
+                               {
+                                       FirstSelId = 1;
+                                       LastSelId = SelInfo.SELEntries;
+                               }
+                               if ( totalSELEntries > OBMC_MAX_SEL_RECORDS)
+                               {
+                                       ignorerecord = totalSELEntries - OBMC_MAX_SEL_RECORDS;
+                                       FirstSelId = ignorerecord + FirstSelId;
+                               }
+
+                       }
+
+                       else
+                               return 0;
+               }
+       }
+       return 0;
+}
+
 class JournalEventLogEntry : public Node
 {
   public:
@@ -1622,7 +1987,9 @@
 	    }
 	    const std::string& targetID = params[0];
 
-	    unsigned long int record_id;
+            std::string logEntry, lastFileName;
+            std::string filename = "/var/sellog/redfish.";
+            unsigned int record_id;
 	    try
 	    {	
 		    record_id = std::stoul(targetID,nullptr,0);
@@ -1637,62 +2004,130 @@
 		    messages::resourceMissingAtURI(res, targetID);
 		    return;
 	    }
-
+            //check if resource busy
+            if(!access("/tmp/sel_busy",F_OK) || !access("/tmp/selrotate",F_OK))
+            {
+                messages::serviceTemporarilyUnavailable(asyncResp->res,"10");
+                return;
+            }
 	    // Go through the log files and check the unique ID for each entry to
 	    // find the target entry
-	    std::vector<std::filesystem::path> redfishLogFiles;
-	    getRedfishLogFiles(redfishLogFiles);
-	    std::string logEntry;
-	    unsigned int entryCount = 0;
-	    unsigned int MaxNumberOfRecords = 1000;
-	    std::vector<std::string> logEntryVector;
-
-	    // Oldest logs are in the last file, so start there and loop backwards
-	    for (auto it = redfishLogFiles.rbegin(); it < redfishLogFiles.rend();
-			    it++)
-	    {
-		    std::ifstream logStream(*it);
-		    if (!logStream.is_open())
-		    {
-			    continue;
-		    }
-		    while (std::getline(logStream, logEntry))
-		    {
-                                if ((logEntry.substr(logEntry.find("OpenBMC."),logEntry.substr(logEntry.find("OpenBMC.")).find(",")).compare("OpenBMC.0.1")) == 0)
-                                {
-                                   BMCWEB_LOG_DEBUG << "Entry with Empty MessageId & Message found, Ignoring! ";
-                                   continue;
-                                }
-			    entryCount++;
-			    logEntryVector.push_back(logEntry);
-		    }
-	    }
-
-	    if((record_id > MaxNumberOfRecords) || (entryCount < MaxNumberOfRecords && record_id > entryCount))
-	    {
-		    messages::resourceMissingAtURI(asyncResp->res, targetID);
-		    return;
-	    }	
-
-	    if(entryCount > MaxNumberOfRecords)
-	    {
-		    record_id = entryCount - MaxNumberOfRecords + record_id;
-	    }
-	    if (fillEventLogEntryJson(targetID, logEntryVector[record_id],asyncResp->res.jsonValue) != 0)
-	    {
-		    messages::internalError(asyncResp->res);
-		    return;
-	    }
-	    else
-	    {
-		    asyncResp->res.addHeader(boost::beast::http::field::allow,
-				    redfish::Header::GetAllowHeaders("Event_v1.xml"));
-		    return;
+           //Load the SEL table
+               CheckandLoadSELTable();
+               unsigned int tempcount =0, tempindex = 0;
+               std::string tempbuf;
+
+               std::string databuf;
+               unsigned int linecount=0;
+               if(record_id == 0 || record_id > 0xFFFE)
+               {
+                       messages::resourceMissingAtURI(asyncResp->res, targetID);
+                       return;
+               }
+               if (MaxFlag == 0)
+               {
+                       if (record_id < FirstSelId || record_id > LastSelId)
+                       {
+                               messages::resourceMissingAtURI(asyncResp->res, targetID);
+                               return;
+                       }
+               }
+               else
+               {
+                       if(!((record_id > FirstSelId  &&  record_id < 0xFFFF) || (record_id >= 1 && record_id <= LastSelId)))
+                       {
+                               messages::resourceMissingAtURI(asyncResp->res, targetID);
+                               return;
+                       }
+
+               }
+
+               tempcount = record_id/RECORDS_PER_FILE;
+               if ( record_id % RECORDS_PER_FILE == 0)
+               {
+                       tempindex = tempcount;
+               }
+               else
+               {
+                       tempindex = tempcount + 1;
+               }
+
+               if ( tempindex > MAX_FILE_INDEX)
+               {
+                       tempindex = tempindex - MAX_FILE_INDEX;
+               }
+
+               linecount = ((tempindex - 1 ) * RECORDS_PER_FILE) + 1;
+               tempbuf.clear();
+               tempbuf = logfileformat + to_string(tempindex);
+               std::ifstream logStream(tempbuf.c_str());
+               if (!logStream.is_open())
+               {
+                       std::ifstream fileStream(SelInfo.FileName);
+                       if (!fileStream.is_open())
+                       {
+                               std::cout << "Error opening file" << endl;
+                       }
+
+                       while (std::getline(fileStream, databuf))
+                       {
+                               if (record_id == linecount)
+                               {
+                                       if ((databuf.substr(databuf.find("OpenBMC."),databuf.substr(databuf.find("OpenBMC.")).find(",")).compare("OpenBMC.0.1")) == 0)
+                                       {
+                                            BMCWEB_LOG_DEBUG << "Entry with Empty MessageId & Message found, Ignoring! ";
+                                            continue;
+                                       }
+
+                                       if (fillEventLogEntryJson(targetID, databuf, asyncResp->res.jsonValue) != 0)
+                                       {
+                                               messages::internalError(asyncResp->res);
+                                               return;
+                                       }
+                                       else
+                                       {
+                                               asyncResp->res.addHeader(boost::beast::http::field::allow, redfish::Header::GetAllowHeaders("Event_v1.xml"));
+                                               return;
+                                       }
+                               }
+                               linecount=linecount+1;
+                       }
+                       fileStream.close();
+               }
+               else
+               {
+                       while (std::getline(logStream, databuf))
+                       {
+                               if (record_id == linecount)
+                               {
+                                       if ((databuf.substr(databuf.find("OpenBMC."),databuf.substr(databuf.find("OpenBMC.")).find(",")).compare("OpenBMC.0.1")) == 0)
+                                       {
+                                            BMCWEB_LOG_DEBUG << "Entry with Empty MessageId & Message found, Ignoring! ";
+                                            continue;
+                                       }
+                                       if (fillEventLogEntryJson(targetID, databuf, asyncResp->res.jsonValue) != 0)
+                                       {
+                                               messages::internalError(asyncResp->res);
+                                               return;
+                                       }
+                                       else
+                                       {
+                                               asyncResp->res.addHeader(boost::beast::http::field::allow, redfish::Header::GetAllowHeaders("Event_v1.xml"));
+                                               return;
+                                       }
+                               }
+                               linecount=linecount+1;
+                       }
+                       logStream.close();
+               }
+
+               if(databuf.empty())
+               {
+                       messages::resourceMissingAtURI(asyncResp->res, targetID);
+                       return;
+               }
+       }
 
-	    }
-	    // Requested ID was not found
-	    messages::resourceMissingAtURI(asyncResp->res, targetID);
-    }
 };
 
 class DBusEventLogEntryCollection : public Node
--- a/redfish-core/include/headers.hpp  2021-04-29 08:30:12.507598376 -0400
+++ b/redfish-core/include/headers.hpp  2021-04-29 07:57:23.546936762 -0400
@@ -16,6 +16,34 @@
 #pragma once

 #include <vector>
+#include "projdef.h"
+#include <exception>
+#include <phosphor-logging/elog-errors.hpp>
+#include <phosphor-logging/log.hpp>
+
+#define RECORDS_PER_FILE 64
+#define MAX_FILE_INDEX 1024
+
+static unsigned int MaxFlag=0;
+static unsigned int maxRecordId =65534;
+static unsigned int FirstSelId=0;
+static unsigned int LastSelId=0;
+std::string logfileformat = "/var/sellog/redfish.";
+std::string filename = "/var/sellog/redfish";
+std::string selbusyflag="/tmp/sel_busy";
+const char *selrotatepath ="/tmp/selrotate";
+
+struct SELInfo_T
+{
+       char FileName[30];
+       long mod_time;
+       unsigned int SELEntries;
+};
+
+SELInfo_T SelInfo;
+
+unsigned int totalfiles=0;
+unsigned int totalSELEntries=0;

 namespace redfish
 {
