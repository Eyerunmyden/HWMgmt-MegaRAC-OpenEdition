--- a/CMakeLists.txt	2020-08-26 06:26:05.038873845 +0530
+++ b/CMakeLists.txt	2020-08-26 06:26:30.290882227 +0530
@@ -25,6 +25,7 @@
     -Wformat=2 \
     -Wno-sign-compare \
     -Wno-reorder \
+    -Wno-null-dereference \
 "
 )
 # todo: get rid of nos, add the below:
@@ -38,6 +39,8 @@
 
 option (DISABLE_ADC "Disable installing ADC sensor" OFF)
 option (DISABLE_CPU "Disable installing CPU sensor" ON)
+option (DISABLE_DIG_GPIO "Disable intialling digital gpio sensor" OFF)
+option (DISABLE_DISC_EVENT "Disable installing discrete event sensor" OFF)
 option (DISABLE_EXIT_AIR "Disable installing Exit Air Temp sensor" OFF)
 option (DISABLE_FAN "Disable installing fan sensor" OFF)
 option (DISABLE_HWMON_TEMP "Disable installing hwmon temp sensor" OFF)
@@ -58,6 +61,10 @@
 
 set (CPU_SRC_FILES src/Utils.cpp src/CPUSensor.cpp src/Thresholds.cpp)
 
+set (DIG_GPIO_SRC_FILES src/Utils.cpp src/GpioSensor.cpp)
+
+set (DISC_EVENT_SRC_FILES src/Utils.cpp src/EventSensor.cpp)
+
 set (EXIT_AIR_SRC_FILES src/Utils.cpp src/Thresholds.cpp)
 
 set (FAN_SRC_FILES src/TachSensor.cpp src/PwmSensor.cpp src/Utils.cpp
@@ -162,6 +169,14 @@
 target_link_libraries (cpusensor ${SENSOR_LINK_LIBS})
 target_link_libraries (cpusensor gpiodcxx)
 
+add_executable (gpiosensor src/GpioMain.cpp ${DIG_GPIO_SRC_FILES})
+add_dependencies (gpiosensor sdbusplus-project)
+target_link_libraries (gpiosensor ${SENSOR_LINK_LIBS})
+
+add_executable (eventsensor src/EventMain.cpp ${DISC_EVENT_SRC_FILES})
+add_dependencies (eventsensor sdbusplus-project)
+target_link_libraries (eventsensor ${SENSOR_LINK_LIBS})
+
 add_executable (exitairtempsensor src/ExitAirTempSensor.cpp
                 ${EXIT_AIR_SRC_FILES})
 add_dependencies (exitairtempsensor sdbusplus-project)
@@ -205,6 +220,8 @@
 if (NOT YOCTO)
     add_dependencies (adcsensor ${EXTERNAL_PACKAGES})
     add_dependencies (cpusensor ${EXTERNAL_PACKAGES})
+    add_dependencies (digitalsensor ${EXTERNAL_PACKAGES})
+    add_dependencies (discretesensor ${EXTERNAL_PACKAGES})
     add_dependencies (exitairtempsensor ${EXTERNAL_PACKAGES})
     add_dependencies (fansensor ${EXTERNAL_PACKAGES})
     add_dependencies (hwmontempsensor ${EXTERNAL_PACKAGES})
@@ -231,6 +248,22 @@
                  DESTINATION ${SERVICE_FILE_INSTALL_DIR})
 endif ()
 
+if (NOT DISABLE_DIG_GPIO)
+    install (TARGETS gpiosensor DESTINATION bin)
+    install (FILES
+               ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.gpiosensor.service
+               DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+
+endif()
+
+if (NOT DISABLE_DISC_EVENT)
+    install (TARGETS eventsensor DESTINATION bin)
+    install (FILES
+                ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.eventsensor.service
+                DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+
+endif()
+
 if (NOT DISABLE_EXIT_AIR)
     install (TARGETS exitairtempsensor DESTINATION bin)
     install (
diff -Naur a/include/ChassisIntrusionSensor.hpp b/include/ChassisIntrusionSensor.hpp
--- a/include/ChassisIntrusionSensor.hpp	2020-08-26 06:30:54.390972544 +0530
+++ b/include/ChassisIntrusionSensor.hpp	2020-08-26 06:31:18.770981083 +0530
@@ -17,15 +17,16 @@
   public:
     ChassisIntrusionSensor(
         boost::asio::io_service& io,
-        std::shared_ptr<sdbusplus::asio::dbus_interface> iface);
+        std::shared_ptr<sdbusplus::asio::dbus_interface> iface,std::shared_ptr<sdbusplus::asio::dbus_interface> ifacediscrete);
 
     ~ChassisIntrusionSensor();
 
     void start(IntrusionSensorType type, int busId, int slaveAddr,
-               bool gpioInverted);
+               bool gpioInverted, uint8_t dtype, uint8_t eventType, uint8_t evStat);
 
   private:
     std::shared_ptr<sdbusplus::asio::dbus_interface> mIface;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> mIfaceDiscrete;
     std::shared_ptr<sdbusplus::asio::connection> mDbusConn;
 
     IntrusionSensorType mType;
@@ -41,6 +42,7 @@
 
     // valid if it is via GPIO
     bool mGpioInverted;
+    uint8_t mdtype, meventType, mevStat;
     std::string mPinName = "CHASSIS_INTRUSION";
     gpiod::line mGpioLine;
     boost::asio::posix::stream_descriptor mGpioFd;
@@ -51,7 +53,7 @@
 
     bool mInitialized = false;
 
-    void updateValue(const std::string newValue);
+    void updateValue(const std::string newValue, bool v); 
     int i2cReadFromPch(int busId, int slaveAddr);
     void pollSensorStatusByPch();
     void readGpio();
diff -Naur a/include/EventSensor.hpp b/include/EventSensor.hpp
--- a/include/EventSensor.hpp	1970-01-01 05:30:00.000000000 +0530
+++ b/include/EventSensor.hpp	2020-08-26 06:31:18.778981085 +0530
@@ -0,0 +1,32 @@
+#pragma once
+
+#include <sdbusplus/asio/object_server.hpp>
+#include <sensor.hpp>
+
+class EventSensor : public DiscSensor
+{
+  public:
+   EventSensor(
+    const std::string& path, const std::string& objectType,
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t DType,uint8_t EventType,uint8_t EventOffset);
+
+    ~EventSensor();
+
+  private:
+    sdbusplus::asio::object_server& objServer;
+//    boost::asio::posix::stream_descriptor inputDev;
+    boost::asio::deadline_timer waitTimer;
+    boost::asio::streambuf readBuf;
+    std::string path;
+    int errCount;
+    uint8_t DType;
+    uint8_t EventType;
+    uint8_t EventOffset;
+    void setupRead(void);
+    void handleResponse(const boost::system::error_code& err);
+};
+
diff -Naur a/include/GpioSensor.hpp b/include/GpioSensor.hpp
--- a/include/GpioSensor.hpp	1970-01-01 05:30:00.000000000 +0530
+++ b/include/GpioSensor.hpp	2020-08-26 06:31:18.778981085 +0530
@@ -0,0 +1,32 @@
+#pragma once
+
+#include <sdbusplus/asio/object_server.hpp>
+#include <sensor.hpp>
+
+class GpioSensor : public DiscSensor
+{
+  public:
+   GpioSensor(
+    const std::string& path, const std::string& objectType,
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t DType,uint8_t EventType,uint8_t EventOffset);
+
+    ~GpioSensor();
+
+  private:
+    sdbusplus::asio::object_server& objServer;
+    boost::asio::posix::stream_descriptor inputDev;
+    boost::asio::deadline_timer waitTimer;
+    boost::asio::streambuf readBuf;
+    std::string path;
+    int errCount;
+    uint8_t DType;
+    uint8_t EventType;
+    uint8_t EventOffset;
+    void setupRead(void);
+    void handleResponse(const boost::system::error_code& err);
+};
+
diff -Naur a/include/sensor.hpp b/include/sensor.hpp
--- a/include/sensor.hpp	2020-08-26 06:30:54.402972548 +0530
+++ b/include/sensor.hpp	2020-08-26 06:31:18.774981084 +0530
@@ -332,3 +332,100 @@
         return false;
     }
 };
+
+struct DiscSensor
+{
+    DiscSensor(const std::string& name,
+           const std::string& configurationPath, const std::string& objectType,
+           const double max, const double min,uint16_t EvStat, const std::string& sensorUnit) :
+        name(name),
+        configurationPath(configurationPath), objectType(objectType),
+        maxValue(max), minValue(min),
+        hysteresis((max - min) * 0.01), eventStat(EvStat), Unit(sensorUnit)
+    {
+    }
+    virtual ~DiscSensor() = default;
+    std::string name;
+    std::string configurationPath;
+    std::string objectType;
+    std::string Unit;
+    double maxValue;
+    double minValue;
+    uint16_t eventStat;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> sensorInterface;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> discreteInterfaceState;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> association;
+    double value = std::numeric_limits<double>::quiet_NaN();
+    bool overriddenState = false;
+    bool internalSet = false;
+    double hysteresis;
+
+
+    int setSensorValue(const double& newValue, double& oldValue)
+    {
+        if (!internalSet)
+        {
+            oldValue = newValue;
+            overriddenState = true;
+            // check thresholds for external set
+            value = newValue;
+           value == 0 ? discreteInterfaceState->set_property("ActiveAlarmState",std::vector<uint8_t>({0x00, 0xFF, 0xFF})) :
+                       discreteInterfaceState->set_property("ActiveAlarmState",std::vector<uint8_t>({0x01, 0xFF, 0xFF}));
+
+        }
+        else if (!overriddenState)
+        {
+            oldValue = newValue;
+        }
+        return 1;
+    }
+
+
+    void
+        setInitialProperties(std::shared_ptr<sdbusplus::asio::connection>& conn)
+    {
+        createAssociation(association, configurationPath);
+
+        sensorInterface->register_property("MaxValue", maxValue);
+        sensorInterface->register_property("MinValue", minValue);
+        sensorInterface->register_property("EvStat", eventStat);
+        sensorInterface->register_property("SensorStat",false);
+       sensorInterface->register_property("Unit", Unit);
+        sensorInterface->register_property(
+            "Value", value, [&](const double& newValue, double& oldValue) {
+                return setSensorValue(newValue, oldValue);
+            });
+
+        if (!sensorInterface->initialize())
+        {
+            std::cerr << "error initializing value interface\n";
+        }
+        if (discreteInterfaceState &&
+            !discreteInterfaceState->initialize())
+        {
+            std::cerr << "error initializing warning threshold interface\n";
+        }
+    }
+    void updateValue(const double& newValue)
+    {
+        // Ignore if overriding is enabled
+        if (!overriddenState)
+        {
+            // Indicate that it is internal set call
+            internalSet = true;
+            sensorInterface->set_property("Value", newValue);
+            newValue == 0 ? discreteInterfaceState->set_property("ActiveAlarmState",std::vector<uint8_t>({0x00, 0xFF, 0xFF})) :
+                        discreteInterfaceState->set_property("ActiveAlarmState",std::vector<uint8_t>({0x01, 0xFF, 0xFF}));
+//            sensorInterface->set_property("SensorStat", false);
+            value = newValue;
+
+            internalSet = false;
+            double diff = std::abs(value - newValue);
+            if (std::isnan(diff) || diff > hysteresis)
+            {
+                value = newValue;
+            }
+        }
+    }
+};
+
diff -Naur a/src/ChassisIntrusionSensor.cpp b/src/ChassisIntrusionSensor.cpp
--- a/src/ChassisIntrusionSensor.cpp	2020-08-26 06:22:42.346808847 +0530
+++ b/src/ChassisIntrusionSensor.cpp	2020-08-26 06:23:48.510829576 +0530
@@ -47,7 +47,7 @@
 // Status bit field masks
 const static constexpr size_t pchRegMaskIntrusion = 0x01;
 
-void ChassisIntrusionSensor::updateValue(const std::string newValue)
+void ChassisIntrusionSensor::updateValue(const std::string newValue, bool v)
 {
     // Take no action if value already equal
     // Same semantics as Sensor::updateValue(const double&)
@@ -61,6 +61,9 @@
     mIface->set_property("Status", newValue);
     mInternalSet = false;
 
+     v ? mIfaceDiscrete->set_property("ActiveAlarmState",std::vector<uint8_t>({0x00, 0xFF, 0xFF})) :
+                        mIfaceDiscrete->set_property("ActiveAlarmState",std::vector<uint8_t>({0xFF, 0xFF, 0xFF}));
+
     mValue = newValue;
 
     if (mOldValue == "Normal" && mValue != "Normal")
@@ -157,7 +160,7 @@
             {
                 std::cout << "update value from " << mValue << " to "
                           << newValue << "\n";
-                updateValue(newValue);
+                updateValue(newValue, statusValue ? true : false); 
             }
 
             // trigger next polling
@@ -190,7 +193,7 @@
     {
         std::cout << "update value from " << mValue << " to " << newValue
                   << "\n";
-        updateValue(newValue);
+        updateValue(newValue, value);
     }
 }
 
@@ -235,8 +238,8 @@
 
         // set string defined in chassis redfish schema
         auto value = mGpioLine.get_value();
-        std::string newValue = value ? "HardwareIntrusion" : "Normal";
-        updateValue(newValue);
+        std::string newValue = value ? "HardwareIntrusion" : "Normal"; 
+        updateValue(newValue, value ? true : false);
 
         auto gpioLineFd = mGpioLine.event_get_fd();
         if (gpioLineFd < 0)
@@ -272,7 +275,7 @@
 }
 
 void ChassisIntrusionSensor::start(IntrusionSensorType type, int busId,
-                                   int slaveAddr, bool gpioInverted)
+                                   int slaveAddr, bool gpioInverted, uint8_t dtype, uint8_t eventType, uint8_t evStat)
 {
     if (DEBUG)
     {
@@ -302,6 +305,11 @@
     mBusId = busId;
     mSlaveAddr = slaveAddr;
     mGpioInverted = gpioInverted;
+    mdtype = dtype;
+    meventType = eventType;
+    mevStat = evStat;
+    double v = 0;
+    std::vector<uint8_t> al = {0xFF,0xFF,0xFF};
 
     if ((mType == IntrusionSensorType::pch && mBusId > 0 && mSlaveAddr > 0) ||
         (mType == IntrusionSensorType::gpio))
@@ -314,8 +322,24 @@
                 [&](const std::string& req, std::string& propertyValue) {
                     return setSensorValue(req, propertyValue);
                 });
+           mIface->register_property("Value", v);
+           mIface->register_property("SensorStat",false);
+           mIface->register_property("DType", mdtype);
+           mIface->register_property("EventType", meventType);
+           mIface->register_property("EvStat", mevStat);
+
             mIface->initialize();
 
+	    mIfaceDiscrete->register_property("ActiveAlarmState",al,
+                        [&](const std::vector<uint8_t>& request, std::vector<uint8_t>& oldValue) {
+                    oldValue = request;
+                    al = request;
+                    return 1;
+                });
+
+           mIfaceDiscrete->initialize();
+
+
             if (mType == IntrusionSensorType::gpio)
             {
                 initGpioDeviceFile();
@@ -360,10 +384,10 @@
 
 ChassisIntrusionSensor::ChassisIntrusionSensor(
     boost::asio::io_service& io,
-    std::shared_ptr<sdbusplus::asio::dbus_interface> iface) :
-    mIface(iface),
+    std::shared_ptr<sdbusplus::asio::dbus_interface> iface, std::shared_ptr<sdbusplus::asio::dbus_interface> ifacediscrete) :
+    mIface(iface),mIfaceDiscrete(ifacediscrete),
     mType(IntrusionSensorType::gpio), mValue("unknown"), mOldValue("unknown"),
-    mBusId(-1), mSlaveAddr(-1), mPollTimer(io), mGpioInverted(false),
+    mBusId(-1), mSlaveAddr(-1), mPollTimer(io), mGpioInverted(false), mdtype(0x00), meventType(0x00), mevStat(0x00),
     mGpioFd(io)
 {}
 
diff -Naur a/src/EventMain.cpp b/src/EventMain.cpp
--- a/src/EventMain.cpp	1970-01-01 05:30:00.000000000 +0530
+++ b/src/EventMain.cpp	2020-08-26 06:23:48.526829581 +0530
@@ -0,0 +1,250 @@
+/*
+//
+// Auther: selvaganapathim
+// Email : selvaganapathim@amiindia.co.in
+//
+*/
+#include <EventSensor.hpp>
+#include <Utils.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_set.hpp>
+#include <filesystem>
+#include <fstream>
+#include <regex>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+
+static constexpr bool DEBUG = false;
+
+namespace fs = std::filesystem;
+static constexpr std::array<const char*, 1> sensorTypes = {
+    "xyz.openbmc_project.Configuration.Discevent"};
+
+bool is_number(const std::string& s)
+{
+    return( strspn( s.c_str(), "-.0123456789" ) == s.size() );
+}
+
+int findeIndex(std::string Path)
+{
+    std::string subStr;
+    subStr=Path.substr(strlen("/sys/class/gpio/gpio"));
+
+    if(is_number(subStr) == true)
+        return std::stoi( subStr );
+    return 0xff;
+}
+
+void createSensors(
+    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
+    boost::container::flat_map<std::string, std::unique_ptr<EventSensor>>&
+        sensors,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+    const std::unique_ptr<boost::container::flat_set<std::string>>&
+        sensorsChanged)
+{
+    bool firstScan = sensorsChanged == nullptr;
+    // use new data the first time, then refresh
+    ManagedObjectType sensorConfigurations;
+    bool useCache = false;
+    for (const char* type : sensorTypes)
+    {
+        if (!getSensorConfiguration(type, dbusConnection, sensorConfigurations,
+                                    useCache))
+        {
+            std::cerr << "error communicating to entity manager\n";
+            return;
+        }
+        useCache = true;
+    }
+
+    // iterate through all found Digital sensors, and try to match them with
+    // configuration
+    const SensorData* sensorData = nullptr;
+    const std::string* interfacePath = nullptr;
+    const char* sensorType = nullptr;
+    const std::pair<std::string, boost::container::flat_map<
+                                         std::string, BasicVariantType>>*
+    baseConfiguration = nullptr;
+ for (const std::pair<sdbusplus::message::object_path, SensorData>&
+                 sensor : sensorConfigurations)
+    {
+       sensorData = &(sensor.second);
+       for (const char* type : sensorTypes)
+        {
+               auto sensorBase = sensorData->find(type);
+                if (sensorBase != sensorData->end())
+                {
+                    baseConfiguration = &(*sensorBase);
+                    sensorType = type;
+                    break;
+                }
+        }
+        if (baseConfiguration == nullptr)
+        {
+               std::cerr << "error finding base configuration for "
+                          << "Discrete" << "\n";
+                       continue;
+               }
+
+        interfacePath = &(sensor.first.str);
+
+        if (interfacePath == nullptr)
+        {
+            std::cerr << "failed to find match for " << "Discrete" << "\n";
+            continue;
+        }
+
+auto findSensorName = baseConfiguration->second.find("Name");
+        if (findSensorName == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine configuration name for "
+                      << "discrete" << "\n";
+            continue;
+        }
+        std::string sensorName = std::get<std::string>(findSensorName->second);
+
+       auto findSensorUnit = baseConfiguration->second.find("Unit");
+        if (findSensorUnit == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine Unit for "
+                      << "Discrete" << "\n";
+            continue;
+        }
+        std::string sensorUnit = std::get<std::string>(findSensorUnit->second);
+
+        auto findEvStat = baseConfiguration->second.find("EvStat");
+            if (findEvStat == baseConfiguration->second.end())
+            {
+                std::cerr << "Base configuration missing EvStat"
+                          << baseConfiguration->first << "\n";
+               continue;
+            }
+
+        uint16_t EvStat =
+            std::visit(VariantToUnsignedIntVisitor(), findEvStat->second);
+
+       //Digital Type
+        auto findSensorDType = baseConfiguration->second.find("DType");
+        if (findSensorDType == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine configuration DType for "
+                      << "Discrete" << "\n";
+            continue;
+        }
+        uint8_t sensorDType =  std::visit(VariantToUnsignedIntVisitor(), findSensorDType->second);
+
+        //Digital Event Type
+        auto findSensorEventType = baseConfiguration->second.find("EventType");
+        if (findSensorEventType == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine configuration EventType for "
+                      << "Discrete" << "\n";
+            continue;
+        }
+        uint8_t sensorEventType = std::visit(VariantToUnsignedIntVisitor(), findSensorEventType->second);
+        //Digital Event Offset
+        auto findSensorEventOffset = baseConfiguration->second.find("EventOffset");
+        if (findSensorEventOffset == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine configuration EventType for "
+                     << "Discrete" << "\n";
+            continue;
+        }
+        uint8_t sensorEventOffset = std::visit(VariantToUnsignedIntVisitor(), findSensorEventOffset->second);
+
+        // on rescans, only update sensors we were signaled by
+        auto findSensor = sensors.find(sensorName);
+        if (!firstScan && findSensor != sensors.end())
+        {
+            bool found = false;
+            for (auto it = sensorsChanged->begin(); it != sensorsChanged->end();
+                 it++)
+            {
+                if (boost::ends_with(*it, findSensor->second->name))
+                {
+                    sensorsChanged->erase(it);
+                    findSensor->second = nullptr;
+                    found = true;
+                    break;
+                }
+            }
+            if (!found)
+            {
+                continue;
+            }
+        }
+//        std::vector<discretes::Discrete> sensorDiscretes;
+//        if (!parseDiscretesFromConfig(*sensorData, sensorDiscretes))
+//        {
+//            std::cerr << "error populating discretes for " << sensorName
+//                      << "\n";
+//        }
+
+       //std::string sensorPath="/sys/class/gpio/gpio"+std::to_string(index)+"/value";
+       std::string sensorPath;
+
+        sensors[sensorName] = std::make_unique<EventSensor>(
+            sensorPath, sensorType, objectServer,
+            dbusConnection, io, sensorName,
+           *interfacePath,EvStat,sensorUnit,sensorDType,sensorEventType,sensorEventOffset);
+    }
+}
+int main()
+{
+    boost::asio::io_service io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+    systemBus->request_name("xyz.openbmc_project.Eventsensor");
+    sdbusplus::asio::object_server objectServer(systemBus);
+    boost::container::flat_map<std::string, std::unique_ptr<EventSensor>>
+        sensors;
+    std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
+    std::unique_ptr<boost::container::flat_set<std::string>> sensorsChanged =
+        std::make_unique<boost::container::flat_set<std::string>>();
+
+    io.post([&]() {
+        createSensors(io, objectServer, sensors, systemBus, nullptr);
+    });
+
+    boost::asio::deadline_timer filterTimer(io);
+    std::function<void(sdbusplus::message::message&)> eventHandler =
+        [&](sdbusplus::message::message& message) {
+            if (message.is_method_error())
+            {
+                std::cerr << "callback method error\n";
+                return;
+            }
+            sensorsChanged->insert(message.get_path());
+            // this implicitly cancels the timer
+            filterTimer.expires_from_now(boost::posix_time::seconds(1));
+
+            filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                if (ec == boost::asio::error::operation_aborted)
+                {
+                    /* we were canceled*/
+                    return;
+                }
+                else if (ec)
+                {
+                    std::cerr << "timer error\n";
+                    return;
+                }
+                createSensors(io, objectServer, sensors, systemBus,
+                              sensorsChanged);
+            });
+        };
+
+    for (const char* type : sensorTypes)
+    {
+        auto match = std::make_unique<sdbusplus::bus::match::match>(
+            static_cast<sdbusplus::bus::bus&>(*systemBus),
+            "type='signal',member='PropertiesChanged',path_namespace='" +
+                std::string(inventoryPath) + "',arg0namespace='" + type + "'",
+            eventHandler);
+        matches.emplace_back(std::move(match));
+    }
+
+    io.run();
+}
+
diff -Naur a/src/EventSensor.cpp b/src/EventSensor.cpp
--- a/src/EventSensor.cpp	1970-01-01 05:30:00.000000000 +0530
+++ b/src/EventSensor.cpp	2020-08-26 06:23:48.526829581 +0530
@@ -0,0 +1,143 @@
+/*
+//
+// Auther: selvaganapathim
+// Email : selvaganapathim@amiindia.co.in
+//
+*/
+
+#include <unistd.h>
+
+#include <EventSensor.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <iostream>
+#include <limits>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <string>
+static constexpr unsigned int sensorPollMs = 500;
+static constexpr unsigned int sensorScaleFactor = 1000;
+static constexpr size_t warnAfterErrorCount = 10;
+
+static constexpr double maxReading = 127;
+static constexpr double minReading = -128;
+EventSensor::EventSensor(
+    const std::string& path, const std::string& objectType,
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t DType, uint8_t EventType,uint8_t EventOffset) :
+    DiscSensor(boost::replace_all_copy(sensorName, " ", "_"),
+           sensorConfiguration, objectType, maxReading,
+           minReading,EvStat, sensorUnit),
+    path(path), objServer(objectServer),
+    /*inputDev(io, open(path.c_str(), O_RDONLY)),*/ waitTimer(io), errCount(0)
+{
+
+    sensorInterface = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/eventsensor/" + name,
+        "xyz.openbmc_project.Sensor.Value");
+
+    discreteInterfaceState = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/eventsensor/" + name,
+        "xyz.openbmc_project.Sensor.Discrete.State");
+
+    std::vector<uint8_t> al = {0xFF,0xFF,0xFF};
+    discreteInterfaceState->register_property("ActiveAlarmState",al,
+                       [&](const std::vector<uint8_t>& request, std::vector<uint8_t>& oldValue) {
+                   oldValue = request;
+                    al = request;
+                    return 1;
+                });
+
+    association = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/eventsensor/" + name,
+        "org.openbmc.Associations");
+    sensorInterface->register_property("DType",DType);
+    sensorInterface->register_property("EventType",EventType);
+    sensorInterface->register_property("EventOffset",EventOffset);
+    setInitialProperties(conn);
+    //setupRead();
+}
+
+EventSensor::~EventSensor()
+{
+    // close the input dev to cancel async operations
+//    inputDev.close();
+    waitTimer.cancel();
+    objServer.remove_interface(discreteInterfaceState);
+    objServer.remove_interface(sensorInterface);
+    objServer.remove_interface(association);
+}
+/*void DiscreteSensor::setupRead(void)
+{
+    boost::asio::async_read_until(
+        inputDev, readBuf, '\n',
+        [&](const boost::system::error_code& ec,
+            std::size_t) { handleResponse(ec); });
+}
+
+void DiscreteSensor::handleResponse(const boost::system::error_code& err)
+{
+    if (err == boost::system::errc::bad_file_descriptor)
+    {
+       return; // we're being destroyed
+    }
+    std::istream responseStream(&readBuf);
+    if (!err)
+    {
+        std::string response;
+        std::getline(responseStream, response);
+        try
+        {
+            float nvalue = std::stof(response);
+            //nvalue = !value;
+            if (static_cast<double>(nvalue) != value)
+            {
+                updateValue(nvalue);
+            }
+            errCount = 0;
+        }
+        catch (const std::invalid_argument&)
+        {
+            errCount++;
+        }
+    }
+    else
+    {
+        errCount++;
+    }
+
+    // only print once
+    if (errCount == warnAfterErrorCount)
+    {
+        std::cerr << "Failure to read sensor " << name << " at " << path
+                  << " ec:" << err << "\n";
+    }
+
+    if (errCount >= warnAfterErrorCount)
+    {
+        updateValue(0);
+    }
+    responseStream.clear();
+    inputDev.close();
+    int fd = open(path.c_str(), O_RDONLY);
+    if (fd <= 0)
+    {
+        return; // we're no longer valid
+    }
+    inputDev.assign(fd);
+    waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
+    waitTimer.async_wait([&](const boost::system::error_code& ec) {
+        if (ec == boost::asio::error::operation_aborted)
+       {
+            return; // we're being canceled
+        }
+        setupRead();
+    });
+}
+*/
+
+
diff -Naur a/src/GpioMain.cpp b/src/GpioMain.cpp
--- a/src/GpioMain.cpp	1970-01-01 05:30:00.000000000 +0530
+++ b/src/GpioMain.cpp	2020-08-26 06:23:48.526829581 +0530
@@ -0,0 +1,284 @@
+/*
+//
+// Auther: selvaganapathim
+// Email : selvaganapathim@amiindia.co.in
+//
+*/
+
+#include <GpioSensor.hpp>
+#include <Utils.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_set.hpp>
+#include <filesystem>
+#include <fstream>
+#include <regex>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+
+static constexpr bool DEBUG = false;
+
+namespace fs = std::filesystem;
+static constexpr std::array<const char*, 1> sensorTypes = {
+    "xyz.openbmc_project.Configuration.Digitalgpio"};
+
+bool is_number(const std::string& s)
+{
+    return( strspn( s.c_str(), "-.0123456789" ) == s.size() );
+}
+
+int findeIndex(std::string Path)
+{
+    std::string subStr;
+    subStr=Path.substr(strlen("/sys/class/gpio/gpio"));
+
+    if(is_number(subStr) == true)
+        return std::stoi( subStr );
+    return 0xff;
+}
+
+void createSensors(
+    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
+    boost::container::flat_map<std::string, std::unique_ptr<GpioSensor>>&
+        sensors,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+    const std::unique_ptr<boost::container::flat_set<std::string>>&
+        sensorsChanged)
+{
+    bool firstScan = sensorsChanged == nullptr;
+    // use new data the first time, then refresh
+    ManagedObjectType sensorConfigurations;
+    bool useCache = false;
+    for (const char* type : sensorTypes)
+    {
+        if (!getSensorConfiguration(type, dbusConnection, sensorConfigurations,
+                                    useCache))
+        {
+            std::cerr << "error communicating to entity manager\n";
+            return;
+        }
+        useCache = true;
+    }
+
+     std::vector<fs::path> paths;
+     for (const auto & entry : fs::directory_iterator("/sys/class/gpio/"))
+     {
+         paths.emplace_back(entry.path());
+     }
+
+
+    boost::container::flat_set<std::string> directories;
+
+    // iterate through all found Digital sensors, and try to match them with
+    // configuration
+for (auto& path : paths)
+    {
+
+       int index;
+        index=findeIndex(path.string());
+        if(index == 0xff)
+            continue;
+        std::string deviceName = "gpio"+std::to_string(index);
+
+
+        const SensorData* sensorData = nullptr;
+        const std::string* interfacePath = nullptr;
+        const char* sensorType = nullptr;
+        const std::pair<std::string, boost::container::flat_map<
+                                         std::string, BasicVariantType>>*
+            baseConfiguration = nullptr;
+
+        for (const std::pair<sdbusplus::message::object_path, SensorData>&
+                 sensor : sensorConfigurations)
+        {
+            sensorData = &(sensor.second);
+            for (const char* type : sensorTypes)
+            {
+               auto sensorBase = sensorData->find(type);
+                if (sensorBase != sensorData->end())
+                {
+                    baseConfiguration = &(*sensorBase);
+                    sensorType = type;
+                    break;
+                }
+            }
+            if (baseConfiguration == nullptr)
+            {
+                std::cerr << "error finding base configuration for "
+                         << deviceName << "\n";
+                continue;
+            }
+            auto configurationIndex = baseConfiguration->second.find("Index");
+
+            if (configurationIndex == baseConfiguration->second.end())
+            {
+                std::cerr << "error finding Index in configuration";
+                continue;
+            }
+
+            if (std::get<uint64_t>(configurationIndex->second) != index)
+            {
+                continue;
+            }
+
+            interfacePath = &(sensor.first.str);
+            break;
+        }
+        if (interfacePath == nullptr)
+        {
+            std::cerr << "failed to find match for " << deviceName << "\n";
+            continue;
+        }
+
+        auto findSensorName = baseConfiguration->second.find("Name");
+        if (findSensorName == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine configuration name for "
+                      << deviceName << "\n";
+            continue;
+        }
+        std::string sensorName = std::get<std::string>(findSensorName->second);
+
+       auto findSensorUnit = baseConfiguration->second.find("Unit");
+        if (findSensorUnit == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine Unit for "
+                      << deviceName << "\n";
+            continue;
+        }
+        std::string sensorUnit = std::get<std::string>(findSensorUnit->second);
+ auto findEvStat = baseConfiguration->second.find("EvStat");
+            if (findEvStat == baseConfiguration->second.end())
+            {
+                std::cerr << "Base configuration missing EvStat"
+                          << baseConfiguration->first << "\n";
+                continue;
+            }
+
+        uint16_t EvStat =
+            std::visit(VariantToUnsignedIntVisitor(), findEvStat->second);
+
+       //Digital Type
+        auto findSensorDType = baseConfiguration->second.find("DType");
+        if (findSensorDType == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine configuration DType for "
+                      << deviceName << "\n";
+            continue;
+        }
+        uint8_t sensorDType =  std::visit(VariantToUnsignedIntVisitor(), findSensorDType->second);
+
+        //Digital Event Type
+        auto findSensorEventType = baseConfiguration->second.find("EventType");
+        if (findSensorEventType == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine configuration EventType for "
+                      << deviceName << "\n";
+            continue;
+        }
+uint8_t sensorEventType = std::visit(VariantToUnsignedIntVisitor(), findSensorEventType->second);
+
+        //Digital Event Offset
+        auto findSensorEventOffset = baseConfiguration->second.find("EventOffset");
+        if (findSensorEventOffset == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine configuration EventType for "
+                      << deviceName << "\n";
+           continue;
+        }
+        uint8_t sensorEventOffset = std::visit(VariantToUnsignedIntVisitor(), findSensorEventOffset->second);
+
+        // on rescans, only update sensors we were signaled by
+        auto findSensor = sensors.find(sensorName);
+        if (!firstScan && findSensor != sensors.end())
+        {
+            bool found = false;
+            for (auto it = sensorsChanged->begin(); it != sensorsChanged->end();
+                 it++)
+            {
+                if (boost::ends_with(*it, findSensor->second->name))
+                {
+                    sensorsChanged->erase(it);
+                    findSensor->second = nullptr;
+                    found = true;
+                    break;
+                }
+            }
+            if (!found)
+            {
+                continue;
+            }
+        }
+//        std::vector<discretes::Discrete> sensorDiscretes;
+//        if (!parseDiscretesFromConfig(*sensorData, sensorDiscretes))
+//        {
+//            std::cerr << "error populating discretes for " << sensorName
+//                      << "\n";
+//        }
+
+       std::string sensorPath="/sys/class/gpio/gpio"+std::to_string(index)+"/value";
+
+        sensors[sensorName] = std::make_unique<GpioSensor>(
+            sensorPath, sensorType, objectServer,
+            dbusConnection, io, sensorName,
+            *interfacePath,EvStat,sensorUnit,sensorDType,sensorEventType,sensorEventOffset);
+    }
+}
+
+int main()
+{
+    boost::asio::io_service io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+    systemBus->request_name("xyz.openbmc_project.Gpiosensor");
+    sdbusplus::asio::object_server objectServer(systemBus);
+    boost::container::flat_map<std::string, std::unique_ptr<GpioSensor>>
+        sensors;
+    std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
+    std::unique_ptr<boost::container::flat_set<std::string>> sensorsChanged =
+        std::make_unique<boost::container::flat_set<std::string>>();
+
+    io.post([&]() {
+        createSensors(io, objectServer, sensors, systemBus, nullptr);
+    });
+
+    boost::asio::deadline_timer filterTimer(io);
+    std::function<void(sdbusplus::message::message&)> eventHandler =
+        [&](sdbusplus::message::message& message) {
+            if (message.is_method_error())
+            {
+                std::cerr << "callback method error\n";
+                return;
+            }
+            sensorsChanged->insert(message.get_path());
+            // this implicitly cancels the timer
+            filterTimer.expires_from_now(boost::posix_time::seconds(1));
+
+            filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                if (ec == boost::asio::error::operation_aborted)
+                {
+                    /* we were canceled*/
+                   return;
+                }
+                else if (ec)
+                {
+                    std::cerr << "timer error\n";
+                    return;
+                }
+                createSensors(io, objectServer, sensors, systemBus,
+                              sensorsChanged);
+            });
+        };
+
+    for (const char* type : sensorTypes)
+    {
+        auto match = std::make_unique<sdbusplus::bus::match::match>(
+            static_cast<sdbusplus::bus::bus&>(*systemBus),
+            "type='signal',member='PropertiesChanged',path_namespace='" +
+                std::string(inventoryPath) + "',arg0namespace='" + type + "'",
+            eventHandler);
+        matches.emplace_back(std::move(match));
+    }
+
+    io.run();
+}
+
diff -Naur a/src/GpioSensor.cpp b/src/GpioSensor.cpp
--- a/src/GpioSensor.cpp	1970-01-01 05:30:00.000000000 +0530
+++ b/src/GpioSensor.cpp	2020-08-26 06:23:48.526829581 +0530
@@ -0,0 +1,139 @@
+/*
+//
+// Auther: selvaganapathim
+// Email : selvaganapathim@amiindia.co.in
+//
+*/
+
+#include <unistd.h>
+
+#include <GpioSensor.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <iostream>
+#include <limits>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <string>
+
+static constexpr unsigned int sensorPollMs = 500;
+static constexpr unsigned int sensorScaleFactor = 1000;
+static constexpr size_t warnAfterErrorCount = 10;
+
+static constexpr double maxReading = 127;
+static constexpr double minReading = -128;
+
+GpioSensor::GpioSensor(
+    const std::string& path, const std::string& objectType,
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t DType, uint8_t EventType,uint8_t EventOffset) :
+    DiscSensor(boost::replace_all_copy(sensorName, " ", "_"),
+           sensorConfiguration, objectType, maxReading,
+           minReading,EvStat, sensorUnit),
+    path(path), objServer(objectServer),
+    inputDev(io, open(path.c_str(), O_RDONLY)), waitTimer(io), errCount(0)
+{
+    sensorInterface = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/gpiosensor/" + name,
+        "xyz.openbmc_project.Sensor.Value");
+
+    discreteInterfaceState = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/gpiosensor/" + name,
+        "xyz.openbmc_project.Sensor.Discrete.State");
+
+    std::vector<uint8_t> al = {0xFF,0xFF,0xFF};
+
+    discreteInterfaceState->register_property("ActiveAlarmState",al);
+
+    association = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/gpiosensor/" + name,
+        "org.openbmc.Associations");
+    sensorInterface->register_property("DType",DType);
+    sensorInterface->register_property("EventType",EventType);
+    sensorInterface->register_property("EventOffset",EventOffset);
+    setInitialProperties(conn);
+    setupRead();
+}
+
+GpioSensor::~GpioSensor()
+{
+    // close the input dev to cancel async operations
+    inputDev.close();
+    waitTimer.cancel();
+    objServer.remove_interface(discreteInterfaceState);
+    objServer.remove_interface(sensorInterface);
+    objServer.remove_interface(association);
+}
+
+void GpioSensor::setupRead(void)
+{
+    boost::asio::async_read_until(
+        inputDev, readBuf, '\n',
+        [&](const boost::system::error_code& ec,
+            std::size_t /*bytes_transfered*/) { handleResponse(ec); });
+}
+
+void GpioSensor::handleResponse(const boost::system::error_code& err)
+{
+    if (err == boost::system::errc::bad_file_descriptor)
+    {
+        return; // we're being destroyed
+    }
+    std::istream responseStream(&readBuf);
+    if (!err)
+    {
+        std::string response;
+        std::getline(responseStream, response);
+        try
+        {
+            float nvalue = std::stof(response);
+            //nvalue = !value;
+            if (static_cast<double>(nvalue) != value)
+            {
+                updateValue(nvalue);
+            }
+            errCount = 0;
+        }
+        catch (const std::invalid_argument&)
+        {
+            errCount++;
+        }
+    }
+    else
+    {
+        errCount++;
+    }
+
+    // only print once
+    if (errCount == warnAfterErrorCount)
+    {
+        std::cerr << "Failure to read sensor " << name << " at " << path
+                  << " ec:" << err << "\n";
+    }
+
+    if (errCount >= warnAfterErrorCount)
+    {
+        updateValue(0);
+    }
+    responseStream.clear();
+    inputDev.close();
+    int fd = open(path.c_str(), O_RDONLY);
+    if (fd <= 0)
+    {
+        return; // we're no longer valid
+    }
+    inputDev.assign(fd);
+    waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
+    waitTimer.async_wait([&](const boost::system::error_code& ec) {
+        if (ec == boost::asio::error::operation_aborted)
+        {
+            return; // we're being canceled
+        }
+        setupRead();
+    });
+}
+
diff -Naur a/src/IntrusionSensorMain.cpp b/src/IntrusionSensorMain.cpp
--- a/src/IntrusionSensorMain.cpp	2020-08-26 06:22:42.346808847 +0530
+++ b/src/IntrusionSensorMain.cpp	2020-08-26 06:23:48.526829581 +0530
@@ -55,7 +55,7 @@
 static bool getIntrusionSensorConfig(
     std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
     IntrusionSensorType* pType, int* pBusId, int* pSlaveAddr,
-    bool* pGpioInverted)
+    bool* pGpioInverted, uint8_t *pDtype, uint8_t *pEventType, uint8_t *pEvState)
 {
     // find matched configuration according to sensor type
     ManagedObjectType sensorConfigurations;
@@ -107,8 +107,15 @@
         {
             auto findGpioPolarity =
                 baseConfiguration->second.find("GpioPolarity");
+           auto findDtype =baseConfiguration->second.find("DType");
+           auto findEventType = baseConfiguration->second.find("EventType");
+           auto findEvState = baseConfiguration->second.find("EvStat");
 
-            if (findGpioPolarity == baseConfiguration->second.end())
+
+            if (findGpioPolarity == baseConfiguration->second.end() ||
+	        findDtype == baseConfiguration->second.end() ||
+               findEventType == baseConfiguration->second.end() ||
+               findEvState == baseConfiguration->second.end())
             {
                 std::cerr << "error finding gpio polarity in configuration \n";
                 continue;
@@ -118,6 +125,16 @@
             {
                 *pGpioInverted =
                     (std::get<std::string>(findGpioPolarity->second) == "Low");
+		 *pDtype = /*sdbusplus::message::variant_ns::get<uint8_t>(
+                    findDtype->second);*/
+              std::visit(VariantToUnsignedIntVisitor(), findDtype->second);
+               *pEventType = /*sdbusplus::message::variant_ns::get<uint8_t>(
+                    findEventType->second);*/
+               std::visit(VariantToUnsignedIntVisitor(), findEventType->second);
+               *pEvState = /*sdbusplus::message::variant_ns::get<uint8_t>(
+                    findEvState->second);*/
+               std::visit(VariantToUnsignedIntVisitor(), findEvState->second);
+
             }
             catch (const std::bad_variant_access& e)
             {
@@ -442,6 +459,7 @@
 {
     int busId = -1;
     int slaveAddr = -1;
+    uint8_t dtype, eventType, evStat;
     bool gpioInverted = false;
     IntrusionSensorType type = IntrusionSensorType::gpio;
 
@@ -455,15 +473,20 @@
 
     std::shared_ptr<sdbusplus::asio::dbus_interface> ifaceChassis =
         objServer.add_interface(
-            "/xyz/openbmc_project/Intrusion/Chassis_Intrusion",
-            "xyz.openbmc_project.Chassis.Intrusion");
+                               "/xyz/openbmc_project/sensors/Intrusion/Chassis_Intrusion",
+            "xyz.openbmc_project.Sensor.Value");
+
+    std::shared_ptr<sdbusplus::asio::dbus_interface> ifaceDiscrete =
+        objServer.add_interface(
+            "/xyz/openbmc_project/sensors/Intrusion/Chassis_Intrusion",
+           "xyz.openbmc_project.Sensor.Discrete.State");
 
-    ChassisIntrusionSensor chassisIntrusionSensor(io, ifaceChassis);
+    ChassisIntrusionSensor chassisIntrusionSensor(io, ifaceChassis, ifaceDiscrete);
 
     if (getIntrusionSensorConfig(systemBus, &type, &busId, &slaveAddr,
-                                 &gpioInverted))
+                                 &gpioInverted, &dtype, &eventType, &evStat))
     {
-        chassisIntrusionSensor.start(type, busId, slaveAddr, gpioInverted);
+        chassisIntrusionSensor.start(type, busId, slaveAddr, gpioInverted, dtype, eventType, evStat);
     }
 
     // callback to handle configuration change
@@ -477,10 +500,10 @@
 
             std::cout << "rescan due to configuration change \n";
             if (getIntrusionSensorConfig(systemBus, &type, &busId, &slaveAddr,
-                                         &gpioInverted))
+                                         &gpioInverted, &dtype, &eventType, &evStat))
             {
                 chassisIntrusionSensor.start(type, busId, slaveAddr,
-                                             gpioInverted);
+                                             gpioInverted, dtype, eventType, evStat);
             }
         };
 
diff -Naur a/service_files/xyz.openbmc_project.eventsensor.service b/service_files/xyz.openbmc_project.eventsensor.service
--- a/service_files/xyz.openbmc_project.eventsensor.service	1970-01-01 05:30:00.000000000 +0530
+++ b/service_files/xyz.openbmc_project.eventsensor.service	2020-08-26 06:29:25.186941555 +0530
@@ -0,0 +1,12 @@
+[Unit]
+Description=Event Sensor
+StopWhenUnneeded=false
+
+[Service]
+Restart=always
+RestartSec=5
+ExecStart=/usr/bin/eventsensor
+
+[Install]
+WantedBy=multi-user.target
+
diff -Naur a/service_files/xyz.openbmc_project.gpiosensor.service b/service_files/xyz.openbmc_project.gpiosensor.service
--- a/service_files/xyz.openbmc_project.gpiosensor.service	1970-01-01 05:30:00.000000000 +0530
+++ b/service_files/xyz.openbmc_project.gpiosensor.service	2020-08-26 06:29:25.186941555 +0530
@@ -0,0 +1,12 @@
+[Unit]
+Description=Gpio Sensor
+StopWhenUnneeded=false
+
+[Service]
+Restart=always
+RestartSec=5
+ExecStart=/usr/bin/gpiosensor
+
+[Install]
+WantedBy=multi-user.target
+
