diff -Naur a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2021-03-02 13:40:12.861890105 +0530
+++ b/CMakeLists.txt	2021-03-02 21:15:37.926978058 +0530
@@ -25,6 +25,7 @@
     -Wformat=2 \
     -Wno-sign-compare \
     -Wno-reorder \
+    -Wno-null-dereference \
 "
 )
 # todo: get rid of nos, add the below:
@@ -38,6 +39,8 @@
 
 option (DISABLE_ADC "Disable installing ADC sensor" OFF)
 option (DISABLE_CPU "Disable installing CPU sensor" OFF)
+option (DISABLE_DIG_GPIO "Disable intialling digital gpio sensor" OFF)
+option (DISABLE_DISC_EVENT "Disable installing discrete event sensor" OFF)
 option (DISABLE_EXIT_AIR "Disable installing Exit Air Temp sensor" OFF)
 option (DISABLE_FAN "Disable installing fan sensor" OFF)
 option (DISABLE_HWMON_TEMP "Disable installing hwmon temp sensor" OFF)
@@ -58,6 +61,10 @@
 
 set (CPU_SRC_FILES src/Utils.cpp src/CPUSensor.cpp src/Thresholds.cpp src/SdrRecord.cpp)
 
+set (DIG_GPIO_SRC_FILES src/Utils.cpp src/GpioSensor.cpp src/SdrRecord.cpp)
+
+set (DISC_EVENT_SRC_FILES src/Utils.cpp src/EventSensor.cpp src/AcpiSensor.cpp src/SdrRecord.cpp)
+
 set (EXIT_AIR_SRC_FILES src/Utils.cpp src/Thresholds.cpp src/SdrRecord.cpp)
 
 set (FAN_SRC_FILES src/TachSensor.cpp src/PwmSensor.cpp src/Utils.cpp
@@ -162,6 +169,14 @@
 target_link_libraries (cpusensor ${SENSOR_LINK_LIBS})
 target_link_libraries (cpusensor gpiodcxx)
 
+add_executable (gpiosensor src/GpioMain.cpp ${DIG_GPIO_SRC_FILES})
+add_dependencies (gpiosensor sdbusplus-project)
+target_link_libraries (gpiosensor ${SENSOR_LINK_LIBS})
+
+add_executable (eventsensor src/EventMain.cpp ${DISC_EVENT_SRC_FILES})
+add_dependencies (eventsensor sdbusplus-project)
+target_link_libraries (eventsensor ${SENSOR_LINK_LIBS})
+
 add_executable (exitairtempsensor src/ExitAirTempSensor.cpp
                 ${EXIT_AIR_SRC_FILES})
 add_dependencies (exitairtempsensor sdbusplus-project)
@@ -205,6 +220,8 @@
 if (NOT YOCTO)
     add_dependencies (adcsensor ${EXTERNAL_PACKAGES})
     add_dependencies (cpusensor ${EXTERNAL_PACKAGES})
+    add_dependencies (digitalsensor ${EXTERNAL_PACKAGES})
+    add_dependencies (discretesensor ${EXTERNAL_PACKAGES})
     add_dependencies (exitairtempsensor ${EXTERNAL_PACKAGES})
     add_dependencies (fansensor ${EXTERNAL_PACKAGES})
     add_dependencies (hwmontempsensor ${EXTERNAL_PACKAGES})
@@ -231,6 +248,22 @@
                  DESTINATION ${SERVICE_FILE_INSTALL_DIR})
 endif ()
 
+if (NOT DISABLE_DIG_GPIO)
+    install (TARGETS gpiosensor DESTINATION bin)
+    install (FILES
+               ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.gpiosensor.service
+               DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+
+endif()
+
+if (NOT DISABLE_DISC_EVENT)
+    install (TARGETS eventsensor DESTINATION bin)
+    install (FILES
+                ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.eventsensor.service
+                DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+
+endif()
+
 if (NOT DISABLE_EXIT_AIR)
     install (TARGETS exitairtempsensor DESTINATION bin)
     install (
diff -Naur a/include/AcpiSensor.hpp b/include/AcpiSensor.hpp
--- a/include/AcpiSensor.hpp	1970-01-01 05:30:00.000000000 +0530
+++ b/include/AcpiSensor.hpp	2021-03-03 08:38:30.899678325 +0530
@@ -0,0 +1,34 @@
+//
+//author: selvaganapathi m
+//email: selvaganapathim@amiindia.co.in
+//
+#pragma once
+
+#include <sdbusplus/asio/object_server.hpp>
+#include <sensor.hpp>
+
+class AcpiSensor : public DiscSensor
+{
+  public:
+   AcpiSensor(
+    const std::string& path, const std::string& objectType,
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn, std::shared_ptr<sdbusplus::asio::connection> bus,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat, const std::string& sensorUnit,
+    uint8_t LowOffset, uint8_t HighOffset, struct sdr::SdrRecord sdrRecord);
+
+    ~AcpiSensor();
+
+  private:
+    sdbusplus::asio::object_server& objServer;
+    boost::asio::deadline_timer waitTimer;
+    std::string path;
+    int errCount;
+
+    std::vector<uint8_t> data;
+    uint8_t al;
+    uint8_t LowOffset, HighOffset;
+    void setupRead(void);
+};
+
diff -Naur a/include/EventSensor.hpp b/include/EventSensor.hpp
--- a/include/EventSensor.hpp	1970-01-01 05:30:00.000000000 +0530
+++ b/include/EventSensor.hpp	2021-03-03 08:42:26.298605998 +0530
@@ -0,0 +1,34 @@
+#pragma once
+
+#include <sdbusplus/asio/object_server.hpp>
+#include <boost/asio/streambuf.hpp>
+#include <sensor.hpp>
+
+class EventSensor : public DiscSensor
+{
+  public:
+   EventSensor(
+    const std::string& path, const std::string& objectType,
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t LowOffset, uint8_t HighOffset, struct sdr::SdrRecord sdrRecord);
+
+    ~EventSensor();
+
+  private:
+    sdbusplus::asio::object_server& objServer;
+//    boost::asio::posix::stream_descriptor inputDev;
+    boost::asio::deadline_timer waitTimer;
+    boost::asio::streambuf readBuf;
+    std::string path;
+    int errCount;
+    uint8_t DType;
+    std::vector<uint8_t> data;
+    uint8_t al;
+    uint8_t EventType;
+    uint8_t LowOffset, HighOffset;
+    void setupRead(void);
+    void handleResponse(const boost::system::error_code& err);
+};
diff -Naur a/include/GpioSensor.hpp b/include/GpioSensor.hpp
--- a/include/GpioSensor.hpp	1970-01-01 05:30:00.000000000 +0530
+++ b/include/GpioSensor.hpp	2021-03-03 08:31:01.085353786 +0530
@@ -0,0 +1,31 @@
+#pragma once
+
+#include <sdbusplus/asio/object_server.hpp>
+#include <boost/asio/streambuf.hpp>
+#include <sensor.hpp>
+
+class GpioSensor : public DiscSensor
+{
+  public:
+   GpioSensor(
+    const std::string& path, const std::string& objectType,
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t LowOffset, uint8_t HighOffset , struct sdr::SdrRecord sdrRecord);
+
+    ~GpioSensor();
+
+  private:
+    sdbusplus::asio::object_server& objServer;
+    boost::asio::posix::stream_descriptor inputDev;
+    boost::asio::deadline_timer waitTimer;
+    boost::asio::streambuf readBuf;
+    std::string path;
+    int errCount;
+    uint8_t LowOffset, HighOffset;
+    void setupRead(void);
+    void handleResponse(const boost::system::error_code& err);
+};
+
diff -Naur a/include/sensor.hpp b/include/sensor.hpp
--- a/include/sensor.hpp	2021-03-02 13:39:59.242646483 +0530
+++ b/include/sensor.hpp	2021-03-03 07:42:40.328128802 +0530
@@ -488,4 +488,143 @@
         internalSet = false;
     }
 };
+
+struct DiscSensor
+{
+    DiscSensor(const std::string& name,
+           const std::string& configurationPath, const std::string& objectType,
+	   const double max, const double min,uint16_t EvStat, uint8_t lOffset, uint8_t hOffset, const std::string& sensorUnit,
+          struct sdr::SdrRecord sdrRecord) :
+        name(name),configurationPath(configurationPath), objectType(objectType),maxValue(max), minValue(min),
+        hysteresis((max - min) * 0.01), eventStat(EvStat), loffset(lOffset), hoffset(hOffset), Unit(sensorUnit),
+	RecordType(sdrRecord.RecordType),
+       EntityId(sdrRecord.EntityId),
+       EntityInstance(sdrRecord.EntityInstance),SensorInit(sdrRecord.SensorInit),SensorCap(sdrRecord.SensorCap),
+       SensorType(sdrRecord.SensorType),EventType(sdrRecord.EventType), SensorUnit2(sdrRecord.SensorUnit2)
+
+
+    {
+    }
+    virtual ~DiscSensor() = default;
+    std::string name;
+    std::string configurationPath;
+    std::string objectType;
+    std::string Unit;
+    double maxValue;
+    double minValue;
+    uint16_t eventStat;
+    uint8_t loffset, hoffset;
+    uint8_t RecordType;
+    uint8_t EntityId;
+    uint8_t EntityInstance;
+    uint8_t SensorInit;
+    uint8_t SensorCap;
+    uint8_t SensorType;
+    uint8_t EventType;
+    uint8_t SensorUnit2;
+
+    std::shared_ptr<sdbusplus::asio::dbus_interface> sensorInterface;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> discreteInterfaceState;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> association;
+    double value = std::numeric_limits<double>::quiet_NaN();
+    bool overriddenState = false;
+    bool internalSet = false;
+    double hysteresis;
+
+
+    int setSensorValue(const double& newValue, double& oldValue)
+    {
+        if (!internalSet)
+        {
+            oldValue = newValue;
+            overriddenState = true;
+            // check thresholds for external set
+            value = newValue;
+	    value == 0 ? discreteInterfaceState->set_property("ActiveAlarmState",static_cast<uint8_t>(0x00)) :
+                         discreteInterfaceState->set_property("ActiveAlarmState",static_cast<uint8_t>(0x01));
+
+        }
+        else if (!overriddenState)
+        {
+            oldValue = newValue;
+        }
+        return 1;
+    }
+
+
+    void
+        setInitialProperties(std::shared_ptr<sdbusplus::asio::connection>& conn)
+    {
+	conn = NULL;
+        createAssociation(association, configurationPath);
+
+        sensorInterface->register_property("MaxValue", maxValue);
+        sensorInterface->register_property("MinValue", minValue);
+        sensorInterface->register_property("EvStat", eventStat);
+        sensorInterface->register_property("SensorStat",false);
+       sensorInterface->register_property("Unit", Unit);
+       sensorInterface->register_property("SdrVersion", 81);
+        sensorInterface->register_property("RecordType",RecordType );
+
+        sensorInterface->register_property("EntityId",EntityId );
+        sensorInterface->register_property("EntityInstance",EntityInstance );
+        sensorInterface->register_property("SensorInit",SensorInit );
+        sensorInterface->register_property("SensorCap",SensorCap );
+        sensorInterface->register_property("SensorType",SensorType );
+        sensorInterface->register_property("EventType",EventType );
+        sensorInterface->register_property("SensorUnit1",  0);
+        sensorInterface->register_property("SensorUnit2", SensorUnit2 );
+	sensorInterface->register_property("ModifierUnit",  0);
+        sensorInterface->register_property("Linearization",  0);
+        sensorInterface->register_property("NominalReading",  151);
+        sensorInterface->register_property("NormalMax",  197);
+        sensorInterface->register_property("NormalMin",  139);
+        sensorInterface->register_property("PositiveHysteris",  0);
+        sensorInterface->register_property("NegativeHysteresis", 0);
+        sensorInterface->register_property("IdStringLen",  0);
+
+        sensorInterface->register_property(
+            "Value", value, [&](const double& newValue, double& oldValue) {
+                return setSensorValue(newValue, oldValue);
+            });
+
+        if (!sensorInterface->initialize())
+        {
+            std::cerr << "error initializing value interface\n";
+        }
+        if (discreteInterfaceState &&
+			!discreteInterfaceState->initialize(true))
+        {
+            std::cerr << "error initializing warning threshold interface\n";
+        }
+    }
+    void updateValue(const double& newValue)
+    {
+        // Ignore if overriding is enabled
+        if (!overriddenState)
+        {
+            // Indicate that it is internal set call
+            internalSet = true;
+            sensorInterface->set_property("Value", newValue);
+	    if (newValue == 0){
+	       discreteInterfaceState->set_property("EventData",std::vector<uint8_t>({loffset, 0xFF, 0xFF}));
+               discreteInterfaceState->set_property("ActiveAlarmState",static_cast<uint8_t>(loffset == 0xFF ? loffset
+                                                               : (0x01 << loffset)));
+            }else if(newValue == 1){
+               discreteInterfaceState->set_property("EventData",std::vector<uint8_t>({hoffset, 0xFF, 0xFF}));
+               discreteInterfaceState->set_property("ActiveAlarmState",static_cast<uint8_t>(0x01 << hoffset));
+            }
+
+
+            value = newValue;
+
+            internalSet = false;
+            double diff = std::abs(value - newValue);
+            if (std::isnan(diff) || diff > hysteresis)
+            {
+                value = newValue;
+            }
+        }
+    }
+};
 bool  parseSdrRecordFromConfig( const SensorData& sensorData,struct sdr::SdrRecord& sdrRecord );
diff -Naur a/service_files/xyz.openbmc_project.eventsensor.service b/service_files/xyz.openbmc_project.eventsensor.service
--- a/service_files/xyz.openbmc_project.eventsensor.service	1970-01-01 05:30:00.000000000 +0530
+++ b/service_files/xyz.openbmc_project.eventsensor.service	2021-03-02 18:25:51.871806366 +0530
@@ -0,0 +1,13 @@
+[Unit]
+Description=Event Sensor
+StopWhenUnneeded=false
+
+[Service]
+Restart=always
+RestartSec=5
+ExecStart=/usr/bin/eventsensor
+
+[Install]
+WantedBy=multi-user.target
+
+
diff -Naur a/service_files/xyz.openbmc_project.gpiosensor.service b/service_files/xyz.openbmc_project.gpiosensor.service
--- a/service_files/xyz.openbmc_project.gpiosensor.service	1970-01-01 05:30:00.000000000 +0530
+++ b/service_files/xyz.openbmc_project.gpiosensor.service	2021-03-02 18:26:27.596577545 +0530
@@ -0,0 +1,13 @@
+[Unit]
+Description=Gpio Sensor
+StopWhenUnneeded=false
+
+[Service]
+Restart=always
+RestartSec=5
+ExecStart=/usr/bin/gpiosensor
+
+[Install]
+WantedBy=multi-user.target
+
+
diff -Naur a/src/AcpiSensor.cpp b/src/AcpiSensor.cpp
--- a/src/AcpiSensor.cpp	1970-01-01 05:30:00.000000000 +0530
+++ b/src/AcpiSensor.cpp	2021-03-03 08:40:35.355003503 +0530
@@ -0,0 +1,116 @@
+/*
+//
+// Auther: selvaganapathim
+// Email : selvaganapathim@amiindia.co.in
+//
+*/
+
+#include <unistd.h>
+
+#include <AcpiSensor.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/asio/read_until.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <iostream>
+#include <limits>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <string>
+
+
+static constexpr double maxReading = 127;
+static constexpr double minReading = -128;
+
+AcpiSensor::AcpiSensor(
+    const std::string& path, const std::string& objectType,
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn, std::shared_ptr<sdbusplus::asio::connection> bus,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t LowOffset, uint8_t HighOffset, struct sdr::SdrRecord sdrRecord) :
+    DiscSensor(boost::replace_all_copy(sensorName, " ", "_"),
+           sensorConfiguration, objectType, maxReading,
+	   minReading,EvStat, LowOffset, HighOffset, sensorUnit,sdrRecord),
+    path(path), objServer(objectServer), waitTimer(io), errCount(0)
+{
+
+    sensorInterface = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/acpisensor/" + name,
+        "xyz.openbmc_project.Sensor.Value");
+
+    discreteInterfaceState = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/acpisensor/" + name,
+        "xyz.openbmc_project.Sensor.Discrete.State");
+
+    data = {0xFF,0xFF,0xFF};
+    al = 0x00;
+
+    discreteInterfaceState->register_property("EventData",data,
+                       [&](const std::vector<uint8_t>& request, std::vector<uint8_t>& oldValue) {
+                   oldValue = request;
+                    data = request;
+                    return 1;
+               });
+    discreteInterfaceState->register_property("ActiveAlarmState",al,
+                        [&](const uint8_t& request, uint8_t& oldValue) {
+                    oldValue = request;
+                    al = request;
+                    return 1;
+                });
+
+
+    association = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/acpisensor/" + name,
+        "org.openbmc.Associations");
+    sensorInterface->register_property("EventType",EventType);
+    setInitialProperties(conn);
+
+    std::function<void(sdbusplus::message::message&)> PgoodEventMatcherCallback =
+      [&](sdbusplus::message::message& message) {
+           boost::container::flat_map<std::string, std::variant<int>> propertiesChanged;
+           std::string objectName;
+           if (message.is_method_error())
+           {
+               std::cerr << "callback method error\n";
+               return;
+           }
+
+           message.read(objectName, propertiesChanged);
+           std::string event = propertiesChanged.begin()->first;
+           int *pgood = std::get_if<int>(&propertiesChanged.begin()->second);
+
+           if (!pgood)
+           {
+               std::cerr << "event has invalid type\n";
+               return;
+           }
+           if (event == "pgood")
+           {
+              if(*pgood == 1){
+                    discreteInterfaceState->set_property("EventData", std::vector<uint8_t>({0x00, 0xFF, 0xFF}));
+                     discreteInterfaceState->set_property("ActiveAlarmState", static_cast<uint8_t>(0x01));
+              }else{
+                    discreteInterfaceState->set_property("EventData", std::vector<uint8_t>({0x05, 0xFF, 0xFF}));
+                            discreteInterfaceState->set_property("ActiveAlarmState", static_cast<uint8_t>(0x20));
+              }
+           }
+
+       };
+
+    //event trigger, this can move to poll the gpio service.
+    sdbusplus::bus::match::match caterrEventMatcher(
+        static_cast<sdbusplus::bus::bus&>(*bus),
+        "type='signal',interface='org.freedesktop.DBus.Properties',member='"
+        "PropertiesChanged',arg0namespace='org.openbmc.control.Power'",
+        PgoodEventMatcherCallback);
+}
+
+AcpiSensor::~AcpiSensor()
+{
+    waitTimer.cancel();
+    objServer.remove_interface(discreteInterfaceState);
+    objServer.remove_interface(sensorInterface);
+    objServer.remove_interface(association);
+}
+
diff -Naur a/src/EventMain.cpp b/src/EventMain.cpp
--- a/src/EventMain.cpp	1970-01-01 05:30:00.000000000 +0530
+++ b/src/EventMain.cpp	2021-03-03 08:45:03.038298655 +0530
@@ -0,0 +1,240 @@
+/*
+//
+// Auther: selvaganapathim
+// Email : selvaganapathim@amiindia.co.in
+//
+*/
+#include <EventSensor.hpp>
+#include <AcpiSensor.hpp>
+#include <Utils.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_set.hpp>
+#include <filesystem>
+#include <fstream>
+#include <regex>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+
+static constexpr bool DEBUG = false;
+
+namespace fs = std::filesystem;
+static constexpr std::array<const char*, 1> sensorTypes = {
+    "xyz.openbmc_project.Configuration.Discevent"};
+
+bool is_number(const std::string& s)
+{
+    return( strspn( s.c_str(), "-.0123456789" ) == s.size() );
+}
+
+int findeIndex(std::string Path)
+{
+    std::string subStr;
+    subStr=Path.substr(strlen("/sys/class/gpio/gpio"));
+
+    if(is_number(subStr) == true)
+        return std::stoi( subStr );
+    return 0xff;
+}
+
+void createSensors(
+    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
+    boost::container::flat_map<std::string, std::unique_ptr<EventSensor>>&
+    sensors, boost::container::flat_map<std::string, std::unique_ptr<AcpiSensor>>& acpi,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection, std::shared_ptr<sdbusplus::asio::connection> bus,
+    const std::unique_ptr<boost::container::flat_set<std::string>>&
+        sensorsChanged)
+{
+    bool firstScan = sensorsChanged == nullptr;
+    // use new data the first time, then refresh
+    ManagedObjectType sensorConfigurations;
+    bool useCache = false;
+    for (const char* type : sensorTypes)
+    {
+        if (!getSensorConfiguration(type, dbusConnection, sensorConfigurations,
+                                    useCache))
+        {
+            std::cerr << "error communicating to entity manager\n";
+            return;
+        }
+        useCache = true;
+    }
+
+    // iterate through all found Digital sensors, and try to match them with
+    // configuration
+    const SensorData* sensorData = nullptr;
+    const std::string* interfacePath = nullptr;
+    const char* sensorType = nullptr;
+    const std::pair<std::string, boost::container::flat_map<
+                                         std::string, BasicVariantType>>*
+    baseConfiguration = nullptr;
+ for (const std::pair<sdbusplus::message::object_path, SensorData>&
+                 sensor : sensorConfigurations)
+    {
+       sensorData = &(sensor.second);
+       for (const char* type : sensorTypes)
+        {
+               auto sensorBase = sensorData->find(type);
+                if (sensorBase != sensorData->end())
+                {
+                    baseConfiguration = &(*sensorBase);
+                    sensorType = type;
+                    break;
+                }
+        }
+        if (baseConfiguration == nullptr)
+        {
+               std::cerr << "error finding base configuration for "
+                          << "Discrete" << "\n";
+                       continue;
+               }
+
+        interfacePath = &(sensor.first.str);
+
+        if (interfacePath == nullptr)
+        {
+            std::cerr << "failed to find match for " << "Discrete" << "\n";
+            continue;
+        }
+
+auto findSensorName = baseConfiguration->second.find("Name");
+        if (findSensorName == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine configuration name for "
+                      << "discrete" << "\n";
+            continue;
+        }
+        std::string sensorName = std::get<std::string>(findSensorName->second);
+
+       auto findSensorUnit = baseConfiguration->second.find("Unit");
+        if (findSensorUnit == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine Unit for "
+                      << "Discrete" << "\n";
+            continue;
+        }
+        std::string sensorUnit = std::get<std::string>(findSensorUnit->second);
+
+        auto findEvStat = baseConfiguration->second.find("EvStat");
+            if (findEvStat == baseConfiguration->second.end())
+            {
+                std::cerr << "Base configuration missing EvStat"
+                          << baseConfiguration->first << "\n";
+               continue;
+            }
+
+        uint16_t EvStat =
+            std::visit(VariantToUnsignedIntVisitor(), findEvStat->second);
+
+        //Digital Event Offset
+        auto findSensorEventOffset = baseConfiguration->second.find("EventOffset");
+        if (findSensorEventOffset == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine configuration EventType for "
+                     << "Discrete" << "\n";
+            continue;
+        }
+        uint8_t sensorEventOffset = std::visit(VariantToUnsignedIntVisitor(), findSensorEventOffset->second);
+
+        // on rescans, only update sensors we were signaled by
+        auto findSensor = sensors.find(sensorName);
+        if (!firstScan && findSensor != sensors.end())
+        {
+            bool found = false;
+            for (auto it = sensorsChanged->begin(); it != sensorsChanged->end();
+                 it++)
+            {
+                if (boost::ends_with(*it, findSensor->second->name))
+                {
+                    sensorsChanged->erase(it);
+                    findSensor->second = nullptr;
+                    found = true;
+                    break;
+                }
+            }
+            if (!found)
+            {
+                continue;
+            }
+        }
+	
+        struct sdr::SdrRecord sdrRecord;
+        if( !parseSdrRecordFromConfig(*sensorData ,sdrRecord))
+        {
+            std::cerr << "error getting sdr record for " << sensorName << std::endl;
+        }
+       
+       std::string sensorPath;
+
+       if(sdrRecord.EventType == 0x22){
+          acpi[sensorName] = std::make_unique<AcpiSensor>(
+             sensorPath, sensorType, objectServer,
+             dbusConnection, bus, io, sensorName,
+	     *interfacePath,EvStat,sensorUnit, 0x00, 0x00,sdrRecord);
+       }else{
+          sensors[sensorName] = std::make_unique<EventSensor>(
+             sensorPath, sensorType, objectServer,
+             dbusConnection, io, sensorName,
+	     *interfacePath,EvStat,sensorUnit, 0x00, 0x00 ,sdrRecord);
+       }
+
+    }
+}
+int main()
+{
+    boost::asio::io_service io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+    systemBus->request_name("xyz.openbmc_project.Eventsensor");
+    sdbusplus::asio::object_server objectServer(systemBus);
+    boost::container::flat_map<std::string, std::unique_ptr<EventSensor>>
+        sensors;
+    boost::container::flat_map<std::string, std::unique_ptr<AcpiSensor>>
+       acpi;
+    std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
+    std::unique_ptr<boost::container::flat_set<std::string>> sensorsChanged =
+        std::make_unique<boost::container::flat_set<std::string>>();
+
+    io.post([&]() {
+ 	   createSensors(io, objectServer, sensors, acpi, systemBus, systemBus, nullptr);
+    });
+
+    boost::asio::deadline_timer filterTimer(io);
+    std::function<void(sdbusplus::message::message&)> eventHandler =
+        [&](sdbusplus::message::message& message) {
+            if (message.is_method_error())
+            {
+                std::cerr << "callback method error\n";
+                return;
+            }
+            sensorsChanged->insert(message.get_path());
+            // this implicitly cancels the timer
+            filterTimer.expires_from_now(boost::posix_time::seconds(1));
+
+            filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                if (ec == boost::asio::error::operation_aborted)
+                {
+                    /* we were canceled*/
+                    return;
+                }
+                else if (ec)
+                {
+                    std::cerr << "timer error\n";
+                    return;
+                }
+		createSensors(io, objectServer, sensors, acpi, systemBus, systemBus,
+                              sensorsChanged);
+            });
+        };
+
+    for (const char* type : sensorTypes)
+    {
+        auto match = std::make_unique<sdbusplus::bus::match::match>(
+            static_cast<sdbusplus::bus::bus&>(*systemBus),
+            "type='signal',member='PropertiesChanged',path_namespace='" +
+                std::string(inventoryPath) + "',arg0namespace='" + type + "'",
+            eventHandler);
+        matches.emplace_back(std::move(match));
+    }
+
+    io.run();
+}
diff -Naur a/src/EventSensor.cpp b/src/EventSensor.cpp
--- a/src/EventSensor.cpp	1970-01-01 05:30:00.000000000 +0530
+++ b/src/EventSensor.cpp	2021-03-03 08:42:45.942552557 +0530
@@ -0,0 +1,79 @@
+/*
+//
+// Auther: selvaganapathim
+// Email : selvaganapathim@amiindia.co.in
+//
+*/
+
+#include <unistd.h>
+
+#include <EventSensor.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/asio/read_until.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <iostream>
+#include <limits>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <string>
+static constexpr unsigned int sensorPollMs = 500;
+static constexpr unsigned int sensorScaleFactor = 1000;
+static constexpr size_t warnAfterErrorCount = 10;
+
+static constexpr double maxReading = 127;
+static constexpr double minReading = -128;
+EventSensor::EventSensor(
+    const std::string& path, const std::string& objectType,
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t LowOffset, uint8_t HighOffset, struct sdr::SdrRecord sdrRecord) :
+    DiscSensor(boost::replace_all_copy(sensorName, " ", "_"),
+           sensorConfiguration, objectType, maxReading,
+	   minReading,EvStat, LowOffset, HighOffset, sensorUnit,sdrRecord),
+    path(path), objServer(objectServer),
+    /*inputDev(io, open(path.c_str(), O_RDONLY)),*/ waitTimer(io), errCount(0)
+{
+
+    sensorInterface = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/eventsensor/" + name,
+        "xyz.openbmc_project.Sensor.Value");
+
+    discreteInterfaceState = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/eventsensor/" + name,
+        "xyz.openbmc_project.Sensor.Discrete.State");
+
+    data = {0xFF,0xFF,0xFF};
+    al = 0x00;
+		    discreteInterfaceState->register_property("EventData",data,
+                       [&](const std::vector<uint8_t>& request, std::vector<uint8_t>& oldValue) {
+                   oldValue = request;
+		   data = request;
+                    return 1;
+                });
+
+		discreteInterfaceState->register_property("ActiveAlarmState",al,
+                        [&](const uint8_t& request, uint8_t& oldValue) {
+                    oldValue = request;
+                     al = request;
+                     return 1;
+                 });
+
+    association = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/eventsensor/" + name,
+        "org.openbmc.Associations");
+    setInitialProperties(conn);
+}
+
+EventSensor::~EventSensor()
+{
+    // close the input dev to cancel async operations
+//    inputDev.close();
+    waitTimer.cancel();
+    objServer.remove_interface(discreteInterfaceState);
+    objServer.remove_interface(sensorInterface);
+    objServer.remove_interface(association);
+}
+
diff -Naur a/src/GpioMain.cpp b/src/GpioMain.cpp
--- a/src/GpioMain.cpp	1970-01-01 05:30:00.000000000 +0530
+++ b/src/GpioMain.cpp	2021-03-03 08:04:57.709375735 +0530
@@ -0,0 +1,276 @@
+/*
+//
+// Auther: selvaganapathim
+// Email : selvaganapathim@amiindia.co.in
+//
+*/
+
+#include <GpioSensor.hpp>
+#include <Utils.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_set.hpp>
+#include <filesystem>
+#include <fstream>
+#include <regex>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+
+static constexpr bool DEBUG = false;
+
+namespace fs = std::filesystem;
+static constexpr std::array<const char*, 1> sensorTypes = {
+    "xyz.openbmc_project.Configuration.Digitalgpio"};
+
+bool is_number(const std::string& s)
+{
+    return( strspn( s.c_str(), "-.0123456789" ) == s.size() );
+}
+
+int findeIndex(std::string Path)
+{
+    std::string subStr;
+    subStr=Path.substr(strlen("/sys/class/gpio/gpio"));
+
+    if(is_number(subStr) == true)
+        return std::stoi( subStr );
+    return 0xff;
+}
+
+void createSensors(
+    boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
+    boost::container::flat_map<std::string, std::unique_ptr<GpioSensor>>&
+        sensors,
+    std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+    const std::unique_ptr<boost::container::flat_set<std::string>>&
+        sensorsChanged)
+{
+    bool firstScan = sensorsChanged == nullptr;
+    // use new data the first time, then refresh
+    ManagedObjectType sensorConfigurations;
+    bool useCache = false;
+    for (const char* type : sensorTypes)
+    {
+        if (!getSensorConfiguration(type, dbusConnection, sensorConfigurations,
+                                    useCache))
+        {
+            std::cerr << "error communicating to entity manager\n";
+            return;
+        }
+        useCache = true;
+    }
+
+     std::vector<fs::path> paths;
+     for (const auto & entry : fs::directory_iterator("/sys/class/gpio/"))
+     {
+         paths.emplace_back(entry.path());
+     }
+
+
+    boost::container::flat_set<std::string> directories;
+
+    // iterate through all found Digital sensors, and try to match them with
+    // configuration
+for (auto& path : paths)
+    {
+
+       int index;
+        index=findeIndex(path.string());
+        if(index == 0xff)
+            continue;
+        std::string deviceName = "gpio"+std::to_string(index);
+
+
+        const SensorData* sensorData = nullptr;
+        const std::string* interfacePath = nullptr;
+        const char* sensorType = nullptr;
+        const std::pair<std::string, boost::container::flat_map<
+                                         std::string, BasicVariantType>>*
+            baseConfiguration = nullptr;
+
+        for (const std::pair<sdbusplus::message::object_path, SensorData>&
+                 sensor : sensorConfigurations)
+        {
+            sensorData = &(sensor.second);
+            for (const char* type : sensorTypes)
+            {
+               auto sensorBase = sensorData->find(type);
+                if (sensorBase != sensorData->end())
+                {
+                    baseConfiguration = &(*sensorBase);
+                    sensorType = type;
+                    break;
+                }
+            }
+            if (baseConfiguration == nullptr)
+            {
+                std::cerr << "error finding base configuration for "
+                         << deviceName << "\n";
+                continue;
+            }
+            auto configurationIndex = baseConfiguration->second.find("Index");
+
+            if (configurationIndex == baseConfiguration->second.end())
+            {
+                std::cerr << "error finding Index in configuration";
+                continue;
+            }
+
+            if (std::get<uint64_t>(configurationIndex->second) != index)
+            {
+                continue;
+            }
+
+            interfacePath = &(sensor.first.str);
+            break;
+        }
+        if (interfacePath == nullptr)
+        {
+            std::cerr << "failed to find match for " << deviceName << "\n";
+            continue;
+        }
+
+        auto findSensorName = baseConfiguration->second.find("Name");
+        if (findSensorName == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine configuration name for "
+                      << deviceName << "\n";
+            continue;
+        }
+        std::string sensorName = std::get<std::string>(findSensorName->second);
+
+       auto findSensorUnit = baseConfiguration->second.find("Unit");
+        if (findSensorUnit == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine Unit for "
+                      << deviceName << "\n";
+            continue;
+        }
+        std::string sensorUnit = std::get<std::string>(findSensorUnit->second);
+ auto findEvStat = baseConfiguration->second.find("EvStat");
+            if (findEvStat == baseConfiguration->second.end())
+            {
+                std::cerr << "Base configuration missing EvStat"
+                          << baseConfiguration->first << "\n";
+                continue;
+            }
+
+        uint16_t EvStat =
+            std::visit(VariantToUnsignedIntVisitor(), findEvStat->second);
+
+        //Digital Event Offset
+	auto findSensorLowOffset = baseConfiguration->second.find("LowOffset");
+        if (findSensorLowOffset == baseConfiguration->second.end())
+	{
+            std::cerr << "could not determine configuration LowOffset for "
+                       << deviceName << "\n";
+            continue;
+        }
+        uint8_t sensorLowOffset = std::visit(VariantToUnsignedIntVisitor(), findSensorLowOffset->second);
+
+	//Digital Event Offset
+        auto findSensorHighOffset = baseConfiguration->second.find("HighOffset");
+        if (findSensorHighOffset == baseConfiguration->second.end())
+        {
+            std::cerr << "could not determine configuration HighOffset for "
+                      << deviceName << "\n";
+           continue;
+        }
+        uint8_t sensorHighOffset = std::visit(VariantToUnsignedIntVisitor(), findSensorHighOffset->second);
+
+        // on rescans, only update sensors we were signaled by
+        auto findSensor = sensors.find(sensorName);
+        if (!firstScan && findSensor != sensors.end())
+        {
+            bool found = false;
+            for (auto it = sensorsChanged->begin(); it != sensorsChanged->end();
+                 it++)
+            {
+                if (boost::ends_with(*it, findSensor->second->name))
+                {
+                    sensorsChanged->erase(it);
+                    findSensor->second = nullptr;
+                    found = true;
+                    break;
+                }
+            }
+            if (!found)
+            {
+                continue;
+            }
+        }
+
+	struct sdr::SdrRecord sdrRecord;
+
+        if( !parseSdrRecordFromConfig(*sensorData,sdrRecord))
+        {
+              std::cerr << "error getting sdr record for " << sensorName << std::endl;
+        }
+
+
+       std::string sensorPath="/sys/class/gpio/gpio"+std::to_string(index)+"/value";
+
+        sensors[sensorName] = std::make_unique<GpioSensor>(
+            sensorPath, sensorType, objectServer,
+            dbusConnection, io, sensorName,
+	    *interfacePath,EvStat,sensorUnit,sensorLowOffset, sensorHighOffset,sdrRecord);
+    }
+}
+
+int main()
+{
+    boost::asio::io_service io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+    systemBus->request_name("xyz.openbmc_project.Gpiosensor");
+    sdbusplus::asio::object_server objectServer(systemBus);
+    boost::container::flat_map<std::string, std::unique_ptr<GpioSensor>>
+        sensors;
+    std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
+    std::unique_ptr<boost::container::flat_set<std::string>> sensorsChanged =
+        std::make_unique<boost::container::flat_set<std::string>>();
+
+    io.post([&]() {
+        createSensors(io, objectServer, sensors, systemBus, nullptr);
+    });
+
+    boost::asio::deadline_timer filterTimer(io);
+    std::function<void(sdbusplus::message::message&)> eventHandler =
+        [&](sdbusplus::message::message& message) {
+            if (message.is_method_error())
+            {
+                std::cerr << "callback method error\n";
+                return;
+            }
+            sensorsChanged->insert(message.get_path());
+            // this implicitly cancels the timer
+            filterTimer.expires_from_now(boost::posix_time::seconds(1));
+
+            filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                if (ec == boost::asio::error::operation_aborted)
+                {
+                    /* we were canceled*/
+                   return;
+                }
+                else if (ec)
+                {
+                    std::cerr << "timer error\n";
+                    return;
+                }
+                createSensors(io, objectServer, sensors, systemBus,
+                              sensorsChanged);
+            });
+        };
+
+    for (const char* type : sensorTypes)
+    {
+        auto match = std::make_unique<sdbusplus::bus::match::match>(
+            static_cast<sdbusplus::bus::bus&>(*systemBus),
+            "type='signal',member='PropertiesChanged',path_namespace='" +
+                std::string(inventoryPath) + "',arg0namespace='" + type + "'",
+            eventHandler);
+        matches.emplace_back(std::move(match));
+    }
+
+    io.run();
+}
+
diff -Naur a/src/GpioSensor.cpp b/src/GpioSensor.cpp
--- a/src/GpioSensor.cpp	1970-01-01 05:30:00.000000000 +0530
+++ b/src/GpioSensor.cpp	2021-03-03 08:34:58.813578493 +0530
@@ -0,0 +1,136 @@
+/*
+//
+// Auther: selvaganapathim
+// Email : selvaganapathim@amiindia.co.in
+//
+*/
+
+#include <unistd.h>
+
+#include <GpioSensor.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <iostream>
+#include <boost/asio/read_until.hpp>
+#include <limits>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <string>
+
+static constexpr unsigned int sensorPollMs = 500;
+static constexpr unsigned int sensorScaleFactor = 1000;
+static constexpr size_t warnAfterErrorCount = 10;
+
+static constexpr double maxReading = 127;
+static constexpr double minReading = -128;
+
+GpioSensor::GpioSensor(
+    const std::string& path, const std::string& objectType,
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t LowOffset, uint8_t HighOffset, struct sdr::SdrRecord sdrRecord) :
+    DiscSensor(boost::replace_all_copy(sensorName, " ", "_"),
+           sensorConfiguration, objectType, maxReading,
+	   minReading,EvStat, LowOffset, HighOffset , sensorUnit, sdrRecord),
+    path(path), objServer(objectServer),
+    inputDev(io, open(path.c_str(), O_RDONLY)), waitTimer(io), errCount(0)
+{
+    sensorInterface = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/gpiosensor/" + name,
+        "xyz.openbmc_project.Sensor.Value");
+
+    discreteInterfaceState = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/gpiosensor/" + name,
+        "xyz.openbmc_project.Sensor.Discrete.State");
+
+    discreteInterfaceState->register_property("ActiveAlarmState", static_cast<uint8_t>(0x00));
+    discreteInterfaceState->register_property("EventData", std::vector<uint8_t>({0xFF, 0xFF, 0xFF}));
+
+    association = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/gpiosensor/" + name,
+        "org.openbmc.Associations");
+    setInitialProperties(conn);
+    setupRead();
+}
+
+GpioSensor::~GpioSensor()
+{
+    // close the input dev to cancel async operations
+    inputDev.close();
+    waitTimer.cancel();
+    objServer.remove_interface(discreteInterfaceState);
+    objServer.remove_interface(sensorInterface);
+    objServer.remove_interface(association);
+}
+
+void GpioSensor::setupRead(void)
+{
+    boost::asio::async_read_until(
+        inputDev, readBuf, '\n',
+        [&](const boost::system::error_code& ec,
+            std::size_t /*bytes_transfered*/) { handleResponse(ec); });
+}
+
+void GpioSensor::handleResponse(const boost::system::error_code& err)
+{
+    if (err == boost::system::errc::bad_file_descriptor)
+    {
+        return; // we're being destroyed
+    }
+    std::istream responseStream(&readBuf);
+    if (!err)
+    {
+        std::string response;
+        std::getline(responseStream, response);
+        try
+        {
+            float nvalue = std::stof(response);
+            //nvalue = !value;
+            if (static_cast<double>(nvalue) != value)
+            {
+                updateValue(nvalue);
+            }
+            errCount = 0;
+        }
+        catch (const std::invalid_argument&)
+        {
+            errCount++;
+        }
+    }
+    else
+    {
+        errCount++;
+    }
+
+    // only print once
+    if (errCount == warnAfterErrorCount)
+    {
+        std::cerr << "Failure to read sensor " << name << " at " << path
+                  << " ec:" << err << "\n";
+    }
+
+    if (errCount >= warnAfterErrorCount)
+    {
+        updateValue(0);
+    }
+    responseStream.clear();
+    inputDev.close();
+    int fd = open(path.c_str(), O_RDONLY);
+    if (fd <= 0)
+    {
+        return; // we're no longer valid
+    }
+   inputDev.assign(fd);
+    waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
+    waitTimer.async_wait([&](const boost::system::error_code& ec) {
+        if (ec == boost::asio::error::operation_aborted)
+        {
+            return; // we're being canceled
+        }
+        setupRead();
+    });
+}
+
