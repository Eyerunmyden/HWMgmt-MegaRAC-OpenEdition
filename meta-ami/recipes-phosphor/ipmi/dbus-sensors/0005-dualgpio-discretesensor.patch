diff -Naur a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2021-03-04 09:59:50.280674714 +0530
+++ b/CMakeLists.txt	2021-03-04 10:10:23.323998324 +0530
@@ -61,9 +61,9 @@
 
 set (CPU_SRC_FILES src/Utils.cpp src/CPUSensor.cpp src/Thresholds.cpp src/SdrRecord.cpp)
 
-set (DIG_GPIO_SRC_FILES src/Utils.cpp src/GpioSensor.cpp src/SdrRecord.cpp)
+set (DIG_GPIO_SRC_FILES src/Utils.cpp src/GpioSensor.cpp src/DiscreteGpio.cpp src/SdrRecord.cpp)
 
-set (DISC_EVENT_SRC_FILES src/Utils.cpp src/EventSensor.cpp src/AcpiSensor.cpp src/SdrRecord.cpp)
+set (DISC_EVENT_SRC_FILES src/Utils.cpp src/EventSensor.cpp src/AcpiSensor.cpp src/WatchdogSensor.cpp src/SdrRecord.cpp)
 
 set (EXIT_AIR_SRC_FILES src/Utils.cpp src/Thresholds.cpp src/SdrRecord.cpp)
 
diff -Naur a/include/DiscreteGpio.hpp b/include/DiscreteGpio.hpp
--- a/include/DiscreteGpio.hpp	1970-01-01 05:30:00.000000000 +0530
+++ b/include/DiscreteGpio.hpp	2021-03-04 18:23:23.663539506 +0530
@@ -0,0 +1,53 @@
+//
+//Author : selvaganapathi m
+//Email : selvaganapathim@amiindia.co.in
+//
+#pragma once
+
+#include <sdbusplus/asio/object_server.hpp>
+#include <boost/asio/streambuf.hpp>
+#include <sensor.hpp>
+
+class DiscreteGpio : public DiscSensor
+{
+  public:
+   DiscreteGpio(
+    const std::string& path1, const std::string& path2, const std::string& objectType,
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t LowOffset1, uint8_t HighOffset1,
+    uint8_t LowOffset2, uint8_t HighOffset2, struct sdr::SdrRecord sdrRecord);
+
+    ~DiscreteGpio();
+
+    void updateState(const int& newValue, int astate, int oset)
+    {
+        // Ignore if overriding is enabled
+        if (!overriddenState)
+        {
+            // Indicate that it is internal set call
+            internalSet = true;
+            sensorInterface->set_property("Value", static_cast<double>(newValue));
+                discreteInterfaceState->set_property("EventData",std::vector<uint8_t>({ oset, 0xFF, 0xFF}));
+                discreteInterfaceState->set_property("ActiveAlarmState",static_cast<uint8_t>(astate));
+            value = newValue;
+           laststate = astate;
+            internalSet = false;
+        }
+    }
+
+  private:
+    sdbusplus::asio::object_server& objServer;
+    boost::asio::posix::stream_descriptor inputDev1, inputDev2;
+    boost::asio::deadline_timer waitTimer;
+    boost::asio::streambuf readBuf, readBuf1;
+    std::string path1, path2;
+    int errCount;
+    int laststate;
+    uint8_t LowOffset1, HighOffset1, LowOffset2, HighOffset2;
+    void setupRead(void);
+    void handleResponse(const boost::system::error_code& err);
+    void handleResponse1(const boost::system::error_code& err);
+};
diff -Naur a/include/sensor.hpp b/include/sensor.hpp
--- a/include/sensor.hpp	2021-03-04 08:04:50.536872360 +0530
+++ b/include/sensor.hpp	2021-03-04 10:15:13.344257816 +0530
@@ -608,11 +608,12 @@
             sensorInterface->set_property("Value", newValue);
 	    if (newValue == 0){
 	       discreteInterfaceState->set_property("EventData",std::vector<uint8_t>({loffset, 0xFF, 0xFF}));
-               discreteInterfaceState->set_property("ActiveAlarmState",static_cast<uint8_t>(loffset == 0xFF ? loffset
+	       discreteInterfaceState->set_property("ActiveAlarmState",static_cast<uint8_t>(loffset == 0xFF ? 0x00
                                                                : (0x01 << loffset)));
             }else if(newValue == 1){
                discreteInterfaceState->set_property("EventData",std::vector<uint8_t>({hoffset, 0xFF, 0xFF}));
-               discreteInterfaceState->set_property("ActiveAlarmState",static_cast<uint8_t>(0x01 << hoffset));
+	       discreteInterfaceState->set_property("ActiveAlarmState",static_cast<uint8_t>(hoffset == 0xff ? 0x00
+                                                               : (0x01 << hoffset)));
             }
 
 
diff -Naur a/include/WatchdogSensor.hpp b/include/WatchdogSensor.hpp
--- a/include/WatchdogSensor.hpp	1970-01-01 05:30:00.000000000 +0530
+++ b/include/WatchdogSensor.hpp	2021-03-04 19:45:28.307187613 +0530
@@ -0,0 +1,44 @@
+//
+//Author : selvaganapathim
+//Email : selvaganapathim@amiindia.co.in
+//
+#pragma once
+
+#include <sdbusplus/asio/object_server.hpp>
+#include <sensor.hpp>
+
+#define CONF_WDT_TIMEOUT_FILE                                   "/usr/share/wdttout"
+
+#define AST_SCU_REG_BASE                       0x1E6E2000
+#define AST_SCU_SYSRST_CTRLSTATUS_REG_OFFSET   0x64
+
+#define SYSRST_CTRLSTAT_WDT1_RESET_BIT         0x00000004
+#define AST_SCU_UNLOCK_KEY                     0x1688A8A8
+
+
+class WatchdogSensor : public DiscSensor
+{
+  public:
+   WatchdogSensor(
+    const std::string& objectType, sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t LowOffset, uint8_t HighOffset, struct sdr::SdrRecord sdrRecord);
+
+    ~WatchdogSensor();
+
+ private:
+    sdbusplus::asio::object_server& objServer;
+    std::vector<uint8_t> data;
+    uint8_t al;
+    uint8_t LowOffset, HighOffset;
+    unsigned long val;
+    struct stat buf;
+    int fd = -1; //devmem_fd = -1;
+    //void *map;
+    char count = 0;
+
+    int mmap_read(unsigned long addr, unsigned long *data);
+    int mmap_write(unsigned long addr, unsigned long data);
+};
diff -Naur a/src/DiscreteGpio.cpp b/src/DiscreteGpio.cpp
--- a/src/DiscreteGpio.cpp	1970-01-01 05:30:00.000000000 +0530
+++ b/src/DiscreteGpio.cpp	2021-03-04 17:40:43.934349392 +0530
@@ -0,0 +1,216 @@
+/*
+//
+// Auther: selvaganapathim
+// Email : selvaganapathim@amiindia.co.in
+//
+*/
+
+#include <unistd.h>
+
+#include <DiscreteGpio.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/asio/read_until.hpp>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <iostream>
+#include <limits>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <string>
+
+static constexpr unsigned int sensorPollMs = 500;
+static constexpr unsigned int sensorScaleFactor = 1000;
+static constexpr size_t warnAfterErrorCount = 10;
+
+static constexpr double maxReading = 127;
+static constexpr double minReading = -128;
+
+DiscreteGpio::DiscreteGpio(
+    const std::string& path1, const std::string& path2, const std::string& objectType,
+    sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t LowOffset1, uint8_t HighOffset1, uint8_t LowOffset2,
+    uint8_t HighOffset2 , struct sdr::SdrRecord sdrRecord) :
+    DiscSensor(boost::replace_all_copy(sensorName, " ", "_"),
+           sensorConfiguration, objectType, maxReading,
+           minReading,EvStat, LowOffset1, HighOffset1, sensorUnit, sdrRecord),
+    path1(path1), path2(path2), objServer(objectServer), LowOffset1(LowOffset1), HighOffset1(HighOffset1),
+    LowOffset2(LowOffset2), HighOffset2(HighOffset2),
+    inputDev1(io, open(path1.c_str(), O_RDONLY)), inputDev2(io, open(path2.c_str(), O_RDONLY)), waitTimer(io), errCount(0)
+{
+    sensorInterface = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/discretegpio/" + name,
+       "xyz.openbmc_project.Sensor.Value");
+
+    discreteInterfaceState = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/discretegpio/" + name,
+        "xyz.openbmc_project.Sensor.Discrete.State");
+
+    discreteInterfaceState->register_property("ActiveAlarmState", static_cast<uint8_t>(0x00));
+    discreteInterfaceState->register_property("EventData", std::vector<uint8_t>({0xFF, 0xFF, 0xFF}));
+
+    association = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/discretegpio/" + name,
+        "org.openbmc.Associations");
+    setInitialProperties(conn);
+    setupRead();
+}
+
+DiscreteGpio::~DiscreteGpio()
+{
+    // close the input dev to cancel async operations
+    inputDev1.close();
+    inputDev2.close();
+    waitTimer.cancel();
+    objServer.remove_interface(discreteInterfaceState);
+    objServer.remove_interface(sensorInterface);
+    objServer.remove_interface(association);
+}
+
+void DiscreteGpio::setupRead(void)
+{
+    boost::asio::async_read_until(
+        inputDev1, readBuf, '\n',
+        [&](const boost::system::error_code& ec,
+            std::size_t /*bytes_transfered*/) { handleResponse(ec); });
+    boost::asio::async_read_until(
+        inputDev2, readBuf1, '\n',
+        [&](const boost::system::error_code& ec,
+            std::size_t /*bytes_transfered*/) { handleResponse1(ec); });
+
+}
+
+void DiscreteGpio::handleResponse(const boost::system::error_code& err)
+{
+    if (err == boost::system::errc::bad_file_descriptor)
+    {
+        return; // we're being destroyed
+    }
+    std::istream responseStream(&readBuf);
+    if (!err)
+    {
+        std::string response;
+        std::getline(responseStream, response);
+        try
+        {
+            int nvalue = std::stoi(response);
+               if(nvalue == 0){
+                       std::cerr << "read dev1 0 \n";
+                       if(LowOffset1 != 0xff){
+                               updateState(nvalue, laststate | (0x01 << LowOffset1), LowOffset1);
+                       }else{
+                               updateState(nvalue, laststate & (~(0x01 << HighOffset1)), LowOffset1);
+                       }
+               }else{
+                       std::cerr << "read dev1 1 \n";
+                       if(HighOffset1 != 0xff){
+                                updateState(nvalue, laststate | (0x01 << HighOffset1), HighOffset1);
+                        }else{
+                                updateState(nvalue, laststate & (~(0x01 << LowOffset1)), HighOffset1);
+                        }
+               }
+            errCount = 0;
+        }
+        catch (const std::invalid_argument&)
+        {
+            errCount++;
+        }
+    }
+    else
+    {
+        errCount++;
+    }
+
+    // only print once
+    if (errCount == warnAfterErrorCount)
+    {
+        std::cerr << "Failure to read sensor " << name << " at " << path1
+                  << " ec:" << err << "\n";
+    }
+
+    if (errCount >= warnAfterErrorCount)
+    {
+        //updateState(0);
+    }
+    responseStream.clear();
+    inputDev1.close();
+    int fd = open(path1.c_str(), O_RDONLY);
+    if (fd <= 0)
+    {
+        return; // we're no longer valid
+    }
+    inputDev1.assign(fd);
+
+}
+
+void DiscreteGpio::handleResponse1(const boost::system::error_code& err)
+{
+    if (err == boost::system::errc::bad_file_descriptor)
+    {
+        return; // we're being destroyed
+    }
+    std::istream responseStream(&readBuf1);
+    if (!err)
+    {
+        std::string response;
+        std::getline(responseStream, response);
+        try
+        {
+            int nvalue = std::stoi(response);
+               if(nvalue == 0){
+                       std::cerr << "read dev2 0 \n";
+                        if(LowOffset2 != 0xff){
+                                updateState(nvalue, laststate | (0x01 << LowOffset2), LowOffset2);
+                        }else{
+                                updateState(nvalue, laststate & (~(0x01 << HighOffset2)), LowOffset2);
+                        }
+                }else{
+                       std::cerr << "read dev2 1 \n";
+                        if(HighOffset2 != 0xff){
+                                updateState(nvalue, laststate | (0x01 << HighOffset2), HighOffset2);
+                        }else{
+                                updateState(nvalue, laststate & (~(0x01 << LowOffset2)), HighOffset2);
+                        }
+                }
+            errCount = 0;
+        }
+        catch (const std::invalid_argument&)
+        {
+            errCount++;
+        }
+    }
+    else
+    {
+        errCount++;
+    }
+
+    // only print once
+    if (errCount == warnAfterErrorCount)
+    {
+        std::cerr << "Failure to read sensor " << name << " at " << path2
+                  << " ec:" << err << "\n";
+    }
+
+    if (errCount >= warnAfterErrorCount)
+    {
+       // updateState(0);
+    }
+    responseStream.clear();
+    inputDev2.close();
+    int fd = open(path2.c_str(), O_RDONLY);
+    if (fd <= 0)
+    {
+        return; // we're no longer valid
+    }
+    inputDev2.assign(fd);
+    waitTimer.expires_from_now(boost::posix_time::milliseconds(sensorPollMs));
+    waitTimer.async_wait([&](const boost::system::error_code& ec) {
+        if (ec == boost::asio::error::operation_aborted)
+        {
+            return; // we're being canceled
+        }
+        setupRead();
+    });
+}
diff -Naur a/src/EventMain.cpp b/src/EventMain.cpp
--- a/src/EventMain.cpp	2021-03-04 08:04:44.924721424 +0530
+++ b/src/EventMain.cpp	2021-03-04 11:10:54.492960498 +0530
@@ -6,6 +6,7 @@
 */
 #include <EventSensor.hpp>
 #include <AcpiSensor.hpp>
+#include <WatchdogSensor.hpp>
 #include <Utils.hpp>
 #include <boost/algorithm/string/predicate.hpp>
 #include <boost/algorithm/string/replace.hpp>
@@ -19,8 +20,10 @@
 static constexpr bool DEBUG = false;
 
 namespace fs = std::filesystem;
-static constexpr std::array<const char*, 1> sensorTypes = {
-    "xyz.openbmc_project.Configuration.Discevent"};
+static constexpr std::array<const char*, 2> sensorTypes = {
+    "xyz.openbmc_project.Configuration.Discevent",
+    "xyz.openbmc_project.Configuration.Watchevent"};
+
 
 bool is_number(const std::string& s)
 {
@@ -41,6 +44,7 @@
     boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
     boost::container::flat_map<std::string, std::unique_ptr<EventSensor>>&
     sensors, boost::container::flat_map<std::string, std::unique_ptr<AcpiSensor>>& acpi,
+    boost::container::flat_map<std::string, std::unique_ptr<WatchdogSensor>>& watchdog,
     std::shared_ptr<sdbusplus::asio::connection>& dbusConnection, std::shared_ptr<sdbusplus::asio::connection> bus,
     const std::unique_ptr<boost::container::flat_set<std::string>>&
         sensorsChanged)
@@ -171,6 +175,11 @@
              sensorPath, sensorType, objectServer,
              dbusConnection, bus, io, sensorName,
 	     *interfacePath,EvStat,sensorUnit, 0x00, 0x00,sdrRecord);
+       }else if(sensorType == "xyz.openbmc_project.Configuration.Watchevent"){
+          watchdog[sensorName] = std::make_unique<WatchdogSensor>(
+             sensorType, objectServer,
+             dbusConnection, io, sensorName,
+             *interfacePath,EvStat,sensorUnit, 0x00, 0x00 ,sdrRecord);
        }else{
           sensors[sensorName] = std::make_unique<EventSensor>(
              sensorPath, sensorType, objectServer,
@@ -190,12 +199,14 @@
         sensors;
     boost::container::flat_map<std::string, std::unique_ptr<AcpiSensor>>
        acpi;
+    boost::container::flat_map<std::string, std::unique_ptr<WatchdogSensor>>
+       watchdog;
     std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
     std::unique_ptr<boost::container::flat_set<std::string>> sensorsChanged =
         std::make_unique<boost::container::flat_set<std::string>>();
 
     io.post([&]() {
- 	   createSensors(io, objectServer, sensors, acpi, systemBus, systemBus, nullptr);
+	createSensors(io, objectServer, sensors, acpi, watchdog, systemBus, systemBus, nullptr);
     });
 
     boost::asio::deadline_timer filterTimer(io);
@@ -221,7 +232,7 @@
                     std::cerr << "timer error\n";
                     return;
                 }
-		createSensors(io, objectServer, sensors, acpi, systemBus, systemBus,
+		createSensors(io, objectServer, sensors, acpi, watchdog, systemBus, systemBus,
                               sensorsChanged);
             });
         };
diff -Naur a/src/GpioMain.cpp b/src/GpioMain.cpp
--- a/src/GpioMain.cpp	2021-03-04 08:04:44.924721424 +0530
+++ b/src/GpioMain.cpp	2021-03-04 11:12:26.445781172 +0530
@@ -6,6 +6,7 @@
 */
 
 #include <GpioSensor.hpp>
+#include <DiscreteGpio.hpp>
 #include <Utils.hpp>
 #include <boost/algorithm/string/predicate.hpp>
 #include <boost/algorithm/string/replace.hpp>
@@ -19,8 +20,9 @@
 static constexpr bool DEBUG = false;
 
 namespace fs = std::filesystem;
-static constexpr std::array<const char*, 1> sensorTypes = {
-    "xyz.openbmc_project.Configuration.Digitalgpio"};
+static constexpr std::array<const char*, 2> sensorTypes = {
+    "xyz.openbmc_project.Configuration.Digitalgpio",
+    "xyz.openbmc_project.Configuration.Discretegpio"};
 
 bool is_number(const std::string& s)
 {
@@ -40,7 +42,8 @@
 void createSensors(
     boost::asio::io_service& io, sdbusplus::asio::object_server& objectServer,
     boost::container::flat_map<std::string, std::unique_ptr<GpioSensor>>&
-        sensors,
+    sensors, boost::container::flat_map<std::string, std::unique_ptr<DiscreteGpio>>&
+        Discgpiosensor,
     std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
     const std::unique_ptr<boost::container::flat_set<std::string>>&
         sensorsChanged)
@@ -73,8 +76,7 @@
     // configuration
 for (auto& path : paths)
     {
-
-       int index;
+	int index, index1, index2;
         index=findeIndex(path.string());
         if(index == 0xff)
             continue;
@@ -108,18 +110,50 @@
                          << deviceName << "\n";
                 continue;
             }
-            auto configurationIndex = baseConfiguration->second.find("Index");
+	    if(sensorType == "xyz.openbmc_project.Configuration.Digitalgpio"){
+               auto configurationIndex = baseConfiguration->second.find("Index");
 
-            if (configurationIndex == baseConfiguration->second.end())
-            {
-                std::cerr << "error finding Index in configuration";
-                continue;
-            }
+	       if (configurationIndex == baseConfiguration->second.end())
+               {
+                       std::cerr << "error finding Index in configuration";
+                       continue;
+               }
+
+               if (std::get<uint64_t>(configurationIndex->second) != index)
+               {
+                       continue;
+               }
+	    }else if(sensorType == "xyz.openbmc_project.Configuration.Discretegpio"){
+               auto configurationIndex1 = baseConfiguration->second.find("Index1");
+               auto configurationIndex2 = baseConfiguration->second.find("Index2");
 
-            if (std::get<uint64_t>(configurationIndex->second) != index)
-            {
-                continue;
-            }
+	       if (configurationIndex1 == baseConfiguration->second.end() ||
+                               configurationIndex2 == baseConfiguration->second.end())
+                {
+                        std::cerr << "error finding Index in configuration";
+                        continue;
+                }
+
+                if (std::get<uint64_t>(configurationIndex1->second) == index)
+                {
+                       index1 = index;
+                       for (auto& pathcheck : paths)
+                       {
+                               int indx;
+                               indx=findeIndex(pathcheck.string());
+                               if(indx == 0xff)
+                                       continue;
+
+                               if(std::get<uint64_t>(configurationIndex2->second) == indx)
+                               {
+                                       index2 = indx;
+                                       break;
+                               }
+                       }
+               }else{
+                       continue;
+               }
+           }
 
             interfacePath = &(sensor.first.str);
             break;
@@ -159,24 +193,62 @@
             std::visit(VariantToUnsignedIntVisitor(), findEvStat->second);
 
         //Digital Event Offset
-	auto findSensorLowOffset = baseConfiguration->second.find("LowOffset");
-        if (findSensorLowOffset == baseConfiguration->second.end())
-	{
-            std::cerr << "could not determine configuration LowOffset for "
-                       << deviceName << "\n";
-            continue;
-        }
-        uint8_t sensorLowOffset = std::visit(VariantToUnsignedIntVisitor(), findSensorLowOffset->second);
+	uint8_t sensorLowOffset, sensorLowOffset1, sensorLowOffset2;
+       uint8_t sensorHighOffset, sensorHighOffset1, sensorHighOffset2;
+       if(sensorType == "xyz.openbmc_project.Configuration.Digitalgpio"){
+               auto findSensorLowOffset = baseConfiguration->second.find("LowOffset");
+               if (findSensorLowOffset == baseConfiguration->second.end())
+               {
+                       std::cerr << "could not determine configuration LowOffset for "
+                             << deviceName << "\n";
+                       continue;
+               }
+               sensorLowOffset = std::visit(VariantToUnsignedIntVisitor(), findSensorLowOffset->second);
+
+               auto findSensorHighOffset = baseConfiguration->second.find("HighOffset");
+               if (findSensorHighOffset == baseConfiguration->second.end())
+               {
+                       std::cerr << "could not determine configuration HighOffset for "
+                               << deviceName << "\n";
+                       continue;
+               }
+               sensorHighOffset = std::visit(VariantToUnsignedIntVisitor(), findSensorHighOffset->second);
+       }else if(sensorType == "xyz.openbmc_project.Configuration.Discretegpio"){
+               auto findSensorLowOffset1 = baseConfiguration->second.find("LowOffset1");
+                if (findSensorLowOffset1 == baseConfiguration->second.end())
+                {
+                        std::cerr << "could not determine configuration LowOffset1 for "
+                              << deviceName << "\n";
+                        continue;
+                }
+                sensorLowOffset1 = std::visit(VariantToUnsignedIntVisitor(), findSensorLowOffset1->second);
+		auto findSensorHighOffset1 = baseConfiguration->second.find("HighOffset1");
+                if (findSensorHighOffset1 == baseConfiguration->second.end())
+                {
+                        std::cerr << "could not determine configuration HighOffset1 for "
+                                << deviceName << "\n";
+                        continue;
+                }
+                sensorHighOffset1 = std::visit(VariantToUnsignedIntVisitor(), findSensorHighOffset1->second);
 
-	//Digital Event Offset
-        auto findSensorHighOffset = baseConfiguration->second.find("HighOffset");
-        if (findSensorHighOffset == baseConfiguration->second.end())
-        {
-            std::cerr << "could not determine configuration HighOffset for "
-                      << deviceName << "\n";
-           continue;
-        }
-        uint8_t sensorHighOffset = std::visit(VariantToUnsignedIntVisitor(), findSensorHighOffset->second);
+               auto findSensorLowOffset2 = baseConfiguration->second.find("LowOffset2");
+                if (findSensorLowOffset2 == baseConfiguration->second.end())
+                {
+                        std::cerr << "could not determine configuration LowOffset2 for "
+                              << deviceName << "\n";
+                        continue;
+                }
+                sensorLowOffset2 = std::visit(VariantToUnsignedIntVisitor(), findSensorLowOffset2->second);
+
+                auto findSensorHighOffset2 = baseConfiguration->second.find("HighOffset2");
+                if (findSensorHighOffset2 == baseConfiguration->second.end())
+                {
+                        std::cerr << "could not determine configuration HighOffset2 for "
+                                << deviceName << "\n";
+                        continue;
+                }
+                sensorHighOffset2 = std::visit(VariantToUnsignedIntVisitor(), findSensorHighOffset2->second);
+       }
 
         // on rescans, only update sensors we were signaled by
         auto findSensor = sensors.find(sensorName);
@@ -210,11 +282,21 @@
 
        std::string sensorPath="/sys/class/gpio/gpio"+std::to_string(index)+"/value";
 
+       if(sensorType == "xyz.openbmc_project.Configuration.Digitalgpio"){
         sensors[sensorName] = std::make_unique<GpioSensor>(
             sensorPath, sensorType, objectServer,
             dbusConnection, io, sensorName,
 	    *interfacePath,EvStat,sensorUnit,sensorLowOffset, sensorHighOffset,sdrRecord);
-    }
+       } 
+      else if(sensorType == "xyz.openbmc_project.Configuration.Discretegpio"){
+               std::string sensorPath1="/sys/class/gpio/gpio"+std::to_string(index1)+"/value";
+               std::string sensorPath2="/sys/class/gpio/gpio"+std::to_string(index2)+"/value";
+               Discgpiosensor[sensorName] = std::make_unique<DiscreteGpio>(
+                       sensorPath1, sensorPath2, sensorType, objectServer,dbusConnection, io, sensorName,
+                       *interfacePath,EvStat,sensorUnit,sensorLowOffset1,
+                       sensorHighOffset1, sensorLowOffset2, sensorHighOffset2, sdrRecord);
+       }
+   }
 }
 
 int main()
@@ -225,12 +307,13 @@
     sdbusplus::asio::object_server objectServer(systemBus);
     boost::container::flat_map<std::string, std::unique_ptr<GpioSensor>>
         sensors;
+    boost::container::flat_map<std::string, std::unique_ptr<DiscreteGpio>> Discgpiosensor;
     std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
     std::unique_ptr<boost::container::flat_set<std::string>> sensorsChanged =
         std::make_unique<boost::container::flat_set<std::string>>();
 
     io.post([&]() {
-        createSensors(io, objectServer, sensors, systemBus, nullptr);
+	createSensors(io, objectServer, sensors, Discgpiosensor, systemBus, nullptr); 
     });
 
     boost::asio::deadline_timer filterTimer(io);
@@ -256,7 +339,7 @@
                     std::cerr << "timer error\n";
                     return;
                 }
-                createSensors(io, objectServer, sensors, systemBus,
+		createSensors(io, objectServer, sensors, Discgpiosensor, systemBus,
                               sensorsChanged);
             });
         };
diff -Naur a/src/WatchdogSensor.cpp b/src/WatchdogSensor.cpp
--- a/src/WatchdogSensor.cpp	1970-01-01 05:30:00.000000000 +0530
+++ b/src/WatchdogSensor.cpp	2021-03-04 19:46:02.011359229 +0530
@@ -0,0 +1,227 @@
+/*
+//
+// Auther: selvaganapathim
+// Email : selvaganapathim@amiindia.co.in
+//
+*/
+
+#include <unistd.h>
+
+#include <WatchdogSensor.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/asio/read_until.hpp>`
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <iostream>
+#include <limits>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+#include <string>
+#include <fcntl.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+
+static constexpr double maxReading = 127;
+static constexpr double minReading = -128;
+WatchdogSensor::WatchdogSensor(
+    const std::string& objectType, sdbusplus::asio::object_server& objectServer,
+    std::shared_ptr<sdbusplus::asio::connection>& conn,
+    boost::asio::io_service& io, const std::string& sensorName,
+    const std::string& sensorConfiguration,uint16_t EvStat , const std::string& sensorUnit,
+    uint8_t LowOffset, uint8_t HighOffset, struct sdr::SdrRecord sdrRecord) :
+    DiscSensor(boost::replace_all_copy(sensorName, " ", "_"),
+           sensorConfiguration, objectType, maxReading,
+           minReading,EvStat, LowOffset, HighOffset, sensorUnit,sdrRecord),
+           objServer(objectServer)
+{
+
+    sensorInterface = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/eventsensor/" + name,
+        "xyz.openbmc_project.Sensor.Value");
+
+    discreteInterfaceState = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/eventsensor/" + name,
+        "xyz.openbmc_project.Sensor.Discrete.State");
+
+    data = {0xFF,0xFF,0xFF};
+    al = 0x00;
+                      discreteInterfaceState->register_property("EventData",data,
+                       [&](const std::vector<uint8_t>& request, std::vector<uint8_t>& oldValue) {
+                   oldValue = request;
+                     data = request;
+                    return 1;
+                });
+
+                  discreteInterfaceState->register_property("ActiveAlarmState",al,
+                        [&](const uint8_t& request, uint8_t& oldValue) {
+                    oldValue = request;
+                     al = request;
+                     return 1;
+                 });
+
+    association = objectServer.add_interface(
+        "/xyz/openbmc_project/sensors/eventsensor/" + name,
+        "org.openbmc.Associations");
+    setInitialProperties(conn);
+
+    mmap_read((AST_SCU_REG_BASE+AST_SCU_SYSRST_CTRLSTATUS_REG_OFFSET), &val);
+    std::cerr << "WFT reset val read \n";
+
+     std::cerr << "mmap read value" << val << "\n";
+    if(val & SYSRST_CTRLSTAT_WDT1_RESET_BIT)
+    {
+           std::cerr << "BMC watchdog assrted \n";
+           fd = open(CONF_WDT_TIMEOUT_FILE, O_RDWR | O_CREAT, S_IRWXU | S_IRWXG | S_IRWXO);
+            if(fd < 0)
+            {
+                   std::cerr << "open failed \n";
+            }
+           std::cerr << "BMC watchdog lseek \n";
+            lseek (fd, 0, SEEK_SET);
+
+            //Read the File for number of counts the BMC rebooted because of watchdog timeout.
+            //If count is "0" after reading the file then it may be first time.
+           std::cerr << "BMC watchdog read file \n";
+            if(-1 == read(fd, &count, sizeof(char)))
+            {
+                  close(fd);
+            }
+
+            if(count < 2)
+            {
+                 std::cerr << "BMC watchdog count less \n";
+                 //Every time the BMC reboots because of WDT timeout, increment the count till 3 in the file.
+                  count ++;
+                 std::cerr << "BMC watchdog lseek write \n";
+                  lseek (fd, 0, SEEK_SET);
+                  if(-1 == write(fd, &count, sizeof(char)))
+                  {
+                                close(fd);
+                                fd = -1;
+                  }
+                 std::cerr << "BMC watchdog write count complete \n";
+           }
+           else{
+                  //When the count reaches 3, add a SEL Entry and Remove the file.
+		  discreteInterfaceState->set_property("EventData", std::vector<uint8_t>({0xFF, 0xFF, 0xFF}));
+                  discreteInterfaceState->set_property("ActiveAlarmState", static_cast<uint8_t>(0x00));
+
+		  discreteInterfaceState->set_property("EventData", std::vector<uint8_t>({0x01, 0xFF, 0xFF}));
+                  discreteInterfaceState->set_property("ActiveAlarmState", static_cast<uint8_t>(0x01));
+
+                 std::cerr << "BMC watchdog lseek write \n";
+                 if(stat(CONF_WDT_TIMEOUT_FILE, &buf) == 0)
+                  {
+                       unlink(CONF_WDT_TIMEOUT_FILE);
+                 }
+                 std::cerr << "BMC watchdog unlinked \n";
+            }
+           std::cerr << "BMC watchdog clear reset \n";
+           mmap_write(AST_SCU_REG_BASE, AST_SCU_UNLOCK_KEY);
+           val &= ~(SYSRST_CTRLSTAT_WDT1_RESET_BIT);
+           std::cerr << "write value" << val << "\n";
+           mmap_write((AST_SCU_REG_BASE+AST_SCU_SYSRST_CTRLSTATUS_REG_OFFSET), val);
+           //mmap_write(AST_SCU_REG_BASE, 0x00);
+           if(fd)
+                close(fd);
+
+           std::cerr << "BMC watchdog close fd \n";
+    }else{
+        std::cerr << "BMC watchdog not asserted \n";
+        if(stat(CONF_WDT_TIMEOUT_FILE, &buf) == 0)
+         {
+              unlink(CONF_WDT_TIMEOUT_FILE);
+         }
+        std::cerr << "BMC watchdog unlinked \n";
+    }
+
+}
+
+WatchdogSensor::~WatchdogSensor()
+{
+    // close the input dev to cancel async operations
+    objServer.remove_interface(discreteInterfaceState);
+    objServer.remove_interface(sensorInterface);
+    objServer.remove_interface(association);
+}
+
+int WatchdogSensor::mmap_read(unsigned long addr, unsigned long *data)
+{
+       void *vrt;
+       int devmem_fd = -1;
+       void *map;
+       unsigned long ofset = 0;
+       devmem_fd = open("/dev/mem", O_RDWR | O_SYNC);
+       if (devmem_fd < 0)
+        {
+               std::cerr << "ERROR: Unable to open Memory Access Driver\n";
+        }
+
+       int page_size = getpagesize ();
+
+        if (addr % page_size)
+                ofset = (addr % page_size);
+
+        addr -= ofset;
+
+        map = mmap(0,  page_size, PROT_READ | PROT_WRITE, MAP_SHARED, devmem_fd, addr);
+       if (map == MAP_FAILED)
+        {
+               std::cerr << "ERROR: Failed to map physical memory";
+               close(devmem_fd);
+                return NULL;
+        }
+
+       vrt = map + ofset;
+       *data = *((unsigned long *)vrt);
+
+       if (munmap(map, page_size) == -1)
+        {
+                std::cerr << "Error in unmapping \n";
+        }
+       map = NULL;
+
+       close(devmem_fd);
+       return 0;
+}
+
+int WatchdogSensor::mmap_write(unsigned long addr, unsigned long data)
+{
+       void *vrt;
+       int devmem_fd = -1;
+        void *map;
+       unsigned long ofset = 0;
+        devmem_fd = open("/dev/mem", O_RDWR | O_SYNC);
+       if (devmem_fd < 0)
+        {
+                std::cerr << "ERROR: Unable to open Memory Access Driver\n";
+       }
+
+       int page_size = getpagesize ();
+
+        if (addr % page_size)
+                ofset = (addr % page_size);
+
+        addr -= ofset;
+
+        map = mmap(0, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, devmem_fd, addr);
+       if (map == MAP_FAILED)
+        {
+                std::cerr << "ERROR: Failed to map physical memory";
+                close(devmem_fd);
+                return NULL;
+        }
+
+       vrt = map + ofset;
+        *(unsigned long *)vrt = data;
+
+       if (munmap(map, page_size) == -1)
+        {
+                std::cerr << "Error in unmapping \n";
+        }
+       map = NULL;
+        close(devmem_fd);
+       return 0;
+}
+
