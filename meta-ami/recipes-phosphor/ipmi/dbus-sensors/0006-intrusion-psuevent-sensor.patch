diff -Naur a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2021-03-25 11:41:19.132429697 +0530
+++ b/CMakeLists.txt	2021-03-25 18:24:05.840029927 +0530
@@ -47,6 +47,7 @@
 option (DISABLE_INTRUSION "Disable installing intrusion sensor" OFF)
 option (DISABLE_IPMB "Disable installing IPMB sensor" OFF)
 option (DISABLE_MCUTEMP "Disable installing MCU temperature sensor" OFF)
+option (DISABLE_PSU_EVENT "Disable installing PSU_EVENT sensor" OFF)
 option (DISABLE_PSU "Disable installing PSU sensor" OFF)
 option (DISABLE_NVME "Disable installing NVME sensor" ON)
 
@@ -82,6 +83,9 @@
 set (PSU_SRC_FILES src/Utils.cpp src/PSUSensor.cpp src/Thresholds.cpp
      src/PwmSensor.cpp src/PSUEvent.cpp src/SdrRecord.cpp)
 
+set (PSUEVENT_SRC_FILES src/Utils.cpp src/PSUSensor.cpp src/PSUEvent.cpp
+     src/PwmSensor.cpp src/Thresholds.cpp src/SdrRecord.cpp)
+
 set (NVME_SRC_FILES src/Utils.cpp src/NVMeSensorMain.cpp src/NVMeSensor.cpp src/Thresholds.cpp src/SdrRecord.cpp)
 
 set (EXTERNAL_PACKAGES Boost sdbusplus-project nlohmann-json)
@@ -211,6 +215,10 @@
 add_dependencies (psusensor sdbusplus-project)
 target_link_libraries (psusensor ${SENSOR_LINK_LIBS})
 
+add_executable (psuevent src/PSUEventMain.cpp ${PSUEVENT_SRC_FILES})
+add_dependencies (psuevent sdbusplus-project)
+target_link_libraries (psuevent ${SENSOR_LINK_LIBS})
+
 if (NOT DISABLE_NVME)
     add_executable (nvmesensor ${NVME_SRC_FILES})
     add_dependencies (nvmesensor sdbusplus-project)
@@ -319,6 +327,13 @@
                  DESTINATION ${SERVICE_FILE_INSTALL_DIR})
 endif ()
 
+if (NOT DISABLE_PSU_EVENT)
+    install (TARGETS psuevent DESTINATION bin)
+    install (FILES
+                 ${SERVICE_FILE_SRC_DIR}/xyz.openbmc_project.psuevent.service
+                 DESTINATION ${SERVICE_FILE_INSTALL_DIR})
+endif ()
+
 if (NOT DISABLE_NVME)
     install (TARGETS nvmesensor DESTINATION bin)
     install (FILES
diff -Naur a/include/ChassisIntrusionSensor.hpp b/include/ChassisIntrusionSensor.hpp
--- a/include/ChassisIntrusionSensor.hpp	2021-03-25 11:41:05.752375669 +0530
+++ b/include/ChassisIntrusionSensor.hpp	2021-03-25 12:59:20.203860772 +0530
@@ -19,18 +19,18 @@
   public:
     ChassisIntrusionSensor(
         boost::asio::io_service& io,
-        std::shared_ptr<sdbusplus::asio::dbus_interface> iface);
+	std::shared_ptr<sdbusplus::asio::dbus_interface> iface,std::shared_ptr<sdbusplus::asio::dbus_interface> ifacediscrete);
 
     ~ChassisIntrusionSensor();
 
     void start(IntrusionSensorType type, int busId, int slaveAddr,
-              bool gpioInvertedi, uint8_t dtype, uint8_t eventType, uint8_t evStat,
-              uint8_t recordType,
+              bool gpioInverted, uint8_t eventType, uint8_t evStat, uint8_t recordType,
               uint8_t entityId,uint8_t entityInstance, uint8_t sensorInit,uint8_t sensorCap,uint8_t sensorType,
               uint8_t sensorUnit2);
 
   private:
     std::shared_ptr<sdbusplus::asio::dbus_interface> mIface;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> mIfaceDiscrete;
     std::shared_ptr<sdbusplus::asio::connection> mDbusConn;
 
     IntrusionSensorType mType;
@@ -46,13 +46,15 @@
 
     // valid if it is via GPIO
     bool mGpioInverted;
-    uint8_t mdtype, meventType, mevStat;
+    uint8_t  meventType, mevStat;
     uint8_t  mrecordType,mentityId,
             mentityInstance,msensorInit,msensorCap,msensorType,
             msensorUnit2;
     std::string mPinName = "CHASSIS_INTRUSION";
     gpiod::line mGpioLine;
     boost::asio::posix::stream_descriptor mGpioFd;
+    std::vector<uint8_t> data;
+    uint8_t al;
 
     // common members
     bool mOverridenState = false;
@@ -60,7 +62,7 @@
 
     bool mInitialized = false;
 
-    void updateValue(const std::string newValue);
+    void updateValue(const std::string newValue, bool v);
     int i2cReadFromPch(int busId, int slaveAddr);
     void pollSensorStatusByPch();
     void readGpio();
diff -Naur a/include/PSUEvent.hpp b/include/PSUEvent.hpp
--- a/include/PSUEvent.hpp	2021-03-25 11:41:05.748375652 +0530
+++ b/include/PSUEvent.hpp	2021-03-25 13:06:55.107566578 +0530
@@ -21,6 +21,7 @@
 #include <boost/asio/streambuf.hpp>
 #include <boost/container/flat_map.hpp>
 #include <sdbusplus/asio/object_server.hpp>
+#include <sensor.hpp>
 
 #include <memory>
 #include <set>
@@ -30,7 +31,7 @@
 class PSUSubEvent : public std::enable_shared_from_this<PSUSubEvent>
 {
   public:
-    PSUSubEvent(std::shared_ptr<sdbusplus::asio::dbus_interface> eventInterface,
+	PSUSubEvent(std::shared_ptr<sdbusplus::asio::dbus_interface> StateInterface,
                 const std::string& path,
                 std::shared_ptr<sdbusplus::asio::connection>& conn,
                 boost::asio::io_service& io, const std::string& groupEventName,
@@ -40,7 +41,7 @@
                 std::shared_ptr<bool> state, const std::string& psuName);
     ~PSUSubEvent();
 
-    std::shared_ptr<sdbusplus::asio::dbus_interface> eventInterface;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> StateInterface;
     std::shared_ptr<std::set<std::string>> asserts;
     std::shared_ptr<std::set<std::string>> combineEvent;
     std::shared_ptr<bool> assertState;
@@ -77,16 +78,17 @@
         std::shared_ptr<sdbusplus::asio::connection>& conn,
         boost::asio::io_service& io, const std::string& psuName,
         boost::container::flat_map<std::string, std::vector<std::string>>&
-            eventPathList,
+	eventPathList, uint16_t EvStat,
         boost::container::flat_map<
             std::string,
             boost::container::flat_map<std::string, std::vector<std::string>>>&
             groupEventPathList,
-        const std::string& combineEventName);
+	    const std::string& combineEventName,struct sdr::SdrRecord sdrRecord);
     ~PSUCombineEvent();
 
     sdbusplus::asio::object_server& objServer;
-    std::shared_ptr<sdbusplus::asio::dbus_interface> eventInterface;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> SenInterface;
+    std::shared_ptr<sdbusplus::asio::dbus_interface> StateInterface;
     boost::container::flat_map<std::string,
                                std::vector<std::shared_ptr<PSUSubEvent>>>
         events;
diff -Naur a/service_files/xyz.openbmc_project.psuevent.service b/service_files/xyz.openbmc_project.psuevent.service
--- a/service_files/xyz.openbmc_project.psuevent.service	1970-01-01 05:30:00.000000000 +0530
+++ b/service_files/xyz.openbmc_project.psuevent.service	2021-03-25 13:08:23.307698305 +0530
@@ -0,0 +1,12 @@
+[Unit]
+Description=IPMI Event-only Sensor
+StopWhenUnneeded=false
+After=xyz.openbmc_project.EntityManager.service
+
+[Service]
+Restart=always
+RestartSec=5
+ExecStart=/usr/bin/psuevent
+
+[Install]
+WantedBy=multi-user.target
diff -Naur a/src/ChassisIntrusionSensor.cpp b/src/ChassisIntrusionSensor.cpp
--- a/src/ChassisIntrusionSensor.cpp	2021-03-25 11:40:59.120348923 +0530
+++ b/src/ChassisIntrusionSensor.cpp	2021-03-25 19:03:23.141621443 +0530
@@ -47,7 +47,7 @@
 // Status bit field masks
 const static constexpr size_t pchRegMaskIntrusion = 0x01;
 
-void ChassisIntrusionSensor::updateValue(const std::string newValue)
+void ChassisIntrusionSensor::updateValue(const std::string newValue, bool v)
 {
     // Take no action if value already equal
     // Same semantics as Sensor::updateValue(const double&)
@@ -61,6 +61,14 @@
     mIface->set_property("Status", newValue);
     mInternalSet = false;
 
+    if (v == 0){
+       mIfaceDiscrete->set_property("EventData",std::vector<uint8_t>({0xFF, 0xFF, 0xFF}));
+       mIfaceDiscrete->set_property("ActiveAlarmState",static_cast<uint8_t>(0x00));
+    }else if(v == 1){
+        mIfaceDiscrete->set_property("EventData",std::vector<uint8_t>({0x00, 0xFF, 0xFF}));
+        mIfaceDiscrete->set_property("ActiveAlarmState",static_cast<uint8_t>(0x01));
+    }
+
     mValue = newValue;
 
     if (mOldValue == "Normal" && mValue != "Normal")
@@ -157,7 +165,7 @@
             {
                 std::cout << "update value from " << mValue << " to "
                           << newValue << "\n";
-                updateValue(newValue);
+                updateValue(newValue, statusValue ? true : false);
             }
 
             // trigger next polling
@@ -190,7 +198,7 @@
     {
         std::cout << "update value from " << mValue << " to " << newValue
                   << "\n";
-        updateValue(newValue);
+	updateValue(newValue, value ? true : false);
     }
 }
 
@@ -236,7 +244,7 @@
         // set string defined in chassis redfish schema
         auto value = mGpioLine.get_value();
         std::string newValue = value ? "HardwareIntrusion" : "Normal";
-        updateValue(newValue);
+        updateValue(newValue, value ? true : false);
 
         auto gpioLineFd = mGpioLine.event_get_fd();
         if (gpioLineFd < 0)
@@ -272,7 +280,7 @@
 }
 
 void ChassisIntrusionSensor::start(IntrusionSensorType type, int busId,
-                                   int slaveAddr, bool gpioInverted, uint8_t dtype, uint8_t eventType, uint8_t evStat,
+                                   int slaveAddr, bool gpioInverted, uint8_t eventType, uint8_t evStat,
                                   uint8_t recordType, uint8_t entityId,
                                    uint8_t entityInstance, uint8_t sensorInit,uint8_t sensorCap,uint8_t sensorType,
                                   uint8_t sensorUnit2)
@@ -305,7 +313,6 @@
     mBusId = busId;
     mSlaveAddr = slaveAddr;
     mGpioInverted = gpioInverted;
-    mdtype = dtype;
     meventType = eventType;
     mevStat = evStat;
     mrecordType = recordType;
@@ -315,6 +322,10 @@
     msensorCap = sensorCap;
     msensorType = sensorType;
     msensorUnit2 = sensorUnit2;
+    double v = 0;
+    data = {0xFF,0xFF,0xFF};
+    al = 0x00;
+
 
     if ((mType == IntrusionSensorType::pch && mBusId > 0 && mSlaveAddr > 0) ||
         (mType == IntrusionSensorType::gpio))
@@ -327,7 +338,7 @@
                 [&](const std::string& req, std::string& propertyValue) {
                     return setSensorValue(req, propertyValue);
                 });
-           mIface->register_property("DType", mdtype);
+	   mIface->register_property("Value", v);
            mIface->register_property("EventType", meventType);
            mIface->register_property("EvStat", mevStat);
            mIface->register_property("SdrVersion", 81);
@@ -352,6 +363,23 @@
            mIface->register_property("IdStringLen", 0);
             mIface->initialize();
 
+	    mIfaceDiscrete->register_property("ActiveAlarmState",al,
+                        [&](const uint8_t& request, uint8_t& oldValue) {
+                   oldValue = request;
+                   al = request;
+                   return 1;
+               });
+
+	    mIfaceDiscrete->register_property("EventData",data,
+                        [&](const std::vector<uint8_t>& request, std::vector<uint8_t>& oldValue) {
+                    oldValue = request;
+                    data = request;
+                    return 1;
+               });
+
+
+           mIfaceDiscrete->initialize();
+
             if (mType == IntrusionSensorType::gpio)
             {
                 initGpioDeviceFile();
@@ -396,10 +424,10 @@
 
 ChassisIntrusionSensor::ChassisIntrusionSensor(
     boost::asio::io_service& io,
-    std::shared_ptr<sdbusplus::asio::dbus_interface> iface) :
-    mIface(iface),
+    std::shared_ptr<sdbusplus::asio::dbus_interface> iface, std::shared_ptr<sdbusplus::asio::dbus_interface> ifacediscrete) :
+    mIface(iface),mIfaceDiscrete(ifacediscrete),
     mType(IntrusionSensorType::gpio), mValue("unknown"), mOldValue("unknown"),
-    mBusId(-1), mSlaveAddr(-1), mPollTimer(io), mGpioInverted(false),
+    mBusId(-1), mSlaveAddr(-1), mPollTimer(io), mGpioInverted(false),  mevStat(0x00),
     mGpioFd(io)
 {}
 
diff -Naur a/src/IntrusionSensorMain.cpp b/src/IntrusionSensorMain.cpp
--- a/src/IntrusionSensorMain.cpp	2021-03-25 11:40:59.120348923 +0530
+++ b/src/IntrusionSensorMain.cpp	2021-03-25 18:20:16.531664392 +0530
@@ -55,7 +55,7 @@
 static bool getIntrusionSensorConfig(
     std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
     IntrusionSensorType* pType, int* pBusId, int* pSlaveAddr,
-    bool* pGpioInverted, uint8_t *pDtype, uint8_t *pEventType, uint8_t *pEvState,
+    bool* pGpioInverted, uint8_t *pEventType, uint8_t *pEvState,
     uint8_t *precordType,
     uint8_t *pentityId,uint8_t *pentityInstance,uint8_t *psensorInit,uint8_t *psensorCap,
     uint8_t *psensorType,
@@ -112,14 +112,11 @@
             auto findGpioPolarity =
                 baseConfiguration->second.find("GpioPolarity");
 	    auto findGpioIndex =  baseConfiguration->second.find("Index");
-            auto findDtype =  baseConfiguration->second.find("DType");
-            auto findEventType =  baseConfiguration->second.find("EventType");
             auto findEvState =  baseConfiguration->second.find("EvStat");
 
 
             if (findGpioPolarity == baseConfiguration->second.end() || 
 		findGpioIndex ==  baseConfiguration->second.end() ||
-   		findEventType ==  baseConfiguration->second.end()||
 		findEvState ==  baseConfiguration->second.end()
 	      )
             {
@@ -138,20 +135,15 @@
             {
                 *pGpioInverted =
                     (std::get<std::string>(findGpioPolarity->second) == "Low");
-		*pDtype = /*sdbusplus::message::variant_ns::get<uint8_t>(
-                    findDtype->second);*/
-                std::visit(VariantToUnsignedIntVisitor(), findDtype->second);
-                *pEventType = /*sdbusplus::message::variant_ns::get<uint8_t>(
-                    findEventType->second);*/
-                std::visit(VariantToUnsignedIntVisitor(), findEventType->second);
                 *pEvState = /*sdbusplus::message::variant_ns::get<uint8_t>(
                     findEvState->second);*/
                 std::visit(VariantToUnsignedIntVisitor(), findEvState->second);
-               *precordType = sdrRecord.RecordType;
+                *precordType = sdrRecord.RecordType;
                *pentityId = sdrRecord.EntityId;
                *pentityInstance = sdrRecord.EntityInstance;
                *psensorInit = sdrRecord.SensorInit;
                *psensorCap = sdrRecord.SensorCap;
+	       *pEventType = sdrRecord.EventType;
 	       *psensorType = sdrRecord.SensorType;
                *psensorUnit2 = sdrRecord.SensorUnit2;
 
@@ -480,7 +472,7 @@
     int busId = -1;
     int slaveAddr = -1;
     bool gpioInverted = false;
-    uint8_t dtype, eventType, evStat;
+    uint8_t eventType, evStat;
     uint8_t recordType,entityId,
             entityInstance,sensorInit,sensorCap,SensorType,
             sensorUnit2;
@@ -496,18 +488,23 @@
 
     std::shared_ptr<sdbusplus::asio::dbus_interface> ifaceChassis =
         objServer.add_interface(
-            "/xyz/openbmc_project/Intrusion/Chassis_Intrusion",
-            "xyz.openbmc_project.Chassis.Intrusion");
+		"/xyz/openbmc_project/sensors/Intrusion/Chassis_Intrusion",
+                "xyz.openbmc_project.Sensor.Value");
 
-    ChassisIntrusionSensor chassisIntrusionSensor(io, ifaceChassis);
+    std::shared_ptr<sdbusplus::asio::dbus_interface> ifaceDiscrete =
+        objServer.add_interface(
+            "/xyz/openbmc_project/sensors/Intrusion/Chassis_Intrusion",
+           "xyz.openbmc_project.Sensor.Discrete.State");
+
+    ChassisIntrusionSensor chassisIntrusionSensor(io, ifaceChassis, ifaceDiscrete);
 
     if (getIntrusionSensorConfig(systemBus, &type, &busId, &slaveAddr,
-                                 &gpioInverted, &dtype, &eventType, &evStat,
+                                 &gpioInverted, &eventType, &evStat,
                                  &recordType,
                                  &entityId,&entityInstance,&sensorInit,&sensorCap,&SensorType,
                                  &sensorUnit2))
     {
-        chassisIntrusionSensor.start(type, busId, slaveAddr, gpioInverted,dtype, eventType, evStat,recordType,entityId,
+        chassisIntrusionSensor.start(type, busId, slaveAddr, gpioInverted, eventType, evStat,recordType,entityId,
                                      entityInstance,sensorInit,sensorCap,SensorType,
                                      sensorUnit2);
     }
@@ -523,13 +520,13 @@
 
             std::cout << "rescan due to configuration change \n";
             if (getIntrusionSensorConfig(systemBus, &type, &busId, &slaveAddr,
-                                         &gpioInverted,&dtype, &eventType, &evStat,
+                                         &gpioInverted, &eventType, &evStat,
                                  &recordType,
                                  &entityId,&entityInstance,&sensorInit,&sensorCap,&SensorType,
                                  &sensorUnit2))
             {
                 chassisIntrusionSensor.start(type, busId, slaveAddr,
-                                             gpioInverted,dtype, eventType, evStat,recordType,entityId,
+                                             gpioInverted, eventType, evStat,recordType,entityId,
                                      entityInstance,sensorInit,sensorCap,SensorType,
                                      sensorUnit2);
             }
diff -Naur a/src/PSUEvent.cpp b/src/PSUEvent.cpp
--- a/src/PSUEvent.cpp	2021-03-25 11:40:59.112348891 +0530
+++ b/src/PSUEvent.cpp	2021-03-25 21:03:02.426766088 +0530
@@ -37,23 +37,59 @@
     std::shared_ptr<sdbusplus::asio::connection>& conn,
     boost::asio::io_service& io, const std::string& psuName,
     boost::container::flat_map<std::string, std::vector<std::string>>&
-        eventPathList,
+    eventPathList, uint16_t EvStat,
     boost::container::flat_map<
         std::string,
         boost::container::flat_map<std::string, std::vector<std::string>>>&
-        groupEventPathList,
-    const std::string& combineEventName) :
+	groupEventPathList,
+    const std::string& combineEventName, struct sdr::SdrRecord sdrRecord) :
     objServer(objectServer)
 {
-    eventInterface = objServer.add_interface(
-        "/xyz/openbmc_project/State/Decorator/" + psuName + "_" +
-            combineEventName,
-        "xyz.openbmc_project.State.Decorator.OperationalStatus");
-    eventInterface->register_property("functional", true);
+    SenInterface = objServer.add_interface(
+       "/xyz/openbmc_project/sensors/PSU/" + psuName,
+       "xyz.openbmc_project.Sensor.Value");
+
+    SenInterface->register_property("EventType",sdrRecord.EventType);
+    SenInterface->register_property("EvStat", EvStat);
+    SenInterface->register_property("SensorStat", false);
+    SenInterface->register_property("SdrVersion", 81);
+    SenInterface->register_property("RecordType",sdrRecord.RecordType);
+    SenInterface->register_property("RecordLen",0);
+    SenInterface->register_property("OwnerId", 32);
+    SenInterface->register_property("OwnerLun", 0);
+    SenInterface->register_property("EntityId",sdrRecord.EntityId);
+    SenInterface->register_property("EntityInstance",sdrRecord.EntityInstance );
+    SenInterface->register_property("SensorInit",sdrRecord.SensorInit);
+    SenInterface->register_property("SensorCap",sdrRecord.SensorCap);
+    SenInterface->register_property("SensorType",sdrRecord.SensorType);
+    SenInterface->register_property("SensorUnit1", 0);
+    SenInterface->register_property("SensorUnit2", sdrRecord.SensorUnit2);
+    SenInterface->register_property("ModifierUnit", 0);
+    SenInterface->register_property("Linearization", 0);
+    SenInterface->register_property("NominalReading", 151);
+    SenInterface->register_property("NormalMax", 197);
+    SenInterface->register_property("NormalMin", 139);
+    SenInterface->register_property("PositiveHysteris", 0);
+    SenInterface->register_property("NegativeHysteresis",0);
+    SenInterface->register_property("IdStringLen", 0);
+
+    SenInterface->register_property("Value", 0);
+
+    if (!SenInterface->initialize())
+    {
+        std::cerr << "error initializing PSUSen interface\n";
+    }
+
+    StateInterface = objServer.add_interface(
+        "/xyz/openbmc_project/sensors/PSU/" + psuName,
+        "xyz.openbmc_project.Sensor.Discrete.State");
 
-    if (!eventInterface->initialize())
+    StateInterface->register_property("ActiveAlarmState", static_cast<uint8_t>(0x00));
+    StateInterface->register_property("EventData", std::vector<uint8_t>({0xFF, 0xFF, 0xFF}));
+
+    if (!StateInterface->initialize())
     {
-        std::cerr << "error initializing event interface\n";
+	std::cerr << "error initializing PSUState interface\n";
     }
 
     std::shared_ptr<std::set<std::string>> combineEvent =
@@ -69,7 +105,7 @@
         for (const auto& path : pathList.second)
         {
             auto p = std::make_shared<PSUSubEvent>(
-                eventInterface, path, conn, io, eventName, eventName, assert,
+		StateInterface, path, conn, io, eventName, eventName, assert,
                 combineEvent, state, psuName);
             p->setupRead();
 
@@ -92,7 +128,7 @@
             for (const auto& path : pathList.second)
             {
                 auto p = std::make_shared<PSUSubEvent>(
-                    eventInterface, path, conn, io, groupEventName,
+		    StateInterface, path, conn, io, groupEventName,
                     groupPathList.first, assert, combineEvent, state, psuName);
                 p->setupRead();
                 events[eventPSUName].emplace_back(p);
@@ -115,7 +151,7 @@
         }
     }
     events.clear();
-    objServer.remove_interface(eventInterface);
+    objServer.remove_interface(StateInterface);
 }
 
 static boost::container::flat_map<std::string,
@@ -137,7 +173,7 @@
           "OpenBMC.0.1.PowerSupplyConfigurationErrorRecovered"}}};
 
 PSUSubEvent::PSUSubEvent(
-    std::shared_ptr<sdbusplus::asio::dbus_interface> eventInterface,
+    std::shared_ptr<sdbusplus::asio::dbus_interface> StateInterface,
     const std::string& path, std::shared_ptr<sdbusplus::asio::connection>& conn,
     boost::asio::io_service& io, const std::string& groupEventName,
     const std::string& eventName,
@@ -145,7 +181,7 @@
     std::shared_ptr<std::set<std::string>> combineEvent,
     std::shared_ptr<bool> state, const std::string& psuName) :
     std::enable_shared_from_this<PSUSubEvent>(),
-    eventInterface(eventInterface), asserts(asserts),
+    StateInterface(StateInterface), asserts(asserts),
     combineEvent(combineEvent), assertState(state), errCount(0), path(path),
     eventName(eventName), waitTimer(io), inputDev(io), psuName(psuName),
     groupEventName(groupEventName), systemBus(conn)
@@ -269,6 +305,7 @@
 {
     // Take no action if value already equal
     // Same semantics as Sensor::updateValue(const double&)
+    static uint8_t fst,st;
     if (newValue == value)
     {
         return;
@@ -276,97 +313,59 @@
 
     if (newValue == 0)
     {
-        // log deassert only after all asserts are gone
-        if (!(*asserts).empty())
-        {
-            auto found = (*asserts).find(path);
-            if (found == (*asserts).end())
-            {
-                return;
-            }
-            (*asserts).erase(path);
-
-            return;
-        }
-        if (*assertState == true)
-        {
-            *assertState = false;
-            auto foundCombine = (*combineEvent).find(groupEventName);
-            if (foundCombine == (*combineEvent).end())
-            {
-                return;
-            }
-            (*combineEvent).erase(groupEventName);
-            if (!deassertMessage.empty())
-            {
-                // Fan Failed has two args
-                std::string sendMessage = eventName + " deassert";
-                if (deassertMessage == "OpenBMC.0.1.PowerSupplyFanRecovered")
-                {
-                    sd_journal_send(
-                        "MESSAGE=%s", sendMessage.c_str(), "PRIORITY=%i",
-                        LOG_INFO, "REDFISH_MESSAGE_ID=%s",
-                        deassertMessage.c_str(), "REDFISH_MESSAGE_ARGS=%s,%s",
-                        psuName.c_str(), fanName.c_str(), NULL);
-                }
-                else
-                {
-                    sd_journal_send(
-                        "MESSAGE=%s", sendMessage.c_str(), "PRIORITY=%i",
-                        LOG_INFO, "REDFISH_MESSAGE_ID=%s",
-                        deassertMessage.c_str(), "REDFISH_MESSAGE_ARGS=%s",
-                        psuName.c_str(), NULL);
-                }
-            }
-
-            if ((*combineEvent).empty())
-            {
-                eventInterface->set_property("functional", true);
-            }
+	if(eventName ==  "FanFault" && path.find("fault") != std::string::npos){
+             fst &= ~(1 << 1);
+             StateInterface->set_property("EventData", std::vector<uint8_t>({0xFF, 0xFF, 0xFF}));
+             StateInterface->set_property("ActiveAlarmState", st);
+    	}
+        else if(eventName == "ACLost"){
+             st &= ~(1 << 4);
+             StateInterface->set_property("EventData", std::vector<uint8_t>({0xFF, 0xFF, 0xFF}));
+             StateInterface->set_property("ActiveAlarmState", st);
+        }
+        else if(eventName == "Failure"){
+             st &= ~(1 << 1);
+             StateInterface->set_property("EventData", std::vector<uint8_t>({0xFF, 0xFF, 0xFF}));
+             StateInterface->set_property("ActiveAlarmState", st);
+        }
+        else if(eventName == "PredictiveFailure"){
+             st &= ~(1 << 3);
+             StateInterface->set_property("EventData", std::vector<uint8_t>({0xFF, 0xFF, 0xFF}));
+             StateInterface->set_property("ActiveAlarmState", st);
         }
     }
     else
     {
-        if ((*assertState == false) && ((*asserts).empty()))
-        {
-            *assertState = true;
-            if (!assertMessage.empty())
-            {
-                // For failure and configure error, spec requires a beep
-                if ((assertMessage == "OpenBMC.0.1.PowerSupplyFailed") ||
-                    (assertMessage ==
-                     "OpenBMC.0.1.PowerSupplyConfigurationError"))
-                {
-                    std::cout << " beep for " << assertMessage << "\n";
-                    beep(beepPSUFailure);
-                }
-
-                // Fan Failed has two args
-                std::string sendMessage = eventName + " assert";
-                if (assertMessage == "OpenBMC.0.1.PowerSupplyFanFailed")
-                {
-                    sd_journal_send(
-                        "MESSAGE=%s", sendMessage.c_str(), "PRIORITY=%i",
-                        LOG_WARNING, "REDFISH_MESSAGE_ID=%s",
-                        assertMessage.c_str(), "REDFISH_MESSAGE_ARGS=%s,%s",
-                        psuName.c_str(), fanName.c_str(), NULL);
-                }
-                else
-                {
-                    sd_journal_send(
-                        "MESSAGE=%s", sendMessage.c_str(), "PRIORITY=%i",
-                        LOG_WARNING, "REDFISH_MESSAGE_ID=%s",
-                        assertMessage.c_str(), "REDFISH_MESSAGE_ARGS=%s",
-                        psuName.c_str(), NULL);
-                }
-            }
-            if ((*combineEvent).empty())
-            {
-                eventInterface->set_property("functional", false);
-            }
-            (*combineEvent).emplace(groupEventName);
-        }
-        (*asserts).emplace(path);
+	if((eventName == "FanFault") && path.find("fault") != std::string::npos){
+       	     std::cerr << "eventName:" << eventName << "pathname:" << path << "\n";
+            fst |= 0x02;
+            StateInterface->set_property("EventData", std::vector<uint8_t>({0x01, 0xFF, 0xFF}));
+            StateInterface->set_property("ActiveAlarmState", st);
+            /*genEvent(const std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
+               const std::string &message, const std::string &path,
+               const uint8_t &recType, const uint8_t &evmRev,
+               const uint8_t &senType, const uint8_t &senNum, const uint8_t &eveType,
+               const std::vector<uint8_t> &selData, const bool &assert,
+               const uint16_t &genId)*/
+    	}
+       else if(eventName == "ACLost"){
+            std::cerr << "eventName:" << eventName << "pathname:" << path << "\n";
+            st |= 0x08;
+            StateInterface->set_property("EventData", std::vector<uint8_t>({0x03, 0xFF, 0xFF}));
+            StateInterface->set_property("ActiveAlarmState", st);
+       }
+       else if(eventName == "Failure"){
+            std::cerr << "eventName:" << eventName << "pathname:" << path << "\n";
+            st |=0x02;
+            StateInterface->set_property("EventData", std::vector<uint8_t>({0x01, 0xFF, 0xFF}));
+            StateInterface->set_property("ActiveAlarmState", st);
+       }
+       else if(eventName == "PredictiveFailure"){
+            std::cerr << "eventName:" << eventName << "pathname:" << path << "\n";
+            st |= 0x04;
+            StateInterface->set_property("EventData", std::vector<uint8_t>({0x02, 0xFF, 0xFF}));
+	    StateInterface->set_property("ActiveAlarmState", st);
+       }
     }
     value = newValue;
 }
diff -Naur a/src/PSUEventMain.cpp b/src/PSUEventMain.cpp
--- a/src/PSUEventMain.cpp	1970-01-01 05:30:00.000000000 +0530
+++ b/src/PSUEventMain.cpp	2021-03-25 15:20:25.877914455 +0530
@@ -0,0 +1,384 @@
+/*
+// Copyright (c) 2019 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include <PSUEvent.hpp>
+#include <PSUSensor.hpp>
+#include <Utils.hpp>
+#include <boost/algorithm/string/predicate.hpp>
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/container/flat_set.hpp>
+#include <filesystem>
+#include <fstream>
+#include <iostream>
+#include <regex>
+#include <sdbusplus/asio/connection.hpp>
+#include <sdbusplus/asio/object_server.hpp>
+
+static constexpr std::array<const char*, 1> sensorTypes = {
+    "xyz.openbmc_project.Configuration.pmbus"};
+static constexpr std::array<const char*, 1> discsensorTypes = {
+    "xyz.openbmc_project.Configuration.pmbusdisc"};
+
+static std::vector<std::string> pmbusNames = {"pmbus", "pxe1610", "ina219",
+                                              "ina230"};
+namespace fs = std::filesystem;
+
+static boost::container::flat_map<std::string, std::unique_ptr<PSUCombineEvent>>
+    combineEvents;
+static boost::container::flat_map<std::string, std::unique_ptr<PwmSensor>>
+    pwmSensors;
+static boost::container::flat_map<std::string, std::string> sensorTable;
+static boost::container::flat_map<std::string, std::string> Units;
+static boost::container::flat_map<std::string, PSUProperty> labelMatch;
+static boost::container::flat_map<std::string, std::vector<std::string>>
+    stateeventMatch;
+static boost::container::flat_map<std::string, std::vector<std::string>>
+    faneventMatch;
+
+// Function CheckEvent will check each attribute from eventMatch table in the
+// sysfs. If the attributes exists in sysfs, then store the complete path
+// of the attribute into eventPathList.
+void checkEvent(
+    const std::string& directory,
+    const boost::container::flat_map<std::string, std::vector<std::string>>&
+        eventMatch,
+    boost::container::flat_map<std::string, std::vector<std::string>>&
+        eventPathList)
+{
+    for (const auto& match : eventMatch)
+    {
+        const std::vector<std::string>& eventAttrs = match.second;
+        const std::string& eventName = match.first;
+        for (const auto& eventAttr : eventAttrs)
+        {
+            auto eventPath = directory + "/" + eventAttr;
+
+            std::ifstream eventFile(eventPath);
+            if (!eventFile.good())
+            {
+                continue;
+            }
+
+            eventPathList[eventName].push_back(eventPath);
+        }
+    }
+}
+
+void ReplaceStringInPlace(std::string& subject, const std::string& search,
+                          const std::string& replace) {
+    size_t pos = 0;
+    while ((pos = subject.find(search, pos)) != std::string::npos) {
+         subject.replace(pos, search.length(), replace);
+         pos += replace.length();
+    }
+}
+
+void createSensors(boost::asio::io_service& io,
+                   sdbusplus::asio::object_server& objectServer,
+                   std::shared_ptr<sdbusplus::asio::connection>& dbusConnection)
+{
+    std::cout << "calling createDiscSensors" << "\n";
+
+    ManagedObjectType sensorConfigs;
+    bool useCache = false;
+
+    // TODO may need only modify the ones that need to be changed.
+    //sensors.clear();
+    for (const char* type : discsensorTypes)
+    {
+       std::cout << "createDiscSensors: discsensorTypes for " << "\n";
+        if (!getSensorConfiguration(type, dbusConnection, sensorConfigs,
+                                    useCache))
+        {
+            std::cerr << "error get psudiscsensor config from entity manager\n";
+            return;
+        }
+        useCache = true;
+    }
+
+    std::vector<fs::path> pmbusPaths;
+    if (!findFiles(fs::path("/sys/class/hwmon"), "name", pmbusPaths))
+    {
+        std::cerr << "No PSU sensors in system\n";
+        return;
+    }
+
+    boost::container::flat_set<std::string> directories;
+    for (const auto& pmbusPath : pmbusPaths)
+    {
+       std::cout << "createDiscSensors: pmbusPaths for " << "\n";
+        boost::container::flat_map<std::string, std::vector<std::string>>
+            eventPathList;
+
+        std::ifstream nameFile(pmbusPath);
+        if (!nameFile.good())
+        {
+            std::cerr << "Failure reading " << pmbusPath << "\n";
+            continue;
+        }
+
+        std::string pmbusName;
+        std::getline(nameFile, pmbusName);
+        nameFile.close();
+
+        if (std::find(pmbusNames.begin(), pmbusNames.end(), pmbusName) ==
+            pmbusNames.end())
+        {
+            continue;
+        }
+
+        std::string psuName;
+       const std::string* subName;
+        auto directory = pmbusPath.parent_path();
+
+        auto ret = directories.insert(directory.string());
+        if (!ret.second)
+        {
+            continue; // check if path has already been searched
+        }
+
+        fs::path device = directory / "device";
+        std::string deviceName = fs::canonical(device).stem();
+        auto findHyphen = deviceName.find("-");
+        if (findHyphen == std::string::npos)
+        {
+            std::cerr << "found bad device" << deviceName << "\n";
+            continue;
+        }
+        std::string busStr = deviceName.substr(0, findHyphen);
+        std::string addrStr = deviceName.substr(findHyphen + 1);
+
+        size_t bus = 0;
+        size_t addr = 0;
+
+        try
+        {
+            bus = std::stoi(busStr);
+            addr = std::stoi(addrStr, 0, 16);
+        }
+        catch (std::invalid_argument&)
+        {
+            continue;
+        }
+
+        const std::pair<std::string, boost::container::flat_map<
+                                         std::string, BasicVariantType>>*
+            baseConfig = nullptr;
+        const SensorData* sensorData = nullptr;
+        const std::string* interfacePath = nullptr;
+        const char* sensorType = nullptr;
+
+        for (const std::pair<sdbusplus::message::object_path, SensorData>&
+                 sensor : sensorConfigs)
+        {
+           std::cout << "createDiscSensors: sensorConfigs for " << "\n";
+            sensorData = &(sensor.second);
+            for (const char* type : discsensorTypes)
+            {
+               std::cout << "createDiscSensors: discsensorTypes for inside pmbusPaths for " << "\n";
+                auto sensorBase = sensorData->find(type);
+                if (sensorBase != sensorData->end())
+                {
+                    baseConfig = &(*sensorBase);
+                    sensorType = type;
+                    break;
+                }
+            }
+            if (baseConfig == nullptr)
+            {
+                std::cerr << "error finding base configuration for discsensor"
+                          << "\n";
+                continue;
+            }
+
+                        auto configBus = baseConfig->second.find("Bus");
+            auto configAddress = baseConfig->second.find("Address");
+
+            if (configBus == baseConfig->second.end() ||
+                configAddress == baseConfig->second.end())
+            {
+                std::cerr << "error finding necessary entry in configuration\n";
+                continue;
+            }
+
+            const uint64_t* confBus;
+            const uint64_t* confAddr;
+            if (!(confBus = std::get_if<uint64_t>(&(configBus->second))) ||
+                !(confAddr = std::get_if<uint64_t>(&(configAddress->second))))
+            {
+                std::cerr
+                    << "Canot get bus or address, invalid configuration\n";
+                continue;
+            }
+
+            if ((*confBus != bus) || (*confAddr != addr))
+            {
+                continue;
+            }
+
+            interfacePath = &(sensor.first.str);
+            //break;
+        //}
+        if (interfacePath == nullptr)
+        {
+            std::cerr << "failed to find match for " << "\n";
+            continue;
+        }
+
+        auto findPSUName = baseConfig->second.find("Name");
+        if (findPSUName == baseConfig->second.end())
+        {
+            std::cerr << "could not determine configuration name for "
+                      << "\n";
+            continue;
+        }
+       psuName = std::get<std::string>(findPSUName->second);
+
+       //ReplaceStringInPlace(*n, " ", "_");
+       boost::replace_all(psuName, " ", "_");
+
+       auto findsubName = baseConfig->second.find("subName");
+        if (findsubName == baseConfig->second.end())
+        {
+            std::cerr << "could not determine configuration subname for "
+                      << "\n";
+            continue;
+        }
+
+       if(!(subName = std::get_if<std::string>(&(findsubName->second)))){
+           std::cerr << "could not determine configuration subname for "
+                      << "\n";
+            continue;
+
+       }
+
+       auto findEvStat = baseConfig->second.find("EvStat");
+        if (findEvStat == baseConfig->second.end())
+        {
+            std::cerr << "Base configuration missing EvStat"
+                      << baseConfig->first << "\n";
+            continue;
+        }
+
+        uint16_t EvStat =
+            std::visit(VariantToUnsignedIntVisitor(), findEvStat->second);
+
+        auto findSensorUnit = baseConfig->second.find("Unit");
+        if (findSensorUnit == baseConfig->second.end())
+        {
+            std::cerr << "could not determine Unit for "
+                      << "\n";
+            continue;
+        }
+        std::string sensorUnit = std::get<std::string>(findSensorUnit->second);
+
+        //Digital Event Offset
+        auto findSensorEventOffset = baseConfig->second.find("EventOffset");
+        if (findSensorEventOffset == baseConfig->second.end())
+        {
+            std::cerr << "could not determine configuration EventType for "
+                      << "\n";
+            continue;
+        }
+        uint8_t sensorEventOffset = std::visit(VariantToUnsignedIntVisitor(), findSensorEventOffset->second);
+
+       //Digital Event Offset
+        auto findSensorSubType = baseConfig->second.find("SubType");
+        if (findSensorSubType == baseConfig->second.end())
+        {
+            std::cerr << "could not determine configuration SubType for "
+                      << "\n";
+            continue;
+        }
+        uint8_t sensorSubType = std::visit(VariantToUnsignedIntVisitor(), findSensorSubType->second);
+       if(sensorSubType == 0x00){
+            checkEvent(directory.string(), stateeventMatch, eventPathList);
+       }else if(sensorSubType == 0x01){
+           checkEvent(directory.string(), faneventMatch, eventPathList);
+       }
+
+       struct sdr::SdrRecord sdrRecord;
+        if( !parseSdrRecordFromConfig(*sensorData ,sdrRecord))
+        {
+            std::cerr << "error getting sdr record" << std::endl;
+        }
+     /*   uint8_t sensorEventType = sdrRecord.EventType;
+        // OperationalStatus event
+        combineEvents[psuName] =
+            std::make_unique<PSUCombineEvent>(
+                objectServer, io, psuName, eventPathList, sensorDType, sensorEventType,
+               EvStat,"OperationalStatus",sdrRecord);*/
+       }
+    }
+    return;
+}
+
+void propertyInitialize(void)
+{
+    stateeventMatch = {
+        {"PredictiveFailure", {"power1_alarm"}},
+        {"Failure", {"in2_alarm"}},
+        {"ACLost", {"in1_alarm", "in1_lcrit_alarm"}}};
+
+    faneventMatch = {
+       {"FanFault", {"fan1_alarm", "fan2_alarm", "fan1_fault", "fan2_fault"}}};
+}
+
+int main()
+{
+    boost::asio::io_service io;
+    auto systemBus = std::make_shared<sdbusplus::asio::connection>(io);
+
+    systemBus->request_name("xyz.openbmc_project.PSUEvent");
+    sdbusplus::asio::object_server objectServer(systemBus);
+    std::vector<std::unique_ptr<sdbusplus::bus::match::match>> matches;
+
+    propertyInitialize();
+
+    io.post([&]() { createSensors(io, objectServer, systemBus); });
+    boost::asio::deadline_timer filterTimer(io);
+    std::function<void(sdbusplus::message::message&)> eventHandler =
+        [&](sdbusplus::message::message& message) {
+            if (message.is_method_error())
+            {
+                std::cerr << "callback method error\n";
+                return;
+            }
+            filterTimer.expires_from_now(boost::posix_time::seconds(1));
+            filterTimer.async_wait([&](const boost::system::error_code& ec) {
+                if (ec == boost::asio::error::operation_aborted)
+                {
+                    return;
+                }
+                else if (ec)
+                {
+                    std::cerr << "timer error\n";
+                }
+                createSensors(io, objectServer, systemBus);
+            });
+        };
+
+    for (const char* type : sensorTypes)
+    {
+        auto match = std::make_unique<sdbusplus::bus::match::match>(
+            static_cast<sdbusplus::bus::bus&>(*systemBus),
+            "type='signal',member='PropertiesChanged',path_namespace='" +
+                std::string(inventoryPath) + "',arg0namespace='" + type + "'",
+            eventHandler);
+        matches.emplace_back(std::move(match));
+    }
+    io.run();
+}
diff -Naur a/src/PSUSensorMain.cpp b/src/PSUSensorMain.cpp
--- a/src/PSUSensorMain.cpp	2021-03-25 11:40:59.120348923 +0530
+++ b/src/PSUSensorMain.cpp	2021-03-25 15:21:16.670222799 +0530
@@ -823,13 +823,6 @@
                 std::cerr << "Created " << numCreated << " sensors so far\n";
             }
         }
-
-        // OperationalStatus event
-        combineEvents[*psuName + "OperationalStatus"] = nullptr;
-        combineEvents[*psuName + "OperationalStatus"] =
-            std::make_unique<PSUCombineEvent>(
-                objectServer, dbusConnection, io, *psuName, eventPathList,
-                groupEventPathList, "OperationalStatus");
     }
 
     if constexpr (DEBUG)
