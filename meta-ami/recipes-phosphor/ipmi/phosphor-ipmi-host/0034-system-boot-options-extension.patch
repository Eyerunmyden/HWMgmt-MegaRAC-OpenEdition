From 6326dee3205c6e270e605a8ad95f45d6c27486c9 Mon Sep 17 00:00:00 2001
From: Ryon Heichelbech <ryonh@ami.com>
Date: Wed, 17 Feb 2021 13:14:47 -0500
Subject: [PATCH] system boot options extension

---
 Makefile.am                 |    1 +
 chassishandler.cpp          |  865 +---------------------
 chassishandler.hpp          |   14 -
 include/ipmid/api-types.hpp |   15 +
 settings.cpp                |  337 ++++++++-
 settings.hpp                |   59 +-
 systembootoption.cpp        | 1388 +++++++++++++++++++++++++++++++++++
 systembootoption.hpp        |   29 +
 8 files changed, 1791 insertions(+), 917 deletions(-)
 create mode 100644 systembootoption.cpp
 create mode 100644 systembootoption.hpp

diff --git a/Makefile.am b/Makefile.am
index 82fdd5d..650fbcd 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -101,6 +101,7 @@ libipmi20_la_SOURCES = \
 	entity_map_json.cpp \
 	storagehandler.cpp \
 	chassishandler.cpp \
+	systembootoption.cpp \
 	dcmihandler.cpp \
 	ipmisensor.cpp \
 	storageaddsel.cpp \
diff --git a/chassishandler.cpp b/chassishandler.cpp
index a14d968..dc81457 100755
--- a/chassishandler.cpp
+++ b/chassishandler.cpp
@@ -28,8 +28,6 @@
 #include <sstream>
 #include <string>
 #include <xyz/openbmc_project/Common/error.hpp>
-#include <xyz/openbmc_project/Control/Boot/Mode/server.hpp>
-#include <xyz/openbmc_project/Control/Boot/Source/server.hpp>
 #include <xyz/openbmc_project/Control/Power/RestorePolicy/server.hpp>
 #include <xyz/openbmc_project/State/Chassis/server.hpp>
 #include <xyz/openbmc_project/State/Host/server.hpp>
@@ -39,20 +37,10 @@ std::unique_ptr<phosphor::Timer> identifyTimer
     __attribute__((init_priority(101)));
 
 static ChassisIDState chassisIDState = ChassisIDState::reserved;
-static constexpr uint8_t setParmVersion = 0x01;
-static constexpr uint8_t setParmBootFlagsPermanent = 0x40;
-static constexpr uint8_t setParmBootFlagsValidOneTime = 0x80;
-static constexpr uint8_t setParmBootFlagsValidPermanent = 0xC0;
 
 constexpr size_t sizeVersion = 2;
 constexpr size_t DEFAULT_IDENTIFY_TIME_OUT = 15;
 
-// PetiBoot-Specific
-static constexpr uint8_t netConfInitialBytes[] = {0x80, 0x21, 0x70, 0x62,
-                                                  0x21, 0x00, 0x01, 0x06};
-static constexpr uint8_t oemParmStart = 96;
-static constexpr uint8_t oemParmEnd = 127;
-
 static constexpr size_t cookieOffset = 1;
 static constexpr size_t versionOffset = 5;
 static constexpr size_t addrSizeOffset = 8;
@@ -68,16 +56,6 @@ static constexpr size_t chassisIdentifyReqLength = 2;
 static constexpr size_t identifyIntervalPos = 0;
 static constexpr size_t forceIdentifyPos = 1;
 
-namespace ipmi
-{
-constexpr Cc ccParmNotSupported = 0x80;
-
-static inline auto responseParmNotSupported()
-{
-    return response(ccParmNotSupported);
-}
-} // namespace ipmi
-
 void register_netfn_chassis_functions() __attribute__((constructor));
 
 // Host settings in dbus
@@ -129,15 +107,12 @@ namespace fs = std::filesystem;
 
 using namespace phosphor::logging;
 using namespace sdbusplus::xyz::openbmc_project::Common::Error;
-using namespace sdbusplus::xyz::openbmc_project::Control::Boot::server;
 
 namespace chassis
 {
 namespace internal
 {
 
-constexpr auto bootModeIntf = "xyz.openbmc_project.Control.Boot.Mode";
-constexpr auto bootSourceIntf = "xyz.openbmc_project.Control.Boot.Source";
 constexpr auto powerRestoreIntf =
     "xyz.openbmc_project.Control.Power.RestorePolicy";
 sdbusplus::bus::bus dbus(ipmid_get_sd_bus_connection());
@@ -152,8 +127,7 @@ settings::Objects& getObjects()
     if (objectsPtr == nullptr)
     {
         objectsPtr = std::make_unique<settings::Objects>(
-            dbus, std::vector<std::string>{bootModeIntf, bootSourceIntf,
-                                           powerRestoreIntf});
+            dbus, std::vector<std::string>{powerRestoreIntf});
     }
     return *objectsPtr;
 }
@@ -169,398 +143,6 @@ constexpr auto minutesPerCount = 60;
 
 } // namespace poh
 
-int getHostNetworkData(ipmi::message::Payload& payload)
-{
-    ipmi::PropertyMap properties;
-    int rc = 0;
-    uint8_t addrSize = ipmi::network::IPV4_ADDRESS_SIZE_BYTE;
-
-    try
-    {
-        // TODO There may be cases where an interface is implemented by multiple
-        // objects,to handle such cases we are interested on that object
-        //  which are on interested busname.
-        //  Currenlty mapper doesn't give the readable busname(gives busid)
-        //  so we can't match with bus name so giving some object specific info
-        //  as SETTINGS_MATCH.
-        //  Later SETTINGS_MATCH will be replaced with busname.
-
-        sdbusplus::bus::bus bus(ipmid_get_sd_bus_connection());
-
-        auto ipObjectInfo = ipmi::getDbusObject(bus, IP_INTERFACE,
-                                                SETTINGS_ROOT, SETTINGS_MATCH);
-
-        auto macObjectInfo = ipmi::getDbusObject(bus, MAC_INTERFACE,
-                                                 SETTINGS_ROOT, SETTINGS_MATCH);
-
-        properties = ipmi::getAllDbusProperties(
-            bus, ipObjectInfo.second, ipObjectInfo.first, IP_INTERFACE);
-        auto variant = ipmi::getDbusProperty(bus, macObjectInfo.second,
-                                             macObjectInfo.first, MAC_INTERFACE,
-                                             "MACAddress");
-
-        auto ipAddress = std::get<std::string>(properties["Address"]);
-
-        auto gateway = std::get<std::string>(properties["Gateway"]);
-
-        auto prefix = std::get<uint8_t>(properties["PrefixLength"]);
-
-        uint8_t isStatic =
-            (std::get<std::string>(properties["Origin"]) ==
-             "xyz.openbmc_project.Network.IP.AddressOrigin.Static")
-                ? 1
-                : 0;
-
-        auto MACAddress = std::get<std::string>(variant);
-
-        // it is expected here that we should get the valid data
-        // but we may also get the default values.
-        // Validation of the data is done by settings.
-        //
-        // if mac address is default mac address then
-        // don't send blank override.
-        if ((MACAddress == ipmi::network::DEFAULT_MAC_ADDRESS))
-        {
-            rc = -1;
-            return rc;
-        }
-        // if addr is static then ipaddress,gateway,prefix
-        // should not be default one,don't send blank override.
-        if (isStatic)
-        {
-            if ((ipAddress == ipmi::network::DEFAULT_ADDRESS) ||
-                (gateway == ipmi::network::DEFAULT_ADDRESS) || (!prefix))
-            {
-                rc = -1;
-                return rc;
-            }
-        }
-
-        std::string token;
-        std::stringstream ss(MACAddress);
-
-        // First pack macOffset no of bytes in payload.
-        // Latter this PetiBoot-Specific data will be populated.
-        std::vector<uint8_t> payloadInitialBytes(macOffset);
-        payload.pack(payloadInitialBytes);
-
-        while (std::getline(ss, token, ':'))
-        {
-            payload.pack(stoi(token, nullptr, 16));
-        }
-
-        payload.pack(0x00);
-
-        payload.pack(isStatic);
-
-        uint8_t addressFamily = (std::get<std::string>(properties["Type"]) ==
-                                 "xyz.openbmc_project.Network.IP.Protocol.IPv4")
-                                    ? AF_INET
-                                    : AF_INET6;
-
-        addrSize = (addressFamily == AF_INET)
-                       ? ipmi::network::IPV4_ADDRESS_SIZE_BYTE
-                       : ipmi::network::IPV6_ADDRESS_SIZE_BYTE;
-
-        // ipaddress and gateway would be in IPv4 format
-        std::vector<uint8_t> addrInBinary(addrSize);
-        inet_pton(addressFamily, ipAddress.c_str(),
-                  reinterpret_cast<void*>(addrInBinary.data()));
-
-        payload.pack(addrInBinary);
-
-        payload.pack(prefix);
-
-        std::vector<uint8_t> gatewayDetails(addrSize);
-        inet_pton(addressFamily, gateway.c_str(),
-                  reinterpret_cast<void*>(gatewayDetails.data()));
-        payload.pack(gatewayDetails);
-    }
-    catch (InternalFailure& e)
-    {
-        commit<InternalFailure>();
-        rc = -1;
-        return rc;
-    }
-
-    // PetiBoot-Specific
-    // If success then copy the first 9 bytes to the payload message
-    // payload first 2 bytes contain the parameter values. Skip that 2 bytes.
-    uint8_t skipFirstTwoBytes = 2;
-    size_t payloadSize = payload.size();
-    uint8_t* configDataStartingAddress = payload.data() + skipFirstTwoBytes;
-
-    if (payloadSize < skipFirstTwoBytes + sizeof(netConfInitialBytes))
-    {
-        log<level::ERR>("Invalid net config ");
-        rc = -1;
-        return rc;
-    }
-    std::copy(netConfInitialBytes,
-              netConfInitialBytes + sizeof(netConfInitialBytes),
-              configDataStartingAddress);
-
-    if (payloadSize < skipFirstTwoBytes + addrSizeOffset + sizeof(addrSize))
-    {
-        log<level::ERR>("Invalid length of address size");
-        rc = -1;
-        return rc;
-    }
-    std::copy(&addrSize, &(addrSize) + sizeof(addrSize),
-              configDataStartingAddress + addrSizeOffset);
-
-#ifdef _IPMI_DEBUG_
-    std::printf("\n===Printing the IPMI Formatted Data========\n");
-
-    for (uint8_t pos = 0; pos < index; pos++)
-    {
-        std::printf("%02x ", payloadStartingAddress[pos]);
-    }
-#endif
-
-    return rc;
-}
-
-/** @brief convert IPv4 and IPv6 addresses from binary to text form.
- *  @param[in] family - IPv4/Ipv6
- *  @param[in] data - req data pointer.
- *  @param[in] offset - offset in the data.
- *  @param[in] addrSize - size of the data which needs to be read from offset.
- *  @returns address in text form.
- */
-
-std::string getAddrStr(uint8_t family, uint8_t* data, uint8_t offset,
-                       uint8_t addrSize)
-{
-    char ipAddr[INET6_ADDRSTRLEN] = {};
-
-    switch (family)
-    {
-        case AF_INET:
-        {
-            struct sockaddr_in addr4
-            {
-            };
-            std::memcpy(&addr4.sin_addr.s_addr, &data[offset], addrSize);
-
-            inet_ntop(AF_INET, &addr4.sin_addr, ipAddr, INET_ADDRSTRLEN);
-
-            break;
-        }
-        case AF_INET6:
-        {
-            struct sockaddr_in6 addr6
-            {
-            };
-            std::memcpy(&addr6.sin6_addr.s6_addr, &data[offset], addrSize);
-
-            inet_ntop(AF_INET6, &addr6.sin6_addr, ipAddr, INET6_ADDRSTRLEN);
-
-            break;
-        }
-        default:
-        {
-            return {};
-        }
-    }
-
-    return ipAddr;
-}
-
-ipmi::Cc setHostNetworkData(ipmi::message::Payload& data)
-{
-    using namespace std::string_literals;
-    std::string hostNetworkConfig;
-    std::string mac("00:00:00:00:00:00");
-    std::string ipAddress, gateway;
-    std::string addrOrigin{0};
-    uint8_t addrSize{0};
-    std::string addressOrigin =
-        "xyz.openbmc_project.Network.IP.AddressOrigin.DHCP";
-    std::string addressType = "xyz.openbmc_project.Network.IP.Protocol.IPv4";
-    uint8_t prefix{0};
-    uint8_t family = AF_INET;
-
-    // cookie starts from second byte
-    // version starts from sixth byte
-
-    try
-    {
-        do
-        {
-            // cookie ==  0x21 0x70 0x62 0x21
-            data.trailingOk = true;
-            auto msgLen = data.size();
-            std::vector<uint8_t> msgPayloadBytes(msgLen);
-            if (data.unpack(msgPayloadBytes) != 0 || !data.fullyUnpacked())
-            {
-                log<level::ERR>(
-                    "Error in unpacking message of setHostNetworkData");
-                return ipmi::ccReqDataLenInvalid;
-            }
-
-            uint8_t* msgPayloadStartingPos = msgPayloadBytes.data();
-            constexpr size_t cookieSize = 4;
-            if (msgLen < cookieOffset + cookieSize)
-            {
-                log<level::ERR>(
-                    "Error in cookie getting of setHostNetworkData");
-                return ipmi::ccReqDataLenInvalid;
-            }
-            if (std::equal(msgPayloadStartingPos + cookieOffset,
-                           msgPayloadStartingPos + cookieOffset + cookieSize,
-                           (netConfInitialBytes + cookieOffset)) != 0)
-            {
-                // all cookie == 0
-                if (std::all_of(msgPayloadStartingPos + cookieOffset,
-                                msgPayloadStartingPos + cookieOffset +
-                                    cookieSize,
-                                [](int i) { return i == 0; }) == true)
-                {
-                    // need to zero out the network settings.
-                    break;
-                }
-
-                log<level::ERR>("Invalid Cookie");
-                elog<InternalFailure>();
-            }
-
-            // vesion == 0x00 0x01
-            if (msgLen < versionOffset + sizeVersion)
-            {
-                log<level::ERR>(
-                    "Error in version getting of setHostNetworkData");
-                return ipmi::ccReqDataLenInvalid;
-            }
-            if (std::equal(msgPayloadStartingPos + versionOffset,
-                           msgPayloadStartingPos + versionOffset + sizeVersion,
-                           (netConfInitialBytes + versionOffset)) != 0)
-            {
-                log<level::ERR>("Invalid Version");
-                elog<InternalFailure>();
-            }
-
-            if (msgLen < macOffset + 6)
-            {
-                log<level::ERR>(
-                    "Error in mac address getting of setHostNetworkData");
-                return ipmi::ccReqDataLenInvalid;
-            }
-            std::stringstream result;
-            std::copy((msgPayloadStartingPos + macOffset),
-                      (msgPayloadStartingPos + macOffset + 5),
-                      std::ostream_iterator<int>(result, ":"));
-            mac = result.str();
-
-            if (msgLen < addrTypeOffset + sizeof(decltype(addrOrigin)))
-            {
-                log<level::ERR>(
-                    "Error in original address getting of setHostNetworkData");
-                return ipmi::ccReqDataLenInvalid;
-            }
-            std::copy(msgPayloadStartingPos + addrTypeOffset,
-                      msgPayloadStartingPos + addrTypeOffset +
-                          sizeof(decltype(addrOrigin)),
-                      std::ostream_iterator<int>(result, ""));
-            addrOrigin = result.str();
-
-            if (!addrOrigin.empty())
-            {
-                addressOrigin =
-                    "xyz.openbmc_project.Network.IP.AddressOrigin.Static";
-            }
-
-            if (msgLen < addrSizeOffset + sizeof(decltype(addrSize)))
-            {
-                log<level::ERR>(
-                    "Error in address size getting of setHostNetworkData");
-                return ipmi::ccReqDataLenInvalid;
-            }
-            // Get the address size
-            std::copy(msgPayloadStartingPos + addrSizeOffset,
-                      (msgPayloadStartingPos + addrSizeOffset +
-                       sizeof(decltype(addrSize))),
-                      &addrSize);
-
-            uint8_t prefixOffset = ipAddrOffset + addrSize;
-            if (msgLen < prefixOffset + sizeof(decltype(prefix)))
-            {
-                log<level::ERR>(
-                    "Error in prefix getting of setHostNetworkData");
-                return ipmi::ccReqDataLenInvalid;
-            }
-            std::copy(msgPayloadStartingPos + prefixOffset,
-                      (msgPayloadStartingPos + prefixOffset +
-                       sizeof(decltype(prefix))),
-                      &prefix);
-
-            uint8_t gatewayOffset = prefixOffset + sizeof(decltype(prefix));
-            if (addrSize != ipmi::network::IPV4_ADDRESS_SIZE_BYTE)
-            {
-                addressType = "xyz.openbmc_project.Network.IP.Protocol.IPv6";
-                family = AF_INET6;
-            }
-
-            if (msgLen < ipAddrOffset + addrSize)
-            {
-                log<level::ERR>(
-                    "Error in IP address getting of setHostNetworkData");
-                return ipmi::ccReqDataLenInvalid;
-            }
-            ipAddress = getAddrStr(family, msgPayloadStartingPos, ipAddrOffset,
-                                   addrSize);
-
-            if (msgLen < gatewayOffset + addrSize)
-            {
-                log<level::ERR>(
-                    "Error in gateway address getting of setHostNetworkData");
-                return ipmi::ccReqDataLenInvalid;
-            }
-            gateway = getAddrStr(family, msgPayloadStartingPos, gatewayOffset,
-                                 addrSize);
-
-        } while (0);
-
-        // Cookie == 0 or it is a valid cookie
-        hostNetworkConfig += "ipaddress="s + ipAddress + ",prefix="s +
-                             std::to_string(prefix) + ",gateway="s + gateway +
-                             ",mac="s + mac + ",addressOrigin="s +
-                             addressOrigin;
-
-        sdbusplus::bus::bus bus(ipmid_get_sd_bus_connection());
-
-        auto ipObjectInfo = ipmi::getDbusObject(bus, IP_INTERFACE,
-                                                SETTINGS_ROOT, SETTINGS_MATCH);
-        auto macObjectInfo = ipmi::getDbusObject(bus, MAC_INTERFACE,
-                                                 SETTINGS_ROOT, SETTINGS_MATCH);
-        // set the dbus property
-        ipmi::setDbusProperty(bus, ipObjectInfo.second, ipObjectInfo.first,
-                              IP_INTERFACE, "Address", std::string(ipAddress));
-        ipmi::setDbusProperty(bus, ipObjectInfo.second, ipObjectInfo.first,
-                              IP_INTERFACE, "PrefixLength", prefix);
-        ipmi::setDbusProperty(bus, ipObjectInfo.second, ipObjectInfo.first,
-                              IP_INTERFACE, "Origin", addressOrigin);
-        ipmi::setDbusProperty(bus, ipObjectInfo.second, ipObjectInfo.first,
-                              IP_INTERFACE, "Gateway", std::string(gateway));
-        ipmi::setDbusProperty(
-            bus, ipObjectInfo.second, ipObjectInfo.first, IP_INTERFACE, "Type",
-            std::string("xyz.openbmc_project.Network.IP.Protocol.IPv4"));
-        ipmi::setDbusProperty(bus, macObjectInfo.second, macObjectInfo.first,
-                              MAC_INTERFACE, "MACAddress", std::string(mac));
-
-        log<level::DEBUG>("Network configuration changed",
-                          entry("NETWORKCONFIG=%s", hostNetworkConfig.c_str()));
-    }
-    catch (sdbusplus::exception_t& e)
-    {
-        commit<InternalFailure>();
-        log<level::ERR>("Error in  ipmiChassisSetSysBootOptions call");
-        return ipmi::ccUnspecifiedError;
-    }
-
-    return ipmi::ccSuccess;
-}
-
 uint32_t getPOHCounter()
 {
     sdbusplus::bus::bus bus{ipmid_get_sd_bus_connection()};
@@ -1655,439 +1237,6 @@ ipmi::RspType<> ipmiChassisIdentify(std::optional<uint8_t> interval,
     return ipmi::responseSuccess();
 }
 
-namespace boot_options
-{
-
-using namespace sdbusplus::xyz::openbmc_project::Control::Boot::server;
-using IpmiValue = uint8_t;
-constexpr auto ipmiDefault = 0;
-
-std::map<IpmiValue, Source::Sources> sourceIpmiToDbus = {
-    {0x01, Source::Sources::Network},
-    {0x02, Source::Sources::Disk},
-    {0x05, Source::Sources::ExternalMedia},
-    {0x0f, Source::Sources::RemovableMedia},
-    {ipmiDefault, Source::Sources::Default}};
-
-std::map<IpmiValue, Mode::Modes> modeIpmiToDbus = {
-#ifdef ENABLE_BOOT_FLAG_SAFE_MODE_SUPPORT
-    {0x03, Mode::Modes::Safe},
-#endif // ENABLE_BOOT_SAFE_MODE_SUPPORT
-    {0x06, Mode::Modes::Setup},
-    {ipmiDefault, Mode::Modes::Regular}};
-
-std::map<Source::Sources, IpmiValue> sourceDbusToIpmi = {
-    {Source::Sources::Network, 0x01},
-    {Source::Sources::Disk, 0x02},
-    {Source::Sources::ExternalMedia, 0x05},
-    {Source::Sources::RemovableMedia, 0x0f},
-    {Source::Sources::Default, ipmiDefault}};
-
-std::map<Mode::Modes, IpmiValue> modeDbusToIpmi = {
-#ifdef ENABLE_BOOT_FLAG_SAFE_MODE_SUPPORT
-    {Mode::Modes::Safe, 0x03},
-#endif // ENABLE_BOOT_SAFE_MODE_SUPPORT
-    {Mode::Modes::Setup, 0x06},
-    {Mode::Modes::Regular, ipmiDefault}};
-
-} // namespace boot_options
-
-/** @brief Set the property value for boot source
- *  @param[in] source - boot source value
- *  @return On failure return IPMI error.
- */
-static ipmi_ret_t setBootSource(const Source::Sources& source)
-{
-    using namespace chassis::internal;
-    using namespace chassis::internal::cache;
-    std::variant<std::string> property = convertForMessage(source);
-    settings::Objects& objects = getObjects();
-    auto bootSetting = settings::boot::setting(objects, bootSourceIntf);
-    const auto& bootSourceSetting = std::get<settings::Path>(bootSetting);
-    auto method = dbus.new_method_call(
-        objects.service(bootSourceSetting, bootSourceIntf).c_str(),
-        bootSourceSetting.c_str(), ipmi::PROP_INTF, "Set");
-    method.append(bootSourceIntf, "BootSource", property);
-    auto reply = dbus.call(method);
-    if (reply.is_method_error())
-    {
-        log<level::ERR>("Error in BootSource Set");
-        report<InternalFailure>();
-        return IPMI_CC_UNSPECIFIED_ERROR;
-    }
-    return IPMI_CC_OK;
-}
-
-/** @brief Set the property value for boot mode
- *  @param[in] mode - boot mode value
- *  @return On failure return IPMI error.
- */
-static ipmi::Cc setBootMode(const Mode::Modes& mode)
-{
-    using namespace chassis::internal;
-    using namespace chassis::internal::cache;
-    std::variant<std::string> property = convertForMessage(mode);
-    settings::Objects& objects = getObjects();
-    auto bootSetting = settings::boot::setting(objects, bootModeIntf);
-    const auto& bootModeSetting = std::get<settings::Path>(bootSetting);
-    auto method = dbus.new_method_call(
-        objects.service(bootModeSetting, bootModeIntf).c_str(),
-        bootModeSetting.c_str(), ipmi::PROP_INTF, "Set");
-    method.append(bootModeIntf, "BootMode", property);
-    auto reply = dbus.call(method);
-    if (reply.is_method_error())
-    {
-        log<level::ERR>("Error in BootMode Set");
-        report<InternalFailure>();
-        return ipmi::ccUnspecifiedError;
-    }
-    return ipmi::ccSuccess;
-}
-
-/** @brief implements the Get Chassis system boot option
- *  @param bootOptionParameter   - boot option parameter selector
- *  @param reserved1    - reserved bit
- *  @param setSelector  - selects a particular block or set of parameters
- *                        under the given parameter selector
- *                        write as 00h if parameter doesn't use a setSelector
- *  @param blockSelector- selects a particular block within a set of
- *                        parameters write as 00h if parameter doesn't use a
- *                        blockSelector
- *
- *  @return IPMI completion code plus response data
- *  @return Payload contains below parameters:
- *   version             - parameter version
- *   bootOptionParameter - boot option parameter selector
- *   parmIndicator - parameter valid/invalid indicator
- *   data          - configuration parameter data
- */
-ipmi::RspType<ipmi::message::Payload>
-    ipmiChassisGetSysBootOptions(uint7_t bootOptionParameter, bool reserved1,
-
-                                 uint8_t setSelector, uint8_t blockSelector)
-{
-    if (reserved1)
-    {
-        return ipmi::responseInvalidFieldRequest();
-    }
-
-    constexpr uint4_t version = 0x01;
-    ipmi::message::Payload response;
-    response.pack(version, uint4_t{});
-    using namespace boot_options;
-
-    IpmiValue bootOption = ipmiDefault;
-
-    /*
-     * Parameter #5 means boot flags. Please refer to 28.13 of ipmi doc.
-     * This is the only parameter used by petitboot.
-     */
-    if (static_cast<uint8_t>(bootOptionParameter) ==
-        static_cast<uint8_t>(BootOptionParameter::bootFlags))
-    {
-        using namespace chassis::internal;
-        using namespace chassis::internal::cache;
-
-        try
-        {
-            settings::Objects& objects = getObjects();
-            auto bootSetting = settings::boot::setting(objects, bootSourceIntf);
-            const auto& bootSourceSetting =
-                std::get<settings::Path>(bootSetting);
-            auto oneTimeEnabled =
-                std::get<settings::boot::OneTimeEnabled>(bootSetting);
-            auto method = dbus.new_method_call(
-                objects.service(bootSourceSetting, bootSourceIntf).c_str(),
-                bootSourceSetting.c_str(), ipmi::PROP_INTF, "Get");
-            method.append(bootSourceIntf, "BootSource");
-            auto reply = dbus.call(method);
-            if (reply.is_method_error())
-            {
-                log<level::ERR>(
-                    "ipmiChassisGetSysBootOptions: Error in BootSource Get");
-                report<InternalFailure>();
-                return ipmi::responseUnspecifiedError();
-            }
-            std::variant<std::string> result;
-            reply.read(result);
-            auto bootSource =
-                Source::convertSourcesFromString(std::get<std::string>(result));
-
-            bootSetting = settings::boot::setting(objects, bootModeIntf);
-            const auto& bootModeSetting = std::get<settings::Path>(bootSetting);
-            method = dbus.new_method_call(
-                objects.service(bootModeSetting, bootModeIntf).c_str(),
-                bootModeSetting.c_str(), ipmi::PROP_INTF, "Get");
-            method.append(bootModeIntf, "BootMode");
-            reply = dbus.call(method);
-            if (reply.is_method_error())
-            {
-                log<level::ERR>(
-                    "ipmiChassisGetSysBootOptions: Error in BootMode Get");
-                report<InternalFailure>();
-                return ipmi::responseUnspecifiedError();
-            }
-            reply.read(result);
-            auto bootMode =
-                Mode::convertModesFromString(std::get<std::string>(result));
-
-            bootOption = sourceDbusToIpmi.at(bootSource);
-            if ((Mode::Modes::Regular == bootMode) &&
-                (Source::Sources::Default == bootSource))
-            {
-                bootOption = ipmiDefault;
-            }
-            else if (Source::Sources::Default == bootSource)
-            {
-                bootOption = modeDbusToIpmi.at(bootMode);
-            }
-
-            uint8_t bootOptionParam = oneTimeEnabled
-                                          ? setParmBootFlagsValidOneTime
-                                          : setParmBootFlagsValidPermanent;
-            response.pack(bootOptionParameter, reserved1, bootOptionParam,
-                          uint2_t{}, uint4_t{bootOption}, uint2_t{}, uint8_t{},
-                          uint8_t{}, uint8_t{});
-            return ipmi::responseSuccess(std::move(response));
-        }
-        catch (InternalFailure& e)
-        {
-            cache::objectsPtr.reset();
-            report<InternalFailure>();
-            return ipmi::responseUnspecifiedError();
-        }
-    }
-    else
-    {
-        if ((bootOptionParameter >= oemParmStart) &&
-            (bootOptionParameter <= oemParmEnd))
-        {
-            if (static_cast<uint8_t>(bootOptionParameter) ==
-                static_cast<uint8_t>(BootOptionParameter::opalNetworkSettings))
-            {
-                response.pack(bootOptionParameter, reserved1);
-                int ret = getHostNetworkData(response);
-                if (ret < 0)
-                {
-                    response.trailingOk = true;
-                    log<level::ERR>(
-                        "getHostNetworkData failed for GetSysBootOptions.");
-                    return ipmi::responseUnspecifiedError();
-                }
-                else
-                {
-                    return ipmi::responseSuccess(std::move(response));
-                }
-            }
-        }
-        else
-        {
-            log<level::ERR>(
-                "ipmiChassisGetSysBootOptions: Unsupported parameter",
-                entry("PARAM=0x%x", static_cast<uint8_t>(bootOptionParameter)));
-            return ipmi::responseUnspecifiedError();
-        }
-    }
-    return ipmi::responseUnspecifiedError();
-}
-
-ipmi::RspType<> ipmiChassisSetSysBootOptions(ipmi::Context::ptr ctx,
-                                             uint7_t parameterSelector,
-                                             bool parameterIsValid,
-                                             ipmi::message::Payload& data)
-{
-    using namespace boot_options;
-    ipmi::Cc rc;
-
-    /*  000101
-     * Parameter #5 means boot flags. Please refer to 28.13 of ipmi doc.
-     * This is the only parameter used by petitboot.
-     */
-
-    if (parameterSelector ==
-        static_cast<uint7_t>(BootOptionParameter::bootFlags))
-    {
-        uint5_t rsvd;
-        bool validFlag;
-        bool permanent;
-        bool biosBootType;
-        bool lockOutResetButton;
-        bool screenBlank;
-        uint4_t bootDeviceSelector;
-        bool lockKeyboard;
-        bool cmosClear;
-        uint8_t data3;
-        uint4_t biosInfo;
-        uint4_t rsvd1;
-        uint5_t deviceInstance;
-        uint3_t rsvd2;
-
-        if (data.unpack(rsvd, biosBootType, permanent, validFlag,
-                        lockOutResetButton, screenBlank, bootDeviceSelector,
-                        lockKeyboard, cmosClear, data3, biosInfo, rsvd1,
-                        deviceInstance, rsvd2) != 0 ||
-            !data.fullyUnpacked())
-        {
-            return ipmi::responseReqDataLenInvalid();
-        }
-        if (rsvd || rsvd1 || rsvd2)
-        {
-            return ipmi::responseInvalidFieldRequest();
-        }
-
-        using namespace chassis::internal;
-        using namespace chassis::internal::cache;
-        auto oneTimeEnabled = false;
-        constexpr auto enabledIntf = "xyz.openbmc_project.Object.Enable";
-        constexpr auto oneTimePath =
-            "/xyz/openbmc_project/control/host0/boot/one_time";
-
-        try
-        {
-            settings::Objects& objects = getObjects();
-
-            auto bootSetting = settings::boot::setting(objects, bootSourceIntf);
-
-            oneTimeEnabled =
-                std::get<settings::boot::OneTimeEnabled>(bootSetting);
-
-            /*
-             * Check if the current boot setting is onetime or permanent, if the
-             * request in the command is otherwise, then set the "Enabled"
-             * property in one_time object path to 'True' to indicate onetime
-             * and 'False' to indicate permanent.
-             *
-             * Once the onetime/permanent setting is applied, then the bootMode
-             * and bootSource is updated for the corresponding object.
-             */
-            if ((permanent && oneTimeEnabled) ||
-                (!permanent && !oneTimeEnabled))
-            {
-                auto service = ipmi::getService(dbus, enabledIntf, oneTimePath);
-
-                ipmi::setDbusProperty(dbus, service, oneTimePath, enabledIntf,
-                                      "Enabled", !permanent);
-            }
-
-            auto modeItr =
-                modeIpmiToDbus.find(static_cast<uint8_t>(bootDeviceSelector));
-            auto sourceItr =
-                sourceIpmiToDbus.find(static_cast<uint8_t>(bootDeviceSelector));
-            if (sourceIpmiToDbus.end() != sourceItr)
-            {
-                rc = setBootSource(sourceItr->second);
-                if (rc != ipmi::ccSuccess)
-                {
-                    log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
-                                    "setting boot source");
-                    return ipmi::responseUnspecifiedError();
-                }
-                // If a set boot device is mapping to a boot source, then reset
-                // the boot mode D-Bus property to default.
-                // This way the ipmid code can determine which property is not
-                // at the default value
-                if (sourceItr->second != Source::Sources::Default)
-                {
-                    setBootMode(Mode::Modes::Regular);
-                }
-            }
-            if (modeIpmiToDbus.end() != modeItr)
-            {
-                rc = setBootMode(modeItr->second);
-                if (rc != ipmi::ccSuccess)
-                {
-                    log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
-                                    "setting boot mode");
-                    return ipmi::responseUnspecifiedError();
-                }
-                // If a set boot device is mapping to a boot mode, then reset
-                // the boot source D-Bus property to default.
-                // This way the ipmid code can determine which property is not
-                // at the default value
-                if (modeItr->second != Mode::Modes::Regular)
-                {
-                    setBootSource(Source::Sources::Default);
-                }
-            }
-            if ((modeIpmiToDbus.end() == modeItr) &&
-                (sourceIpmiToDbus.end() == sourceItr))
-            {
-                // return error if boot option is not supported
-                log<level::ERR>(
-                    "ipmiChassisSetSysBootOptions: Boot option not supported");
-                return ipmi::responseInvalidFieldRequest();
-            }
-        }
-        catch (sdbusplus::exception_t& e)
-        {
-            objectsPtr.reset();
-            report<InternalFailure>();
-            log<level::ERR>(
-                "ipmiChassisSetSysBootOptions: Error in setting Boot "
-                "flag parameters");
-            return ipmi::responseUnspecifiedError();
-        }
-    }
-    else if (parameterSelector ==
-             static_cast<uint7_t>(BootOptionParameter::bootInfo))
-    {
-        uint8_t writeMak;
-        uint5_t bootInitiatorAckData;
-        uint3_t rsvd;
-
-        if (data.unpack(writeMak, bootInitiatorAckData, rsvd) != 0 ||
-            !data.fullyUnpacked())
-        {
-            return ipmi::responseReqDataLenInvalid();
-        }
-        if (rsvd)
-        {
-            return ipmi::responseInvalidFieldRequest();
-        }
-        // (ccSuccess). There is no implementation in OpenBMC for this
-        // parameter. This is added to support the ipmitool command `chassis
-        // bootdev` which sends set on parameter #4, before setting the boot
-        // flags.
-        log<level::INFO>("ipmiChassisSetSysBootOptions: bootInfo parameter set "
-                         "successfully");
-        data.trailingOk = true;
-        return ipmi::responseSuccess();
-    }
-    else
-    {
-        if ((parameterSelector >= static_cast<uint7_t>(oemParmStart)) &&
-            (parameterSelector <= static_cast<uint7_t>(oemParmEnd)))
-        {
-            if (parameterSelector ==
-                static_cast<uint7_t>(BootOptionParameter::opalNetworkSettings))
-            {
-                ipmi::Cc ret = setHostNetworkData(data);
-                if (ret != ipmi::ccSuccess)
-                {
-                    log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
-                                    "setHostNetworkData");
-                    data.trailingOk = true;
-                    return ipmi::response(ret);
-                }
-                data.trailingOk = true;
-                return ipmi::responseSuccess();
-            }
-            else
-            {
-                log<level::ERR>(
-                    "ipmiChassisSetSysBootOptions: Unsupported parameters",
-                    entry("PARAM=0x%x",
-                          static_cast<uint8_t>(parameterSelector)));
-                data.trailingOk = true;
-                return ipmi::responseParmNotSupported();
-            }
-        }
-        data.trailingOk = true;
-        return ipmi::responseParmNotSupported();
-    }
-    return ipmi::responseSuccess();
-}
-
 /** @brief implements Get POH counter command
  *  @parameter
  *   -  none
@@ -2221,12 +1370,6 @@ void register_netfn_chassis_functions()
                           ipmi::chassis::cmdSetChassisCapabilities,
                           ipmi::Privilege::User, ipmiSetChassisCap);
 
-    // <Get System Boot Options>
-    ipmi::registerHandler(ipmi::prioOpenBmcBase, ipmi::netFnChassis,
-                          ipmi::chassis::cmdGetSystemBootOptions,
-                          ipmi::Privilege::Operator,
-                          ipmiChassisGetSysBootOptions);
-
     // <Get Chassis Status>
     ipmi::registerHandler(ipmi::prioOpenBmcBase, ipmi::netFnChassis,
                           ipmi::chassis::cmdGetChassisStatus,
@@ -2247,12 +1390,6 @@ void register_netfn_chassis_functions()
                           ipmi::chassis::cmdChassisIdentify,
                           ipmi::Privilege::Operator, ipmiChassisIdentify);
 
-    // <Set System Boot Options>
-    ipmi::registerHandler(ipmi::prioOpenBmcBase, ipmi::netFnChassis,
-                          ipmi::chassis::cmdSetSystemBootOptions,
-                          ipmi::Privilege::Operator,
-                          ipmiChassisSetSysBootOptions);
-
     // <Get POH Counter>
     ipmi::registerHandler(ipmi::prioOpenBmcBase, ipmi::netFnChassis,
                           ipmi::chassis::cmdGetPohCounter,
diff --git a/chassishandler.hpp b/chassishandler.hpp
index 93de2c0..1ebd1b8 100644
--- a/chassishandler.hpp
+++ b/chassishandler.hpp
@@ -15,8 +15,6 @@ enum ipmi_netfn_chassis_cmds
     IPMI_CMD_CHASSIS_IDENTIFY = 0x04,
     IPMI_CMD_SET_CHASSIS_CAP = 0x05,
     // Get capability bits
-    IPMI_CMD_SET_SYS_BOOT_OPTIONS = 0x08,
-    IPMI_CMD_GET_SYS_BOOT_OPTIONS = 0x09,
     IPMI_CMD_GET_POH_COUNTER = 0x0F,
 };
 
@@ -44,18 +42,6 @@ enum ipmi_chassis_control_cmds : uint8_t
     CMD_PULSE_DIAGNOSTIC_INTR = 0x04,
     CMD_SOFT_OFF_VIA_OVER_TEMP = 0x05,
 };
-enum class BootOptionParameter : size_t
-{
-    bootInfo = 0x4,
-    bootFlags = 0x5,
-    opalNetworkSettings = 0x61
-};
-
-enum class BootOptionResponseSize : size_t
-{
-    bootFlags = 5,
-    opalNetworkSettings = 50
-};
 
 enum class ChassisIDState : uint8_t
 {
diff --git a/include/ipmid/api-types.hpp b/include/ipmid/api-types.hpp
index b4b70e3..d330536 100644
--- a/include/ipmid/api-types.hpp
+++ b/include/ipmid/api-types.hpp
@@ -365,6 +365,9 @@ constexpr Cmd cmdWildcard = 0xFF;
 //
 // Alternately, OEM completion codes are in the 0x01-0x7E range
 constexpr Cc ccSuccess = 0x00;
+constexpr Cc ccParamNotSupported = 0x80;
+constexpr Cc ccSetInProgress = 0x81;
+constexpr Cc ccReadOnlyParameter = 0x82;
 constexpr Cc ccBusy = 0xC0;
 constexpr Cc ccInvalidCommand = 0xC1;
 constexpr Cc ccInvalidCommandOnLun = 0xC2;
@@ -549,5 +552,17 @@ static inline auto responseUnspecifiedError()
 {
     return response(ccUnspecifiedError);
 }
+static inline auto responseParamNotSupported()
+{
+    return response(ccParamNotSupported);
+}
+static inline auto responseSetInProgress()
+{
+    return response(ccSetInProgress);
+}
+static inline auto responseReadOnlyParameter()
+{
+    return response(ccReadOnlyParameter);
+}
 
 } // namespace ipmi
diff --git a/settings.cpp b/settings.cpp
index 2fa2511..b8a3708 100644
--- a/settings.cpp
+++ b/settings.cpp
@@ -1,11 +1,21 @@
 #include "settings.hpp"
 
+#include <ipmid/api.hpp>
+#include <ipmid/types.hpp>
 #include <ipmid/utils.hpp>
 #include <phosphor-logging/elog-errors.hpp>
 #include <phosphor-logging/log.hpp>
 #include <sdbusplus/message/types.hpp>
 #include <xyz/openbmc_project/Common/error.hpp>
 
+#include <xyz/openbmc_project/Control/Boot/Mode/server.hpp>
+#include <xyz/openbmc_project/Control/Boot/Source/server.hpp>
+#include <xyz/openbmc_project/Control/Boot/ConsoleRedirection/server.hpp>
+#include <xyz/openbmc_project/Control/Boot/FirmwareVerbosity/server.hpp>
+#include <xyz/openbmc_project/Control/Boot/MuxOverride/server.hpp>
+#include <xyz/openbmc_project/Control/Boot/SetInProgress/server.hpp>
+#include <xyz/openbmc_project/Control/Boot/BootType/server.hpp>
+
 namespace settings
 {
 
@@ -92,48 +102,321 @@ Service Objects::service(const Path& path, const Interface& interface) const
 namespace boot
 {
 
-std::tuple<Path, OneTimeEnabled> setting(const Objects& objects,
-                                         const Interface& iface)
+constexpr auto enabledIntf = "xyz.openbmc_project.Object.Enable";
+constexpr auto oneTimePath =
+    "/xyz/openbmc_project/control/host0/boot/one_time";
+
+constexpr auto validIntf = "xyz.openbmc_project.Control.Boot.BootOptValid";
+constexpr auto validPath =
+    "/xyz/openbmc_project/control/host0/boot";
+
+DbusBootOptions *DbusBootOptions::instance = nullptr;
+
+DbusBootOptions::DbusBootOptions()
+    : dbus_(ipmid_get_sd_bus_connection())
+    , oneTimeEnable_(1)
+{
+    properties_ = getProperties();
+    flags_ = getFlags();
+
+    // reset (semi-)volatile data
+    using namespace sdbusplus::xyz::openbmc_project::Control::Boot::server;
+    try {
+        this->setBootProperty("SetInProgress", "SetInProgress", convertForMessage(SetInProgress::Statuses::SetComplete));
+        this->setBootProperty("ServicePartitionSelect", "ServicePartition", uint8_t{0});
+        this->setBootProperty("BootFlagValidClearing", "NoClearOnPowerup", false);
+        this->setBootProperty("BootFlagValidClearing", "NoClearOnPushbuttonReset", false);
+        this->setBootProperty("BootFlagValidClearing", "NoClearOnWatchdogReset", false);
+        this->setBootProperty("BootFlagValidClearing", "NoClearOnTimeout", false);
+        this->setBootProperty("BootFlagValidClearing", "NoClearOnPEFReset", false);
+        this->setBootProperty("BootInfoAck", "BIOSAck", false);
+        this->setBootProperty("BootInfoAck", "OSLoaderAck", false);
+        this->setBootProperty("BootInfoAck", "OSAck", false);
+        this->setBootProperty("BootInfoAck", "SMSAck", false);
+        this->setBootProperty("BootInfoAck", "OEMAck", false);
+        this->setOneTime();
+        this->setBootFlag("BootType", "Type", convertForMessage(BootType::Types::Legacy));
+        this->setBootFlag("CMOSClear", "CMOSClear", false);
+        this->setBootFlag("LockKeyboard", "LockKeyboard", false);
+        this->setBootFlag("ScreenBlank", "ScreenBlank", false);
+        this->setBootFlag("ResetLockout", "ResetLockout", false);
+        this->setBootFlag("Source", "BootSource", convertForMessage(Source::Sources::Default));
+        this->setBootFlag("Mode", "BootMode", convertForMessage(Mode::Modes::Regular));
+        this->setBootFlag("ConsoleRedirection", "ConsoleRedirection", convertForMessage(ConsoleRedirection::Redirections::Default));
+        this->setBootFlag("LockSleep", "LockSleep", false);
+        this->setBootFlag("PasswordBypass", "PasswordBypass", false);
+        this->setBootFlag("ForceProgressTraps", "ForceProgressEventTraps", false);
+        this->setBootFlag("FirmwareVerbosity", "FirmwareVerbosity", convertForMessage(FirmwareVerbosity::Levels::Default));
+        this->setBootFlag("LockPower", "LockPower", false);
+        this->setBootFlag("MuxOverride", "MuxOverride", convertForMessage(MuxOverride::Modes::Default));
+        this->setBootFlag("SharedModeOverride", "SharedModeOverride", false);
+        this->setBootFlag("DeviceInstance", "DeviceInstance", uint8_t{0});
+        this->setPermanent();
+        this->setBootFlag("BootType", "Type", convertForMessage(BootType::Types::Legacy));
+        this->setBootFlag("CMOSClear", "CMOSClear", false);
+        this->setBootFlag("LockKeyboard", "LockKeyboard", false);
+        this->setBootFlag("ScreenBlank", "ScreenBlank", false);
+        this->setBootFlag("ResetLockout", "ResetLockout", false);
+        this->setBootFlag("Source", "BootSource", convertForMessage(Source::Sources::Default));
+        this->setBootFlag("Mode", "BootMode", convertForMessage(Mode::Modes::Regular));
+        this->setBootFlag("ConsoleRedirection", "ConsoleRedirection", convertForMessage(ConsoleRedirection::Redirections::Default));
+        this->setBootFlag("LockSleep", "LockSleep", false);
+        this->setBootFlag("PasswordBypass", "PasswordBypass", false);
+        this->setBootFlag("ForceProgressTraps", "ForceProgressEventTraps", false);
+        this->setBootFlag("FirmwareVerbosity", "FirmwareVerbosity", convertForMessage(FirmwareVerbosity::Levels::Default));
+        this->setBootFlag("LockPower", "LockPower", false);
+        this->setBootFlag("MuxOverride", "MuxOverride", convertForMessage(MuxOverride::Modes::Default));
+        this->setBootFlag("SharedModeOverride", "SharedModeOverride", false);
+        this->setBootFlag("DeviceInstance", "DeviceInstance", uint8_t{0});
+        this->setOneTime();
+        this->setBootProperty("BootInitiatorInfo", "Channel", uint8_t{0});
+        this->setBootProperty("BootInitiatorInfo", "SessionID", uint32_t{0});
+        this->setBootProperty("BootInitiatorInfo", "Timestamp", uint32_t{0});
+        this->setBootProperty("BootMailbox", "BlockSelector", uint8_t{0});
+        this->setBootProperty("BootMailbox", "Mailbox0U", uint64_t{0});
+        this->setBootProperty("BootMailbox", "Mailbox0L", uint64_t{0});
+        this->setBootProperty("BootMailbox", "Mailbox1U", uint64_t{0});
+        this->setBootProperty("BootMailbox", "Mailbox1L", uint64_t{0});
+        this->setBootProperty("BootMailbox", "Mailbox2U", uint64_t{0});
+        this->setBootProperty("BootMailbox", "Mailbox2L", uint64_t{0});
+        this->setBootProperty("BootMailbox", "Mailbox3U", uint64_t{0});
+        this->setBootProperty("BootMailbox", "Mailbox3L", uint64_t{0});
+        this->setBootProperty("BootMailbox", "Mailbox4U", uint64_t{0});
+        this->setBootProperty("BootMailbox", "Mailbox4L", uint64_t{0});
+        this->setValidity("BootFlagsValid", false);
+        this->setValidity("BootSetInProgressValid", false);
+        this->setValidity("BootServicePartitionSelectorValid", false);
+        this->setValidity("BootServicePartitionScanValid", false);
+        this->setValidity("BootFlagValidClearingValid", false);
+        this->setValidity("BootInfoAckValid", false);
+        this->setValidity("BootFlagsParamValid", false);
+        this->setValidity("BootInitiatorInfoValid", false);
+        this->setValidity("BootInitiatorMailboxValid", false);
+    } catch (sdbusplus::exception_t& e) {
+        report<InternalFailure>();
+        log<level::ERR>("Failed to reset volatile boot options");
+    }
+}
+
+DbusBootOptions* DbusBootOptions::getInstance()
+{
+    if (!instance)
+        instance = new DbusBootOptions;
+    return instance;
+}
+
+const settings::Path& DbusBootOptions::getPropertyPath(std::string& interfacePath)
+{
+    const std::vector<settings::Path>& paths = properties_->map.at(interfacePath);
+    return paths[0];
+}
+
+ipmi::Cc DbusBootOptions::setBootProperty(const std::string& interface,
+        const std::string& property, const ipmi::Value& value)
+{
+    std::string interfacePath = getInterface(interface);
+    const auto& settingPath = getPropertyPath(interfacePath);
+
+    auto method = dbus_.new_method_call(
+        properties_->service(settingPath, interfacePath).c_str(),
+        settingPath.c_str(), ipmi::PROP_INTF, "Set");
+    method.append(interfacePath, property, value);
+    auto reply = dbus_.call(method);
+    if (reply.is_method_error())
+    {
+        log<level::ERR>("Error setting boot property");
+        report<InternalFailure>();
+        return ipmi::ccUnspecifiedError;
+    }
+    return ipmi::ccSuccess;
+}
+
+const settings::Path& DbusBootOptions::getFlagPath(std::string& interfacePath)
 {
     constexpr auto bootObjCount = 2;
     constexpr auto oneTime = "one_time";
-    constexpr auto enabledIntf = "xyz.openbmc_project.Object.Enable";
 
-    const std::vector<Path>& paths = objects.map.at(iface);
-    auto count = paths.size();
-    if (count != bootObjCount)
-    {
-        log<level::ERR>("Exactly two objects expected",
-                        entry("INTERFACE=%s", iface.c_str()),
-                        entry("COUNT=%d", count));
-        elog<InternalFailure>();
+    const std::vector<settings::Path>& paths = flags_->map.at(interfacePath);
+    size_t count = paths.size();
+    if (count == 0) {
+        return emptyPath;
     }
     size_t index = 0;
     if (std::string::npos == paths[0].rfind(oneTime))
     {
         index = 1;
     }
-    const Path& oneTimeSetting = paths[index];
-    const Path& regularSetting = paths[!index];
+    if (count == 1) {
+        /* Skip settings that are OTE-only when perm flag is set */
+        if (!oneTimeEnable_ && index == 0) {
+            return emptyPath;
+        }
+        return paths[0];
+    }
+    if (count != bootObjCount) {
+        return emptyPath;
+    }
+    const settings::Path& oneTimeSetting = paths[index];
+    const settings::Path& regularSetting = paths[!index];
+
+    if (oneTimeEnable_) {
+        return oneTimeSetting;
+    }
+
+    return regularSetting;
+}
 
-    auto method = objects.bus.new_method_call(
-        objects.service(oneTimeSetting, iface).c_str(), oneTimeSetting.c_str(),
-        ipmi::PROP_INTF, "Get");
-    method.append(enabledIntf, "Enabled");
-    auto reply = objects.bus.call(method);
+/* The flags are special because they have the one-time distinction */
+ipmi::Cc DbusBootOptions::setBootFlag(const std::string& interface,
+        const std::string& property, const ipmi::Value& value)
+{
+    std::string interfacePath = getInterface(interface);
+    auto settingPath = getFlagPath(interfacePath);
+    if (settingPath.empty()) {
+        return ipmi::ccSuccess;
+    }
+    auto method = dbus_.new_method_call(
+        flags_->service(settingPath, interfacePath).c_str(),
+        settingPath.c_str(), ipmi::PROP_INTF, "Set");
+    method.append(interfacePath, property, value);
+    auto reply = dbus_.call(method);
     if (reply.is_method_error())
     {
-        log<level::ERR>("Error in getting Enabled property",
-                        entry("OBJECT=%s", oneTimeSetting.c_str()),
-                        entry("INTERFACE=%s", iface.c_str()));
-        elog<InternalFailure>();
+        log<level::ERR>("Error setting boot property");
+        report<InternalFailure>();
+        return ipmi::ccUnspecifiedError;
     }
+    return ipmi::ccSuccess;
+}
+
+void DbusBootOptions::setPermanent()
+{
+    auto service = ipmi::getService(dbus_, enabledIntf, oneTimePath);
+    ipmi::setDbusProperty(dbus_, service, oneTimePath, enabledIntf,
+                          "Enabled", false);
+    oneTimeEnable_ = false;
+}
+
+void DbusBootOptions::setOneTime()
+{
+    auto service = ipmi::getService(dbus_, enabledIntf, oneTimePath);
+    ipmi::setDbusProperty(dbus_, service, oneTimePath, enabledIntf,
+                          "Enabled", true);
+    oneTimeEnable_ = true;
+}
+
+bool DbusBootOptions::getAndRestoreOneTime()
+{
+    auto service = ipmi::getService(dbus_, enabledIntf, oneTimePath);
+    ipmi::Value oneTime = ipmi::getDbusProperty(dbus_, service,
+            oneTimePath, enabledIntf, "Enabled");
+    oneTimeEnable_ = std::get<bool>(oneTime);
+    return oneTimeEnable_;
+}
+
+void DbusBootOptions::setValidity(std::string property, bool validity)
+{
+    auto service = ipmi::getService(dbus_, validIntf, validPath);
+    ipmi::setDbusProperty(dbus_, service, validPath, validIntf,
+                          property, validity);
+}
+
+bool DbusBootOptions::getValidity(std::string property)
+{
+    auto service = ipmi::getService(dbus_, validIntf, validPath);
+    ipmi::Value valid = ipmi::getDbusProperty(dbus_, service, validPath,
+                                              validIntf, property);
+    return std::get<bool>(valid);
+}
+
+ipmi::Cc DbusBootOptions::getBootProperty(const std::string& interface,
+        const std::string& property, ipmi::Value& value)
+{
+    try {
+        std::string interfacePath = getInterface(interface);
+        const auto& settingPath = getPropertyPath(interfacePath);
+        auto method = dbus_.new_method_call(
+            properties_->service(settingPath, interfacePath).c_str(),
+            settingPath.c_str(), ipmi::PROP_INTF, "Get");
+        method.append(interfacePath, property);
+        auto reply = dbus_.call(method);
+        if (reply.is_method_error())
+        {
+            log<level::ERR>("Error getting boot property");
+            report<InternalFailure>();
+            return ipmi::ccUnspecifiedError;
+        }
+        reply.read(value);
+        return ipmi::ccSuccess;
+    } catch (std::exception& e) {
+        log<level::ERR>(e.what());
+        return ipmi::ccUnspecifiedError;
+    }
+}
 
-    std::variant<bool> enabled;
-    reply.read(enabled);
-    auto oneTimeEnabled = std::get<bool>(enabled);
-    const Path& setting = oneTimeEnabled ? oneTimeSetting : regularSetting;
-    return std::make_tuple(setting, oneTimeEnabled);
+ipmi::Cc DbusBootOptions::getBootFlag(const std::string& interface,
+        const std::string& property, ipmi::Value& value)
+{
+    try {
+        std::string interfacePath = getInterface(interface);
+        const auto& settingPath = getFlagPath(interfacePath);
+
+        if (settingPath.empty()) {
+            // Caller must fall back to ipmiDefault
+            return ipmi::ccInvalidFieldRequest;
+        }
+        auto method = dbus_.new_method_call(
+            flags_->service(settingPath, interfacePath).c_str(),
+            settingPath.c_str(), ipmi::PROP_INTF, "Get");
+        method.append(interfacePath, property);
+        auto reply = dbus_.call(method);
+        if (reply.is_method_error())
+        {
+            log<level::ERR>("Error getting boot property");
+            report<InternalFailure>();
+            return ipmi::ccUnspecifiedError;
+        }
+        reply.read(value);
+        return ipmi::ccSuccess;
+    } catch (std::exception& e) {
+        log<level::ERR>(e.what());
+        return ipmi::ccUnspecifiedError;
+    }
+}
+
+std::unique_ptr<settings::Objects> DbusBootOptions::getProperties()
+{
+    return std::make_unique<settings::Objects>(
+            dbus_, std::vector<std::string>{
+            getInterface("BootFlagValidClearing"),
+            getInterface("ServicePartitionScan"),
+            getInterface("ServicePartitionSelect"),
+            getInterface("BootInfoAck"),
+            getInterface("BootInitiatorInfo"),
+            getInterface("BootMailbox"),
+            getInterface("SetInProgress")});
+}
+
+std::unique_ptr<settings::Objects> DbusBootOptions::getFlags()
+{
+    return std::make_unique<settings::Objects>(
+            dbus_, std::vector<std::string>{
+            getInterface("BootType"),
+            getInterface("CMOSClear"),
+            getInterface("ConsoleRedirection"),
+            getInterface("DeviceInstance"),
+            getInterface("FirmwareVerbosity"),
+            getInterface("ForceProgressTraps"),
+            getInterface("LockKeyboard"),
+            getInterface("LockPower"),
+            getInterface("LockSleep"),
+            getInterface("MuxOverride"),
+            getInterface("PasswordBypass"),
+            getInterface("ResetLockout"),
+            getInterface("ScreenBlank"),
+            getInterface("SharedModeOverride"),
+            getInterface("BootMode"),
+            getInterface("BootSource")});
 }
 
 } // namespace boot
diff --git a/settings.hpp b/settings.hpp
index 5382fdd..8670425 100644
--- a/settings.hpp
+++ b/settings.hpp
@@ -1,5 +1,7 @@
 #pragma once
 
+#include <ipmid/api-types.hpp>
+#include <ipmid/types.hpp>
 #include <sdbusplus/bus.hpp>
 #include <string>
 #include <tuple>
@@ -53,19 +55,52 @@ struct Objects
 namespace boot
 {
 
-using OneTimeEnabled = bool;
+class DbusBootOptions {
+public:
+    static DbusBootOptions* getInstance();
 
-/** @brief Return the one-time boot setting object path if enabled, otherwise
- *         the regular boot setting object path.
- *
- * @param[in] objects - const reference to an object of type Objects
- * @param[in] iface - boot setting interface
- *
- * @return A tuple - boot setting object path, a bool indicating whether the
- *                   returned path corresponds to the one time boot setting.
- */
-std::tuple<Path, OneTimeEnabled> setting(const Objects& objects,
-                                         const Interface& iface);
+    const settings::Path& getPropertyPath(std::string& interfacePath);
+
+    ipmi::Cc setBootProperty(const std::string& interface,
+            const std::string& property, const ipmi::Value& value);
+
+    const settings::Path& getFlagPath(std::string& interfacePath);
+
+    ipmi::Cc setBootFlag(const std::string& interface,
+            const std::string& property, const ipmi::Value& value);
+
+    void setPermanent();
+    void setOneTime();
+    bool getAndRestoreOneTime();
+
+    void setValidity(std::string proprty, bool validity);
+    bool getValidity(std::string property);
+
+    ipmi::Cc getBootProperty(const std::string& interface,
+            const std::string& property, ipmi::Value& value);
+
+    ipmi::Cc getBootFlag(const std::string& interface,
+            const std::string& property, ipmi::Value& value);
+
+private:
+    static DbusBootOptions *instance;
+    DbusBootOptions();
+
+    std::unique_ptr<settings::Objects> properties_;
+    std::unique_ptr<settings::Objects> flags_;
+    sdbusplus::bus::bus dbus_;
+    bool oneTimeEnable_;
+    const settings::Path emptyPath = settings::Path("");
+
+    std::unique_ptr<settings::Objects> getProperties();
+    std::unique_ptr<settings::Objects> getFlags();
+
+    static std::string getInterface(const std::string& s)
+    {
+        std::string r = "xyz.openbmc_project.Control.Boot." + s;
+        return r;
+    }
+};
 
 } // namespace boot
 
diff --git a/systembootoption.cpp b/systembootoption.cpp
new file mode 100644
index 0000000..765b105
--- /dev/null
+++ b/systembootoption.cpp
@@ -0,0 +1,1388 @@
+#include "config.h"
+
+#include "systembootoption.hpp"
+
+#include <ipmid/api.hpp>
+#include <ipmid/message.hpp>
+#include <ipmid/message/types.hpp>
+#include <ipmid/types.hpp>
+#include <ipmid/utils.hpp>
+#include <phosphor-logging/elog-errors.hpp>
+#include <phosphor-logging/log.hpp>
+#include <settings.hpp>
+#include <sdbusplus/bus.hpp>
+#include <sdbusplus/message/types.hpp>
+#include <xyz/openbmc_project/Common/error.hpp>
+#include <memory>
+
+#include <xyz/openbmc_project/Control/Boot/Mode/server.hpp>
+#include <xyz/openbmc_project/Control/Boot/Source/server.hpp>
+#include <xyz/openbmc_project/Control/Boot/ConsoleRedirection/server.hpp>
+#include <xyz/openbmc_project/Control/Boot/FirmwareVerbosity/server.hpp>
+#include <xyz/openbmc_project/Control/Boot/MuxOverride/server.hpp>
+#include <xyz/openbmc_project/Control/Boot/SetInProgress/server.hpp>
+#include <xyz/openbmc_project/Control/Boot/BootType/server.hpp>
+
+static constexpr uint8_t setParmBootPermanent = 0x40;
+static constexpr uint8_t setParmBootValidOneTime = 0x80;
+static constexpr uint8_t setParmBootValidPermanent = 0xC0;
+
+using namespace phosphor::logging;
+using namespace sdbusplus::xyz::openbmc_project::Common::Error;
+
+namespace boot_options
+{
+
+void register_sys_boot_option_functions() __attribute__((constructor));
+
+using namespace sdbusplus::xyz::openbmc_project::Control::Boot::server;
+using IpmiValue = uint8_t;
+constexpr auto ipmiDefault = 0;
+
+std::map<std::tuple<Source::Sources, Mode::Modes>, IpmiValue> sourceModeDbusToIpmi = {
+    {{Source::Sources::Network, Mode::Modes::Regular}, 0x1},
+    {{Source::Sources::Disk, Mode::Modes::Regular}, 0x2},
+    {{Source::Sources::Disk, Mode::Modes::Safe}, 0x3},
+    {{Source::Sources::Diagnostic, Mode::Modes::Regular}, 0x4},
+    {{Source::Sources::ExternalMedia, Mode::Modes::Regular}, 0x5},
+    {{Source::Sources::BIOS, Mode::Modes::Setup}, 0x6},
+    {{Source::Sources::RemoteRemovableMedia, Mode::Modes::Regular}, 0x7},
+    {{Source::Sources::RemoteCD, Mode::Modes::Regular}, 0x8},
+    {{Source::Sources::RemoteMedia, Mode::Modes::Regular}, 0x9},
+    {{Source::Sources::RemoteDisk, Mode::Modes::Regular}, 0xb},
+    {{Source::Sources::RemovableMedia, Mode::Modes::Regular}, 0xf},
+    {{Source::Sources::Default, Mode::Modes::Regular}, ipmiDefault}
+};
+
+std::map<IpmiValue, std::tuple<Source::Sources, Mode::Modes>> sourceModeIpmiToDbus = {
+    {0x1, {Source::Sources::Network, Mode::Modes::Regular}},
+    {0x2, {Source::Sources::Disk, Mode::Modes::Regular}},
+    {0x3, {Source::Sources::Disk, Mode::Modes::Safe}},
+    {0x4, {Source::Sources::Diagnostic, Mode::Modes::Regular}},
+    {0x5, {Source::Sources::ExternalMedia, Mode::Modes::Regular}},
+    {0x6, {Source::Sources::BIOS, Mode::Modes::Setup}},
+    {0x7, {Source::Sources::RemoteRemovableMedia, Mode::Modes::Regular}},
+    {0x8, {Source::Sources::RemoteCD, Mode::Modes::Regular}},
+    {0x9, {Source::Sources::RemoteMedia, Mode::Modes::Regular}},
+    {0xb, {Source::Sources::RemoteDisk, Mode::Modes::Regular}},
+    {0xf, {Source::Sources::RemovableMedia, Mode::Modes::Regular}},
+    {ipmiDefault, {Source::Sources::Default, Mode::Modes::Regular}}
+};
+
+std::map<ConsoleRedirection::Redirections, IpmiValue> redirectDbusToIpmi = {
+    {ConsoleRedirection::Redirections::Suppress, 0x1},
+    {ConsoleRedirection::Redirections::Enable, 0x2},
+    {ConsoleRedirection::Redirections::Default, ipmiDefault}};
+
+std::map<IpmiValue, ConsoleRedirection::Redirections> redirectIpmiToDbus = {
+    {0x1, ConsoleRedirection::Redirections::Suppress},
+    {0x2, ConsoleRedirection::Redirections::Enable},
+    {ipmiDefault, ConsoleRedirection::Redirections::Default}};
+
+std::map<FirmwareVerbosity::Levels, IpmiValue> verbosityDbusToIpmi = {
+    {FirmwareVerbosity::Levels::Quiet, 0x1},
+    {FirmwareVerbosity::Levels::Verbose, 0x2},
+    {FirmwareVerbosity::Levels::Default, ipmiDefault}};
+
+std::map<IpmiValue, FirmwareVerbosity::Levels> verbosityIpmiToDbus = {
+    {0x1, FirmwareVerbosity::Levels::Quiet},
+    {0x2, FirmwareVerbosity::Levels::Verbose},
+    {ipmiDefault, FirmwareVerbosity::Levels::Default}};
+
+std::map<MuxOverride::Modes, IpmiValue> muxDbusToIpmi = {
+    {MuxOverride::Modes::BMC, 0x1},
+    {MuxOverride::Modes::System, 0x2},
+    {MuxOverride::Modes::Default, ipmiDefault}};
+
+std::map<IpmiValue, MuxOverride::Modes> muxIpmiToDbus = {
+    {0x1, MuxOverride::Modes::BMC},
+    {0x2, MuxOverride::Modes::System},
+    {ipmiDefault, MuxOverride::Modes::Default}};
+
+std::map<SetInProgress::Statuses, IpmiValue> setDbusToIpmi = {
+    {SetInProgress::Statuses::SetInProgress, 0x1},
+    {SetInProgress::Statuses::SetComplete, ipmiDefault}};
+
+std::map<IpmiValue, SetInProgress::Statuses> setIpmiToDbus = {
+    {0x1, SetInProgress::Statuses::SetInProgress},
+    {ipmiDefault, SetInProgress::Statuses::SetComplete}};
+
+std::map<BootType::Types, IpmiValue> typeDbusToIpmi = {
+    {BootType::Types::EFI, 0x1},
+    {BootType::Types::Legacy, ipmiDefault}};
+
+std::map<IpmiValue, BootType::Types> typeIpmiToDbus = {
+    {0x1, BootType::Types::EFI},
+    {ipmiDefault, BootType::Types::Legacy}};
+
+/** @brief implements the Get Chassis system boot option
+ *  @param bootOption   - boot option parameter selector
+ *  @param reserved1    - reserved bit
+ *  @param setSelector  - selects a particular block or set of parameters
+ *                        under the given parameter selector
+ *                        write as 00h if parameter doesn't use a setSelector
+ *  @param blockSelector- selects a particular block within a set of
+ *                        parameters write as 00h if parameter doesn't use a
+ *                        blockSelector
+ *
+ *  @returns IPMI completion code plus response data
+ *  @param  Payload contains below parameters:
+ *   version             - parameter version
+ *   parameterSelector   - boot option parameter selector
+ *   parmIndicator - parameter vaild/invaild indicator
+ *   data          - configuration parameter data
+ */
+ipmi::RspType<ipmi::message::Payload>
+    ipmiChassisGetSysBootOptions(uint7_t parameterSelector, bool reserved1,
+                                 uint8_t setSelector, uint8_t blockSelector)
+{
+    if (reserved1)
+    {
+        return ipmi::responseInvalidFieldRequest();
+    }
+
+    constexpr uint4_t version = 0x01;
+    ipmi::message::Payload response;
+    response.pack(version, uint4_t{});
+    using namespace boot_options;
+
+    settings::boot::DbusBootOptions *bbus = bbus->getInstance();
+
+    ipmi::Cc rc;
+    bool parameterIsValid = false;
+
+    if (parameterSelector ==
+        static_cast<uint7_t>(BootOptionParameter::bootSetInProgress))
+    {
+        try
+        {
+            parameterIsValid = bbus->getValidity("BootSetInProgressValid");
+
+            ipmi::Value setInProgress;
+            rc = bbus->getBootProperty("SetInProgress", "SetInProgress", setInProgress);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting set in progress flag");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+            IpmiValue setInProgressRaw = setDbusToIpmi.at(
+                    SetInProgress::convertStatusesFromString(
+                        std::get<std::string>(setInProgress)));
+
+            response.pack(parameterSelector, parameterIsValid,
+                    uint2_t{setInProgressRaw}, uint6_t{});
+            return ipmi::responseSuccess(std::move(response));
+        }
+        catch (InternalFailure& e)
+        {
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else if (parameterSelector ==
+             static_cast<uint7_t>(BootOptionParameter::bootServicePartitionSelect))
+    {
+        try
+        {
+            parameterIsValid = bbus->getValidity("BootServicePartitionSelectorValid");
+
+            ipmi::Value servicePartition;
+            rc = bbus->getBootProperty("ServicePartitionSelect", "ServicePartition",
+                    servicePartition);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting service partition");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+            response.pack(parameterSelector, parameterIsValid,
+                    std::get<uint8_t>(servicePartition));
+            return ipmi::responseSuccess(std::move(response));
+        }
+        catch (InternalFailure& e)
+        {
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else if (parameterSelector ==
+             static_cast<uint7_t>(BootOptionParameter::bootServicePartitionScan))
+    {
+        try
+        {
+            parameterIsValid = bbus->getValidity("BootServicePartitionScanValid");
+
+            ipmi::Value requestScan;
+            rc = bbus->getBootProperty("ServicePartitionScan", "RequestScan",
+                    requestScan);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting service partition scan request status");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            ipmi::Value partitionDiscovered;
+            rc = bbus->getBootProperty("ServicePartitionScan", "PartitionDiscovered",
+                    partitionDiscovered);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting service partition scan status");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            response.pack(parameterSelector, parameterIsValid,
+                    std::get<bool>(requestScan),
+                    std::get<bool>(partitionDiscovered));
+            return ipmi::responseSuccess(std::move(response));
+        }
+        catch (InternalFailure& e)
+        {
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else if (parameterSelector ==
+             static_cast<uint7_t>(BootOptionParameter::bootBMCValidBitClearing))
+    {
+        try
+        {
+            parameterIsValid = bbus->getValidity("BootFlagValidClearingValid");
+
+            ipmi::Value noClearOnPowerup;
+            rc = bbus->getBootProperty("BootFlagValidClearing", "NoClearOnPowerup",
+                    noClearOnPowerup);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting clear valid bit on powerup flag");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            ipmi::Value noClearOnPushbutton;
+            rc = bbus->getBootProperty("BootFlagValidClearing", "NoClearOnPushbuttonReset",
+                    noClearOnPushbutton);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting clear valid bit on pushbutton reset flag");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            ipmi::Value noClearOnWatchdog;
+            rc = bbus->getBootProperty("BootFlagValidClearing", "NoClearOnWatchdogReset",
+                    noClearOnWatchdog);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting clear valid bit on watchdog reset flag");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            ipmi::Value noClearOnTimeout;
+            rc = bbus->getBootProperty("BootFlagValidClearing", "NoClearOnTimeout",
+                    noClearOnTimeout);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting clear valid bit on timeout flag");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            ipmi::Value noClearOnPEF;
+            rc = bbus->getBootProperty("BootFlagValidClearing", "NoClearOnPEFReset",
+                    noClearOnPEF);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting clear valid bit on PEF reset flag");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            response.pack(parameterSelector, parameterIsValid,
+                    std::get<bool>(noClearOnPowerup),
+                    std::get<bool>(noClearOnPushbutton),
+                    std::get<bool>(noClearOnWatchdog),
+                    std::get<bool>(noClearOnTimeout),
+                    std::get<bool>(noClearOnPEF));
+            return ipmi::responseSuccess(std::move(response));
+        }
+        catch (InternalFailure& e)
+        {
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else if (parameterSelector ==
+             static_cast<uint7_t>(BootOptionParameter::bootInfoAck))
+    {
+        parameterIsValid = bbus->getValidity("BootInfoAckValid");
+
+        ipmi::Value biosAck;
+        rc = bbus->getBootProperty("BootInfoAck", "BIOSAck", biosAck);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting boot info bios ack flag");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        ipmi::Value osLoaderAck;
+        rc = bbus->getBootProperty("BootInfoAck", "OSLoaderAck", osLoaderAck);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting boot info os loader ack flag");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        ipmi::Value osAck;
+        rc = bbus->getBootProperty("BootInfoAck", "OSAck", osAck);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting boot info os ack flag");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        ipmi::Value smsAck;
+        rc = bbus->getBootProperty("BootInfoAck", "SMSAck", smsAck);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting boot info sms ack flag");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        ipmi::Value oemAck;
+        rc = bbus->getBootProperty("BootInfoAck", "OEMAck", oemAck);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting boot info oem ack flag");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        response.pack(parameterSelector, parameterIsValid,
+                uint8_t{0x00},
+                uint1_t{std::get<bool>(biosAck)},
+                uint1_t{std::get<bool>(osLoaderAck)},
+                uint1_t{std::get<bool>(osAck)},
+                uint1_t{std::get<bool>(smsAck)},
+                uint1_t{std::get<bool>(oemAck)},
+                uint1_t{0x1},
+                uint1_t{0x1},
+                uint1_t{0x1});
+        return ipmi::responseSuccess(std::move(response));
+    }
+    else if (parameterSelector ==
+             static_cast<uint7_t>(BootOptionParameter::bootFlags))
+    {
+        try
+        {
+            parameterIsValid = bbus->getValidity("BootFlagsParamValid");
+
+            IpmiValue typeRaw;
+            IpmiValue muxOverrideRaw;
+            IpmiValue firmwareVerbosityRaw;
+            IpmiValue consoleRedirectionRaw;
+            IpmiValue sourceModeRaw;
+            ipmi::Value bootType;
+            ipmi::Value cmosClear;
+            ipmi::Value lockKeyboard;
+            ipmi::Value screenBlank;
+            ipmi::Value resetLockout;
+            ipmi::Value source;
+            ipmi::Value mode;
+            ipmi::Value consoleRedirection;
+            ipmi::Value lockSleep;
+            ipmi::Value passwordBypass;
+            ipmi::Value forceProgressTraps;
+            ipmi::Value firmwareVerbosity;
+            ipmi::Value lockPower;
+            ipmi::Value muxOverride;
+            ipmi::Value sharedModeOverride;
+            ipmi::Value deviceInstance;
+
+            bool oneTime = bbus->getAndRestoreOneTime();
+
+            /* Data 1 */
+            rc = bbus->getBootFlag("BootType", "Type", bootType);
+            if (rc == ipmi::ccInvalidFieldRequest) {
+                typeRaw = ipmiDefault;
+            } else if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting boot type setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            } else {
+                typeRaw = typeDbusToIpmi.at(
+                        BootType::convertTypesFromString(
+                            std::get<std::string>(bootType)));
+            }
+
+            /* Data 2 */
+            rc = bbus->getBootFlag("CMOSClear", "CMOSClear", cmosClear);
+            if (rc == ipmi::ccInvalidFieldRequest) {
+                cmosClear = bool{ipmiDefault};
+            } else if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting CMOS setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->getBootFlag("LockKeyboard", "LockKeyboard", lockKeyboard);
+            if (rc == ipmi::ccInvalidFieldRequest) {
+                lockKeyboard = bool{ipmiDefault};
+            } else if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting keyboard lock setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->getBootFlag("ScreenBlank", "ScreenBlank", screenBlank);
+            if (rc == ipmi::ccInvalidFieldRequest) {
+                screenBlank = bool{ipmiDefault};
+            } else if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting screen blank setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->getBootFlag("ResetLockout", "ResetLockout", resetLockout);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting reset lockout setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->getBootFlag("Source", "BootSource", source);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting boot source setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+            rc = bbus->getBootFlag("Mode", "BootMode", mode);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting boot mode setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+            sourceModeRaw = sourceModeDbusToIpmi.at(
+                std::make_tuple(
+                    Source::convertSourcesFromString(std::get<std::string>(source)),
+                    Mode::convertModesFromString(std::get<std::string>(mode))
+                )
+            );
+
+            /* Data 3 */
+            rc = bbus->getBootFlag("ConsoleRedirection", "ConsoleRedirection", consoleRedirection);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting console redirection setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+            consoleRedirectionRaw = redirectDbusToIpmi.at(
+                    ConsoleRedirection::convertRedirectionsFromString(
+                        std::get<std::string>(consoleRedirection)));
+
+            rc = bbus->getBootFlag("LockSleep", "LockSleep", lockSleep);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting sleep lockout setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->getBootFlag("PasswordBypass", "PasswordBypass", passwordBypass);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting password bypass setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->getBootFlag("ForceProgressTraps", "ForceProgressEventTraps", forceProgressTraps);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting force progress event traps setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->getBootFlag("FirmwareVerbosity", "FirmwareVerbosity", firmwareVerbosity);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting console redirection setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+            firmwareVerbosityRaw = verbosityDbusToIpmi.at(
+                    FirmwareVerbosity::convertLevelsFromString(
+                        std::get<std::string>(firmwareVerbosity)));
+
+            rc = bbus->getBootFlag("LockPower", "LockPower", lockPower);
+            if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting power lockout setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            /* Data 4 */
+            rc = bbus->getBootFlag("MuxOverride", "MuxOverride", muxOverride);
+            if (rc == ipmi::ccInvalidFieldRequest) {
+                muxOverrideRaw = ipmiDefault;
+            } else if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting mux override setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            } else {
+                muxOverrideRaw = muxDbusToIpmi.at(
+                        MuxOverride::convertModesFromString(
+                            std::get<std::string>(muxOverride)));
+            }
+
+
+            rc = bbus->getBootFlag("SharedModeOverride", "SharedModeOverride", sharedModeOverride);
+            if (rc == ipmi::ccInvalidFieldRequest) {
+                sharedModeOverride = bool{ipmiDefault};
+            } else if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting shared mode override setting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            /* Data 5 */
+            rc = bbus->getBootFlag("DeviceInstance", "DeviceInstance", deviceInstance);
+            if (rc == ipmi::ccInvalidFieldRequest) {
+                deviceInstance = uint8_t{ipmiDefault};
+            } else if (rc != ipmi::ccSuccess) {
+                log<level::ERR>("Error in getting boot device instancesetting");
+                report<InternalFailure>();
+                return ipmi::responseUnspecifiedError();
+            }
+
+            bool flagsValid = bbus->getValidity("BootFlagsValid");
+
+            response.pack(parameterSelector, parameterIsValid,
+                          uint5_t{}, // reserved
+                          uint1_t{typeRaw},
+                          uint1_t{oneTime},
+                          uint1_t{flagsValid},
+                          uint1_t{std::get<bool>(resetLockout)},
+                          uint1_t{std::get<bool>(screenBlank)},
+                          uint4_t{sourceModeRaw},
+                          uint1_t{std::get<bool>(lockKeyboard)},
+                          uint1_t{std::get<bool>(cmosClear)},
+                          uint2_t{consoleRedirectionRaw},
+                          uint1_t{std::get<bool>(lockSleep)},
+                          uint1_t{std::get<bool>(passwordBypass)},
+                          uint1_t{std::get<bool>(forceProgressTraps)},
+                          uint2_t{firmwareVerbosityRaw},
+                          uint1_t{std::get<bool>(lockPower)},
+                          uint3_t{muxOverrideRaw},
+                          uint1_t{std::get<bool>(sharedModeOverride)},
+                          uint4_t{}, // reserved
+                          uint5_t{std::get<uint8_t>(deviceInstance)},
+                          uint3_t{}); // reserved
+            return ipmi::responseSuccess(std::move(response));
+        }
+        catch (InternalFailure& e)
+        {
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else if (parameterSelector ==
+             static_cast<uint7_t>(BootOptionParameter::bootInitiatorInfo))
+    {
+        parameterIsValid = bbus->getValidity("BootInitiatorInfoValid");
+
+        ipmi::Value channel;
+        ipmi::Value sessionID;
+        ipmi::Value timestamp;
+
+        rc = bbus->getBootProperty("BootInitiatorInfo", "Channel", channel);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting boot initiator channel");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        rc = bbus->getBootProperty("BootInitiatorInfo", "SessionID", sessionID);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting boot initiator session ID");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        rc = bbus->getBootProperty("BootInitiatorInfo", "Timestamp", timestamp);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting boot initiator timestamp");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        response.pack(parameterSelector,
+                parameterIsValid,
+                uint4_t{std::get<uint8_t>(channel)},
+                uint4_t{},
+                std::get<uint32_t>(sessionID),
+                std::get<uint32_t>(timestamp));
+        return ipmi::responseSuccess(std::move(response));
+    }
+    else if (parameterSelector ==
+             static_cast<uint7_t>(BootOptionParameter::bootInitiatorMailbox))
+    {
+        parameterIsValid = bbus->getValidity("BootInitiatorMailboxValid");
+
+        ipmi::Value block;
+        ipmi::Value lower;
+        ipmi::Value upper;
+
+        rc = bbus->getBootProperty("BootMailbox", "BlockSelector", block);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting mailbox block selector");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        rc = bbus->getBootProperty("BootMailbox", std::string("Mailbox" + std::to_string(std::get<uint8_t>(block)) + "L"), lower);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting mailbox block lower");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        rc = bbus->getBootProperty("BootMailbox", std::string("Mailbox" + std::to_string(std::get<uint8_t>(block)) + "U"), upper);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting mailbox block upper");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        response.pack(parameterSelector, parameterIsValid,
+                std::get<uint8_t>(block),
+                std::get<uint64_t>(lower),
+                std::get<uint64_t>(upper));
+        return ipmi::responseSuccess(std::move(response));
+    }
+    else
+    {
+	log<level::ERR>(
+            "ipmiChassisGetSysBootOptions: Unsupported parameters",
+	    entry("PARAM=0x%x", static_cast<uint8_t>(parameterSelector)));
+	return ipmi::responseParamNotSupported();
+    }
+    return ipmi::responseUnspecifiedError();
+}
+
+ipmi::RspType<> ipmiChassisSetSysBootOptions(ipmi::Context::ptr ctx,
+                                             uint7_t parameterSelector,
+                                             bool parameterIsValid,
+                                             ipmi::message::Payload& data)
+{
+    using namespace boot_options;
+    ipmi::Cc rc;
+
+    settings::boot::DbusBootOptions *bbus = bbus->getInstance();
+
+    if (parameterSelector ==
+        static_cast<uint7_t>(BootOptionParameter::bootSetInProgress))
+    {
+        bbus->setValidity("BootSetInProgressValid", parameterIsValid);
+
+        if (data.fullyUnpacked())
+        {
+            return ipmi::responseSuccess();
+        }
+
+        uint6_t reserved;
+        uint2_t setStatus;
+
+        if (data.unpack(setStatus, reserved) != 0 || !data.fullyUnpacked())
+        {
+            return ipmi::responseReqDataLenInvalid();
+        }
+        if (reserved || setStatus == 0x3)
+        {
+            return ipmi::responseInvalidFieldRequest();
+        }
+        if (setStatus == 0x2)
+        {
+            return ipmi::responseParamNotSupported();
+        }
+
+        auto setItr = setIpmiToDbus.find(IpmiValue{setStatus});
+        if (setIpmiToDbus.end() != setItr)
+        {
+            if (setItr->second == SetInProgress::Statuses::SetInProgress)
+            {
+                ipmi::Value setInProgress;
+                rc = bbus->getBootProperty("SetInProgress", "SetInProgress", setInProgress);
+                if (rc != ipmi::ccSuccess) {
+                    log<level::ERR>("Error in getting set in progress flag");
+                    report<InternalFailure>();
+                    return ipmi::responseUnspecifiedError();
+                }
+                auto setInProgressCurrent = 
+                        SetInProgress::convertStatusesFromString(
+                            std::get<std::string>(setInProgress));
+
+                if (setInProgressCurrent == SetInProgress::Statuses::SetInProgress)
+                {
+                    return ipmi::responseSetInProgress();
+                }
+            }
+            rc = bbus->setBootProperty("SetInProgress", "SetInProgress",
+                    convertForMessage(setItr->second));
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting progress flag");
+                return ipmi::responseUnspecifiedError();
+            }
+        }
+    }
+    else if (parameterSelector ==
+        static_cast<uint7_t>(BootOptionParameter::bootServicePartitionSelect))
+    {
+        bbus->setValidity("BootServicePartitionSelectorValid", parameterIsValid);
+
+        if (data.fullyUnpacked())
+        {
+            return ipmi::responseSuccess();
+        }
+
+        uint8_t servicePartition;
+
+        if (data.unpack(servicePartition) != 0 || !data.fullyUnpacked())
+        {
+            return ipmi::responseReqDataLenInvalid();
+        }
+
+        try {
+            rc = bbus->setBootProperty("ServicePartitionSelect", "ServicePartition",
+                    servicePartition);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting service partition");
+                return ipmi::responseUnspecifiedError();
+            }
+        }
+        catch (sdbusplus::exception_t& e)
+        {
+            report<InternalFailure>();
+            log<level::ERR>(
+                "ipmiChassisSetSysBootOptions: Error in setting service "
+                "partition selector");
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else if (parameterSelector ==
+        static_cast<uint7_t>(BootOptionParameter::bootServicePartitionScan))
+    {
+        bbus->setValidity("BootServicePartitionScanValid", parameterIsValid);
+
+        if (data.fullyUnpacked())
+        {
+            return ipmi::responseSuccess();
+        }
+
+        uint6_t reserved;
+        bool requestScan;
+        bool partitionDiscovered;
+
+        if (data.unpack(partitionDiscovered, requestScan, reserved) != 0 ||
+                !data.fullyUnpacked())
+        {
+            return ipmi::responseReqDataLenInvalid();
+        }
+
+        if (reserved)
+        {
+            return ipmi::responseInvalidFieldRequest();
+        }
+
+        try
+        {
+            rc = bbus->setBootProperty("ServicePartitionScan", "RequestScan",
+                    requestScan);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting service partition scan request");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->setBootProperty("ServicePartitionScan", "PartitionDiscovered",
+                    partitionDiscovered);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting service partition discovered");
+                return ipmi::responseUnspecifiedError();
+            }
+        }
+        catch (sdbusplus::exception_t& e)
+        {
+            report<InternalFailure>();
+            log<level::ERR>(
+                "ipmiChassisSetSysBootOptions: Error in setting service "
+                "partition scan request");
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else if (parameterSelector ==
+        static_cast<uint7_t>(BootOptionParameter::bootBMCValidBitClearing))
+    {
+        bbus->setValidity("BootFlagValidClearingValid", parameterIsValid);
+
+        if (data.fullyUnpacked())
+        {
+            return ipmi::responseSuccess();
+        }
+
+        bool noClearOnPower;
+        bool noClearOnPushbutton;
+        bool noClearOnWatchdog;
+        bool noClearOnTimeout;
+        bool noClearOnPEF;
+        uint3_t reserved;
+
+        if (data.unpack(noClearOnPower, noClearOnPushbutton, noClearOnWatchdog,
+                    noClearOnTimeout, noClearOnPEF, reserved) != 0 ||
+                !data.fullyUnpacked())
+        {
+            return ipmi::responseReqDataLenInvalid();
+        }
+
+        if (reserved)
+        {
+            return ipmi::responseInvalidFieldRequest();
+        }
+
+        try
+        {
+            rc = bbus->setBootProperty("BootFlagValidClearing", "NoClearOnPowerup",
+                    noClearOnPower);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "no clear on power condition for valid bit");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->setBootProperty("BootFlagValidClearing", "NoClearOnPushbuttonReset",
+                    noClearOnPushbutton);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "no clear on pushbutton reset condition for valid bit");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->setBootProperty("BootFlagValidClearing", "NoClearOnWatchdogReset",
+                    noClearOnWatchdog);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "no clear on watchdog reset condition for valid bit");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->setBootProperty("BootFlagValidClearing", "NoClearOnTimeout",
+                    noClearOnTimeout);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "no clear on timeout condition for valid bit");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->setBootProperty("BootFlagValidClearing", "NoClearOnPEFReset",
+                    noClearOnPEF);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "no clear on PEF reset condition for valid bit");
+                return ipmi::responseUnspecifiedError();
+            }
+        }
+        catch (sdbusplus::exception_t& e)
+        {
+            report<InternalFailure>();
+            log<level::ERR>(
+                "ipmiChassisSetSysBootOptions: Error in setting BMC "
+                "valid bit clearing conditions");
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else if (parameterSelector ==
+             static_cast<uint7_t>(BootOptionParameter::bootInfoAck))
+    {
+        bbus->setValidity("BootInfoAckValid", parameterIsValid);
+
+        if (data.fullyUnpacked())
+        {
+            return ipmi::responseSuccess();
+        }
+
+        uint8_t writeMask;
+        uint5_t ackData;
+        bool biosAck;
+        bool osLoaderAck;
+        bool osAck;
+        bool smsAck;
+        bool oemAck;
+        uint3_t rsvd;
+
+        if (data.unpack(writeMask, biosAck, osLoaderAck, osAck, smsAck, oemAck,
+                        rsvd) != 0 ||
+            !data.fullyUnpacked())
+        {
+            return ipmi::responseReqDataLenInvalid();
+        }
+
+        if (writeMask & (0x1 << 0)) {
+            rc = bbus->setBootProperty("BootInfoAck", "BIOSAck", biosAck);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting bios ack");
+                return ipmi::responseUnspecifiedError();
+            }
+        }
+
+        if (writeMask & (0x1 << 1)) {
+            rc = bbus->setBootProperty("BootInfoAck", "OSLoaderAck", osLoaderAck);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting os loader ack");
+                return ipmi::responseUnspecifiedError();
+            }
+        }
+
+        if (writeMask & (0x1 << 2)) {
+            rc = bbus->setBootProperty("BootInfoAck", "OSAck", osAck);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting os ack");
+                return ipmi::responseUnspecifiedError();
+            }
+        }
+
+        if (writeMask & (0x1 << 3)) {
+            rc = bbus->setBootProperty("BootInfoAck", "SMSAck", smsAck);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting sms ack");
+                return ipmi::responseUnspecifiedError();
+            }
+        }
+
+        if (writeMask & (0x1 << 4)) {
+            rc = bbus->setBootProperty("BootInfoAck", "OEMAck", oemAck);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting oem ack");
+                return ipmi::responseUnspecifiedError();
+            }
+        }
+        
+        log<level::INFO>("ipmiChassisSetSysBootOptions: bootInfo parameter set "
+                         "successfully");
+        data.trailingOk = true;
+        return ipmi::responseSuccess();
+    }
+    else if (parameterSelector ==
+        static_cast<uint7_t>(BootOptionParameter::bootFlags))
+    {
+        bbus->setValidity("BootFlagsParamValid", parameterIsValid);
+
+        if (data.fullyUnpacked())
+        {
+            return ipmi::responseSuccess();
+        }
+
+        /* Data 1 */
+        uint5_t rsvd;
+        bool biosBootType;
+        bool permanent;
+        bool validFlag;
+
+        /* Data 2 */
+        bool resetLockout;
+        bool screenBlank;
+        uint4_t source;
+        bool lockKeyboard;
+        bool cmosClear;
+
+        /* Data 3 */
+        uint2_t consoleRedirection;
+        bool lockSleep;
+        bool passwordBypass;
+        bool forceEventTraps;
+        uint2_t firmwareVerbosity;
+        bool lockPower;
+
+        /* Data 4 */
+        uint3_t biosMuxOverride;
+        bool biosSharedOverride;
+        uint4_t rsvd1;
+
+        /* Data 5 */
+        uint5_t deviceInstance;
+        uint3_t rsvd2;
+
+        try
+        {
+
+        if (data.unpack(rsvd, biosBootType, permanent, validFlag, resetLockout,
+                        screenBlank, source, lockKeyboard, cmosClear,
+                        consoleRedirection, lockSleep, passwordBypass,
+                        forceEventTraps, firmwareVerbosity, lockPower,
+                        biosMuxOverride, biosSharedOverride, rsvd1,
+                        deviceInstance, rsvd2) != 0 ||
+            !data.fullyUnpacked())
+        {
+            return ipmi::responseReqDataLenInvalid();
+        }
+        if (rsvd || rsvd1 || rsvd2)
+        {
+            return ipmi::responseInvalidFieldRequest();
+        }
+        if (deviceInstance == 0x10) // reserved
+        {
+            return ipmi::responseParmOutOfRange();
+        }
+        if (permanent && ctx->priv < ipmi::Privilege::Admin)
+        {
+            return ipmi::responseInsufficientPrivilege();
+        }
+
+        if (permanent) {
+            bbus->setPermanent();
+        } else {
+            bbus->setOneTime();
+        }
+            /* Data 1 Flags */
+            auto typeItr = typeIpmiToDbus.find(IpmiValue{biosBootType});
+            if (typeIpmiToDbus.end() != typeItr)
+            {
+                rc = bbus->setBootFlag("BootType", "Type",
+                        convertForMessage(typeItr->second));
+                if (rc != ipmi::ccSuccess)
+                {
+                    log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                    "setting boot type");
+                    return ipmi::responseUnspecifiedError();
+                }
+            }
+
+            /* Data 2 Flags */
+            rc = bbus->setBootFlag("CMOSClear", "CMOSClear", cmosClear);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting cmos clear");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->setBootFlag("LockKeyboard", "LockKeyboard", lockKeyboard);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting keyboard lock");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->setBootFlag("ScreenBlank", "ScreenBlank", screenBlank);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting screen blank");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->setBootFlag("ResetLockout", "ResetLockout", resetLockout);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting reset lockout");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            auto sourceModeItr = sourceModeIpmiToDbus.find(IpmiValue{source});
+            if (sourceModeIpmiToDbus.end() != sourceModeItr)
+            {
+                rc = bbus->setBootFlag("Source", "BootSource",
+                        convertForMessage(
+                            std::get<Source::Sources>(sourceModeItr->second)));
+                if (rc != ipmi::ccSuccess)
+                {
+                    log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                    "setting boot source");
+                    return ipmi::responseUnspecifiedError();
+                }
+                rc = bbus->setBootFlag("Mode", "BootMode",
+                        convertForMessage(
+                            std::get<Mode::Modes>(sourceModeItr->second)));
+                if (rc != ipmi::ccSuccess)
+                {
+                    log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                    "setting boot mode");
+                    return ipmi::responseUnspecifiedError();
+                }
+            }
+
+            /* Data 3 Flags */
+            auto redirItr = redirectIpmiToDbus.find(IpmiValue{consoleRedirection});
+            if (redirectIpmiToDbus.end() != redirItr)
+            {
+                rc = bbus->setBootFlag("ConsoleRedirection",
+                        "ConsoleRedirection", convertForMessage(redirItr->second));
+                if (rc != ipmi::ccSuccess)
+                {
+                    log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                    "setting console redirection");
+                    return ipmi::responseUnspecifiedError();
+                }
+            }
+
+            rc = bbus->setBootFlag("LockSleep", "LockSleep", lockSleep);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting sleep lockout");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->setBootFlag("PasswordBypass", "PasswordBypass", passwordBypass);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting password bpyass");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            rc = bbus->setBootFlag("ForceProgressTraps", "ForceProgressEventTraps", forceEventTraps);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting force progress event traps");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            auto verbItr = verbosityIpmiToDbus.find(IpmiValue{firmwareVerbosity});
+            if (verbosityIpmiToDbus.end() != verbItr)
+            {
+                rc = bbus->setBootFlag("FirmwareVerbosity", "FirmwareVerbosity",
+                        convertForMessage(verbItr->second));
+                if (rc != ipmi::ccSuccess)
+                {
+                    log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                    "setting firmware verbosity");
+                    return ipmi::responseUnspecifiedError();
+                }
+            }
+
+            rc = bbus->setBootFlag("LockPower", "LockPower", lockPower);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting power lockout");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            /* Data 4 Flags */
+            auto muxItr = muxIpmiToDbus.find(IpmiValue{biosMuxOverride});
+            if (muxIpmiToDbus.end() != muxItr)
+            {
+                rc = bbus->setBootFlag("MuxOverride",
+                        "MuxOverride", convertForMessage(muxItr->second));
+                if (rc != ipmi::ccSuccess)
+                {
+                    log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                    "setting mux override");
+                    return ipmi::responseUnspecifiedError();
+                }
+            }
+
+            rc = bbus->setBootFlag("SharedModeOverride", "SharedModeOverride", biosSharedOverride);
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting shared mode override");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            /* Data 5 Flags */
+            rc = bbus->setBootFlag("DeviceInstance", "DeviceInstance", uint8_t{deviceInstance});
+            if (rc != ipmi::ccSuccess)
+            {
+                log<level::ERR>("ipmiChassisSetSysBootOptions: Error in "
+                                "setting boot device instance");
+                return ipmi::responseUnspecifiedError();
+            }
+
+            bbus->setValidity("BootFlagsValid", validFlag);
+        }
+        catch (sdbusplus::exception_t& e)
+        {
+            report<InternalFailure>();
+            log<level::ERR>(
+                "ipmiChassisSetSysBootOptions: Error in setting Boot "
+                "flag parameters");
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else if (parameterSelector ==
+             static_cast<uint7_t>(BootOptionParameter::bootInitiatorInfo))
+    {
+        bbus->setValidity("BootInitiatorInfoValid", parameterIsValid);
+
+        if (data.fullyUnpacked())
+        {
+            return ipmi::responseSuccess();
+        }
+
+        uint4_t channel;
+        uint4_t rsvd;
+        uint32_t sessionID;
+        uint32_t timestamp;
+
+        if (data.unpack(channel, rsvd, sessionID, timestamp) != 0 ||
+            !data.fullyUnpacked())
+        {
+            return ipmi::responseReqDataLenInvalid();
+        }
+
+        if (rsvd) {
+            return ipmi::responseInvalidFieldRequest();
+        }
+
+        rc = bbus->setBootProperty("BootInitiatorInfo", "Channel", uint8_t{channel});
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in setting boot initiator channel");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        rc = bbus->setBootProperty("BootInitiatorInfo", "SessionID", sessionID);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in setting boot initiator session ID");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        rc = bbus->setBootProperty("BootInitiatorInfo", "Timestamp", timestamp);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in setting boot initiator timestamp");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+    }
+    else if (parameterSelector ==
+             static_cast<uint7_t>(BootOptionParameter::bootInitiatorMailbox))
+    {
+        bbus->setValidity("BootInitiatorMailboxValid", parameterIsValid);
+
+        if (data.fullyUnpacked())
+        {
+            return ipmi::responseSuccess();
+        }
+
+        uint8_t block;
+        if (data.unpack(block) != 0) {
+            return ipmi::responseReqDataLenInvalid();
+        }
+        if (block > 4)
+        {
+            return ipmi::responseParmOutOfRange();
+        }
+
+        ipmi::Value lower;
+        ipmi::Value upper;
+
+        rc = bbus->setBootProperty("BootMailbox", "BlockSelector", block);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in setting mailbox block selector");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        if (data.fullyUnpacked()) {
+            return ipmi::responseSuccess();
+        }
+
+        rc = bbus->getBootProperty("BootMailbox", std::string("Mailbox" + std::to_string(block) + "L"), lower);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting mailbox block lower");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        rc = bbus->getBootProperty("BootMailbox", std::string("Mailbox" + std::to_string(block) + "U"), upper);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in getting mailbox block upper");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        uint8_t inByte;
+        uint64_t inLower = std::get<uint64_t>(lower);
+        uint64_t inUpper = std::get<uint64_t>(upper);
+        int i = 0;
+        while (data.unpack(inByte) == 0 && !data.fullyUnpacked() && i < 16)
+        {
+            if (i < 8) {
+                inLower &= ~(((uint64_t)0xFF) << ((i % 8) * 8)); // clear
+                inLower |= (((uint64_t)inByte) << ((i % 8) * 8)); // set
+            } else {
+                inUpper &= ~(((uint64_t)0xFF) << ((i % 8) * 8)); // clear
+                inUpper |= (((uint64_t)inByte) << ((i % 8) * 8)); // set
+            }
+
+            i++;
+        }
+
+        if (!data.fullyUnpacked()) {
+            log<level::ERR>("Bad mailbox data length");
+            report<InternalFailure>();
+            return ipmi::responseReqDataLenInvalid();
+        }
+
+        rc = bbus->setBootProperty("BootMailbox", std::string("Mailbox" + std::to_string(block) + "L"), inLower);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in setting mailbox block lower");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        rc = bbus->setBootProperty("BootMailbox", std::string("Mailbox" + std::to_string(block) + "U"), inUpper);
+        if (rc != ipmi::ccSuccess) {
+            log<level::ERR>("Error in setting mailbox block upper");
+            report<InternalFailure>();
+            return ipmi::responseUnspecifiedError();
+        }
+
+        return ipmi::responseSuccess();
+    }
+    else
+    {
+        log<level::ERR>(
+            "ipmiChassisSetSysBootOptions: Unsupported parameters",
+            entry("PARAM=0x%x",
+                  static_cast<uint8_t>(parameterSelector)));
+        data.trailingOk = true;
+        return ipmi::responseParamNotSupported();
+    }
+
+    return ipmi::responseSuccess();
+}
+
+void register_sys_boot_option_functions()
+{
+    // <Get System Boot Options>
+    ipmi::registerHandler(ipmi::prioOpenBmcBase, ipmi::netFnChassis,
+                          ipmi::chassis::cmdGetSystemBootOptions,
+                          ipmi::Privilege::Operator,
+                          ipmiChassisGetSysBootOptions);
+
+    // <Set System Boot Options>
+    ipmi::registerHandler(ipmi::prioOpenBmcBase, ipmi::netFnChassis,
+                          ipmi::chassis::cmdSetSystemBootOptions,
+                          ipmi::Privilege::Operator,
+                          ipmiChassisSetSysBootOptions);
+}
+
+} // namespace boot_options
diff --git a/systembootoption.hpp b/systembootoption.hpp
new file mode 100644
index 0000000..b78cf9b
--- /dev/null
+++ b/systembootoption.hpp
@@ -0,0 +1,29 @@
+#pragma once
+
+#include <stdint.h>
+
+#include <cstddef>
+
+// IPMI commands for Chassis net functions.
+enum ipmi_boot_option_cmds
+{
+    IPMI_CMD_SET_SYS_BOOT_OPTIONS = 0x08,
+    IPMI_CMD_GET_SYS_BOOT_OPTIONS = 0x09,
+};
+
+enum class BootOptionParameter : size_t
+{
+    bootSetInProgress = 0x0,
+    bootServicePartitionSelect = 0x1,
+    bootServicePartitionScan = 0x2,
+    bootBMCValidBitClearing = 0x3,
+    bootInfoAck = 0x4,
+    bootFlags = 0x5,
+    bootInitiatorInfo = 0x6,
+    bootInitiatorMailbox = 0x7,
+};
+
+enum class BootOptionResponseSize : size_t
+{
+    bootFlags = 5,
+};
