diff -Naur a/dcmihandler.cpp b/dcmihandler.cpp
--- a/dcmihandler.cpp	2021-03-14 22:56:03.824728858 +0530
+++ b/dcmihandler.cpp	2021-03-14 23:06:25.360512714 +0530
@@ -1,6 +1,7 @@
 #include "config.h"
 
 #include "dcmihandler.hpp"
+#include "sdrutils.hpp"
 
 #include "user_channel/channel_layer.hpp"
 
@@ -35,6 +36,7 @@
 constexpr auto DCMI_RAND_BACK_OFF_MASK = 0x80;
 constexpr auto DCMI_OPTION_60_43_MASK = 0x02;
 constexpr auto DCMI_OPTION_12_MASK = 0x01;
+constexpr auto DCMI_SET_CONF_PARAM2_RESERVED_MASK = 0x01;
 constexpr auto DCMI_ACTIVATE_DHCP_MASK = 0x01;
 constexpr auto DCMI_ACTIVATE_DHCP_REPLY = 0x00;
 constexpr auto DCMI_SET_CONF_PARAM_REQ_PACKET_MAX_SIZE = 0x04;
@@ -48,11 +50,14 @@
 // added into n/w configuration file and the parameter
 // SendHostNameEnabled will set to true.
 constexpr auto DHCP_OPT12_ENABLED = "SendHostNameEnabled";
+constexpr auto DHCP_OPT60_ENABLED = "VendorClassIdentifierEnabled";
 
 constexpr auto SENSOR_VALUE_INTF = "xyz.openbmc_project.Sensor.Value";
 constexpr auto SENSOR_VALUE_PROP = "Value";
 constexpr auto SENSOR_SCALE_PROP = "Scale";
 
+constexpr auto IPMI_INVALID_CMD_RES_UNKNOWN = 0x89;
+constexpr auto POWER_LIMIT_TMP_FILE = "/etc/power_limit.json";
 using namespace phosphor::logging;
 
 namespace dcmi
@@ -257,7 +262,7 @@
     auto value = ipmi::getDbusProperty(bus, service, ethernetObj.first,
                                        ethernetIntf, "DHCPEnabled");
 
-    return std::get<bool>(value);
+    return true;
 }
 
 bool getDHCPOption(std::string prop)
@@ -328,6 +333,22 @@
         return IPMI_CC_INVALID;
     }
 
+    auto requestData =
+        reinterpret_cast<const dcmi::GetPowerLimitRequest*>(request);
+
+    if (*data_len != sizeof(dcmi::GetPowerLimitRequest))
+    {
+        log<level::ERR>("Malformed request data",
+                        entry("DATA_SIZE=%d", *data_len));
+        return IPMI_CC_REQ_DATA_LEN_INVALID;
+    }
+    *data_len = 0;
+
+    if(requestData->reserved != 0)
+    {
+        return IPMI_CC_INVALID_FIELD_REQUEST;
+    }
+
     std::vector<uint8_t> outPayload(sizeof(dcmi::GetPowerLimitResponse));
     auto responseData =
         reinterpret_cast<dcmi::GetPowerLimitResponse*>(outPayload.data());
@@ -352,8 +373,8 @@
      * with the correction time limit is hardcoded to Hard Power Off system
      * and log event to SEL.
      */
-    constexpr auto exception = 0x01;
-    responseData->exceptionAction = exception;
+    //constexpr auto exception = 0x01;
+    //responseData->exceptionAction = exception;
 
     responseData->powerLimit = static_cast<uint16_t>(pcapValue);
 
@@ -361,6 +382,27 @@
      * Correction time limit and Statistics sampling period is currently not
      * populated.
      */
+    std::ifstream pwrLimitData(POWER_LIMIT_TMP_FILE, std::ios::in | std::ios::binary);
+    if (!pwrLimitData.good())
+    {
+        log<level::ERR>("Error in reading IPMI power limit file");
+	responseData->exceptionAction = 0;
+        responseData->correctionTime = 0;
+        responseData->samplingPeriod = 256;
+    }
+    else
+    {
+	 dcmi::Json jsonPowerLimit = dcmi::Json::array();
+         jsonPowerLimit = dcmi::Json::parse(pwrLimitData, nullptr, false);
+
+         dcmi::Json PwrLimitInfo = jsonPowerLimit[0];
+         responseData->exceptionAction = PwrLimitInfo["ExceptionAction"];
+         responseData->correctionTime = PwrLimitInfo["CorrectionTime"];
+         responseData->samplingPeriod = PwrLimitInfo["SamplingPeriod"];
+
+    }
+
+    pwrLimitData.close();
 
     *data_len = outPayload.size();
     memcpy(response, outPayload.data(), *data_len);
@@ -389,8 +431,30 @@
     auto requestData =
         reinterpret_cast<const dcmi::SetPowerLimitRequest*>(request);
 
-    sdbusplus::bus::bus sdbus{ipmid_get_sd_bus_connection()};
+    if (*data_len != sizeof(dcmi::SetPowerLimitRequest))
+    {
+        log<level::ERR>("Malformed request data",
+                        entry("DATA_SIZE=%d", *data_len));
+        return IPMI_CC_REQ_DATA_LEN_INVALID;
+    }
+    *data_len = 0;
+
+    if((requestData->reserved != 0) || (requestData->reserved1 != 0) || (requestData->reserved2 != 0))
+    {
+        return IPMI_CC_INVALID_FIELD_REQUEST;
+    }
+
+    if((requestData->exceptionAction >= 18) && (requestData->exceptionAction <= 255))
+    {
+        return IPMI_CC_INVALID_FIELD_REQUEST;	    
+    }
+
+    if(requestData->samplingPeriod == 0)
+    {
+	return IPMI_INVALID_CMD_RES_UNKNOWN;
+    }
 
+    sdbusplus::bus::bus sdbus{ipmid_get_sd_bus_connection()};
     // Only process the power limit requested in watts.
     try
     {
@@ -404,6 +468,29 @@
 
     log<level::INFO>("Set Power Cap",
                      entry("POWERCAP=%u", requestData->powerLimit));
+    
+    dcmi::Json jsonPwrLimitTbl = dcmi::Json::array();
+    dcmi::Json powerLimitInfo;
+    powerLimitInfo["ExceptionAction"] = requestData->exceptionAction;
+    powerLimitInfo["CorrectionTime"] = requestData->correctionTime;
+    powerLimitInfo["SamplingPeriod"] = requestData->samplingPeriod;
+
+    jsonPwrLimitTbl.push_back(powerLimitInfo);
+    static std::string tmpFile{POWER_LIMIT_TMP_FILE};
+    int fd = open(tmpFile.c_str(), O_CREAT | O_WRONLY | O_TRUNC | O_SYNC,
+                  S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+    if (fd < 0)
+    {
+        log<level::ERR>("Error in creating temporary IPMI power Limit data file");
+    }
+    const auto& writeStr = jsonPwrLimitTbl.dump();
+    if (write(fd, writeStr.c_str(), writeStr.size()) !=
+        static_cast<ssize_t>(writeStr.size()))
+    {
+        close(fd);
+        log<level::ERR>("Error in writing temporary IPMI power limit data file");
+    }
+    close(fd);
 
     *data_len = 0;
     return IPMI_CC_OK;
@@ -738,7 +825,13 @@
      {3,
       {{"MandatoryPrimaryLanOOBSupport", 1, 0, 8},
        {"OptionalSecondaryLanOOBSupport", 2, 0, 8},
-       {"OptionalSerialOOBMTMODECapability", 3, 0, 8}}}}};
+       {"OptionalSerialOOBMTMODECapability", 3, 0, 8}}}},
+       {dcmi::DCMICapParameters::ENHANCED_SYSTEM_POWER_ATTRIBUTES,
+     {2,
+      {{"NumberOfRollingTimesPeriods", 1, 0, 8},
+       {"TimeDurationUnits", 2, 0, 6},
+   	   {"TimeDuration", 2, 6, 2}}}}
+   };
 
 ipmi_ret_t getDCMICapabilities(ipmi_netfn_t netfn, ipmi_cmd_t cmd,
                                ipmi_request_t request, ipmi_response_t response,
@@ -842,15 +935,7 @@
         std::visit(ipmi::VariantToDoubleVisitor(), result.at("Value"));
     double absTemp = std::abs(temperature);
 
-    auto findFactor = result.find("Scale");
-    double factor = 0.0;
-    if (findFactor != result.end())
-    {
-        factor = std::visit(ipmi::VariantToDoubleVisitor(), findFactor->second);
-    }
-    double scale = std::pow(10, factor);
-
-    auto tempDegrees = absTemp * scale;
+    auto tempDegrees = std::round(absTemp);
     // Max absolute temp as per ipmi spec is 128.
     if (tempDegrees > maxTemp)
     {
@@ -940,7 +1025,7 @@
 
             uint8_t instanceNum = j.value("instance", 0);
             // Not in the instance range we're interested in
-            if (instanceNum < instanceStart)
+            if (instanceNum <= instanceStart)
             {
                 continue;
             }
@@ -1108,7 +1193,7 @@
         log<level::ERR>("Invalid Requested Packet size",
                         entry("PACKET SIZE=%d", *data_len));
         *data_len = 0;
-        return IPMI_CC_INVALID_FIELD_REQUEST;
+        return IPMI_CC_REQ_DATA_LEN_INVALID;
     }
 
     try
@@ -1149,6 +1234,10 @@
                     return IPMI_CC_REQ_DATA_LEN_INVALID;
                 }
 
+		if((requestData->data[0] & (DCMI_SET_CONF_PARAM2_RESERVED_MASK << 6)) || (requestData->data[0] & (DCMI_SET_CONF_PARAM2_RESERVED_MASK << 5)) || (requestData->data[0] & (DCMI_SET_CONF_PARAM2_RESERVED_MASK << 4)) || (requestData->data[0] & (DCMI_SET_CONF_PARAM2_RESERVED_MASK << 3)) || (requestData->data[0] & (DCMI_SET_CONF_PARAM2_RESERVED_MASK << 2)))
+		{
+		    return IPMI_CC_INVALID_FIELD_REQUEST;
+		}
 
                 if (requestData->data[0] & DCMI_OPTION_12_MASK)
                 {
@@ -1159,6 +1248,16 @@
                     dcmi::setDHCPOption(DHCP_OPT12_ENABLED, false);
                 }
 
+
+		if (requestData->data[0] & DCMI_OPTION_60_43_MASK)
+		{
+			 dcmi::setDHCPOption(DHCP_OPT60_ENABLED, true);
+		}
+		else 
+                {
+                         dcmi::setDHCPOption(DHCP_OPT60_ENABLED, false);
+                }
+
                 // Systemd-networkd doesn't support Random Back off
                 if (requestData->data[0] & DCMI_RAND_BACK_OFF_MASK)
                 {
@@ -1218,6 +1317,12 @@
                 {
                     responseData->data[0] |= DCMI_OPTION_12_MASK;
                 }
+
+	        if(dcmi::getDHCPOption(DHCP_OPT60_ENABLED))
+		{
+			responseData->data[0] |= DCMI_OPTION_60_43_MASK;
+    	        } 
+
                 *data_len = sizeof(dcmi::GetConfParamsResponse) + 1;
                 break;
             // Get below values from Systemd-networkd source code
@@ -1265,9 +1370,11 @@
     }
 
     ipmi_ret_t rc = IPMI_CC_OK;
+    auto requestData =
+        reinterpret_cast<dcmi::GetPowerReadingRequest*>(request);
     auto responseData =
         reinterpret_cast<dcmi::GetPowerReadingResponse*>(response);
-
+    /*
     sdbusplus::bus::bus bus{ipmid_get_sd_bus_connection()};
     int64_t power = 0;
     try
@@ -1281,11 +1388,58 @@
                         entry("PROPERTY=%s", SENSOR_VALUE_PROP));
         return IPMI_CC_UNSPECIFIED_ERROR;
     }
-
+    */
     // TODO: openbmc/openbmc#2819
     // Minimum, Maximum, Average power, TimeFrame, TimeStamp,
     // PowerReadingState readings need to be populated
     // after Telemetry changes.
+
+    if((requestData->mode > dcmi::DCMIPowerReadingMode::MODE_ENHANCED_POWER_STATS) || (requestData->reserved2))
+      {
+	*data_len = 0;
+        log<level::ERR>("Invalid data fields");
+        return IPMI_CC_INVALID;
+      }
+
+    sdbusplus::bus::bus bus{ipmid_get_sd_bus_connection()};
+    int64_t power = 0;
+
+    switch(requestData->mode)
+      {
+	
+      case dcmi::DCMIPowerReadingMode::MODE_POWER_STATS:
+	if(requestData->modeAttribute != 0)
+	  {
+	    *data_len = 0;
+	    log<level::ERR>("Invalid data fields");
+	    return IPMI_CC_INVALID;
+	  }
+
+
+       // Get Time in milli seconds
+       try
+       {
+           power = getPowerReading(bus);
+       }
+       catch (InternalFailure& e)
+       {
+           log<level::ERR>("Error in reading power sensor value",
+                           entry("INTERFACE=%s", SENSOR_VALUE_INTF),
+                           entry("PROPERTY=%s", SENSOR_VALUE_PROP));
+           return IPMI_CC_UNSPECIFIED_ERROR;
+       }
+       break;
+   case dcmi::DCMIPowerReadingMode::MODE_ENHANCED_POWER_STATS:
+
+       // check if Rolling Average Time Period is allowed (only ones 
+       //   specified in DMCI Capability Parameter 5 are allowed)
+
+
+       break;
+   default:
+     return IPMI_CC_INVALID;
+   }
+    
     uint16_t totalPower = static_cast<uint16_t>(power);
     responseData->currentPower = totalPower;
     responseData->minimumPower = totalPower;
@@ -1304,7 +1458,8 @@
 Response createFromJson(const Json& config)
 {
     Response response{};
-    uint16_t recordId = config.value("record_id", 0);
+    std::string dcmiSensorpath = config.value("dbus", "");
+    uint16_t recordId = getSensorNumberFromPath(dcmiSensorpath);
     response.recordIdLsb = recordId & 0xFF;
     response.recordIdMsb = (recordId >> 8) & 0xFF;
     return response;
@@ -1369,7 +1524,7 @@
 
             uint8_t instanceNum = reading.value("instance", 0);
             // Not in the instance range we're interested in
-            if (instanceNum < instanceStart)
+            if (instanceNum <= instanceStart)
             {
                 continue;
             }
diff -Naur a/dcmihandler.hpp b/dcmihandler.hpp
--- a/dcmihandler.hpp	2021-03-14 22:56:21.505356361 +0530
+++ b/dcmihandler.hpp	2021-03-14 23:14:21.000008481 +0530
@@ -211,6 +211,15 @@
 
 /** @struct GetPowerLimitResponse
  *
+ *  DCMI payload for Get Power Limit command resquest.
+ */
+struct GetPowerLimitRequest
+{
+    uint16_t reserved;       //!< Reserved.
+} __attribute__((packed));
+
+/** @struct GetPowerLimitResponse
+ *
  *  DCMI payload for Get Power Limit command response.
  */
 struct GetPowerLimitResponse
@@ -320,6 +329,7 @@
     MANDATORY_PLAT_ATTRIBUTES = 0x02,       //!< Mandatory Platform Attributes
     OPTIONAL_PLAT_ATTRIBUTES = 0x03,        //!< Optional Platform Attributes
     MANAGEABILITY_ACCESS_ATTRIBUTES = 0x04, //!< Manageability Access Attributes
+    ENHANCED_SYSTEM_POWER_ATTRIBUTES = 0x05 //!< Enhanced System Power Attributes
 };
 
 /** @struct GetDCMICapRequest
@@ -486,6 +496,16 @@
  */
 int64_t getPowerReading(sdbusplus::bus::bus& bus);
 
+/** @enum DCMIPowerReadingModes
+*
+* DCMI Power Reading Modes
+*/
+enum DCMIPowerReadingMode : uint8_t
+{
+   MODE_POWER_STATS = 0x01,            //!< Mode Power Stats
+   MODE_ENHANCED_POWER_STATS = 0x02    //!< Mode Enhanced Power Stats
+};
+
 /** @struct GetPowerReadingRequest
  *
  *  DCMI Get Power Reading command request.
@@ -495,6 +515,7 @@
 {
     uint8_t mode;          //!< Mode
     uint8_t modeAttribute; //!< Mode Attributes
+    uint8_t reserved2;     //!< Reserved2
 } __attribute__((packed));
 
 /** @struct GetPowerReadingResponse
@@ -512,8 +533,14 @@
     uint16_t averagePower;     //!< Average power over sampling duration
                                //!< in watts
     uint32_t timeStamp;        //!< IPMI specification based time stamp
-    uint32_t timeFrame;        //!< Statistics reporting time period in milli
-                               //!< seconds.
+                               //!< For Mode 02: Time Stamp specifies the end
+                               //!< of the averaging window
+    uint32_t timeFrame;        //!< Statistics reporting time
+                               //!< For Mode 01: timeframe in period in milli
+                                //!< seconds.
+                               //!< For Mode 02: Timeframe reflects the
+                               //!<   Averaging Time period unit
+                               //!< Averaging Time period unit
     uint8_t powerReadingState; //!< Power Reading State
 } __attribute__((packed));
 
diff -Naur a/sdrutils.hpp b/sdrutils.hpp
--- a/sdrutils.hpp	1970-01-01 05:30:00.000000000 +0530
+++ b/sdrutils.hpp	2021-03-14 23:07:36.585784302 +0530
@@ -0,0 +1,251 @@
+/*
+// Copyright (c) 2018 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+*/
+
+#include <boost/algorithm/string.hpp>
+#include <boost/bimap.hpp>
+#include <boost/container/flat_map.hpp>
+#include <cstring>
+#include <phosphor-logging/log.hpp>
+#include <sdbusplus/bus/match.hpp>
+
+#pragma once
+
+struct CmpStrVersion
+{
+    bool operator()(std::string a, std::string b) const
+    {
+        return strverscmp(a.c_str(), b.c_str()) < 0;
+    }
+};
+
+using SensorSubTree = boost::container::flat_map<
+    std::string,
+    boost::container::flat_map<std::string, std::vector<std::string>>,
+    CmpStrVersion>;
+
+using SensorNumMap = boost::bimap<int, std::string>;
+
+namespace details
+{
+inline static bool getSensorSubtree(std::shared_ptr<SensorSubTree>& subtree)
+{
+    static std::shared_ptr<SensorSubTree> sensorTreePtr;
+    sd_bus* bus = NULL;
+    int ret = sd_bus_default_system(&bus);
+    if (ret < 0)
+    {
+        phosphor::logging::log<phosphor::logging::level::ERR>(
+            "Failed to connect to system bus",
+            phosphor::logging::entry("ERRNO=0x%X", -ret));
+        sd_bus_unref(bus);
+        return false;
+    }
+    sdbusplus::bus::bus dbus(bus);
+    static sdbusplus::bus::match::match sensorAdded(
+        dbus,
+        "type='signal',member='InterfacesAdded',arg0path='/xyz/openbmc_project/"
+        "sensors/'",
+        [](sdbusplus::message::message& m) { sensorTreePtr.reset(); });
+
+    static sdbusplus::bus::match::match sensorRemoved(
+        dbus,
+        "type='signal',member='InterfacesRemoved',arg0path='/xyz/"
+        "openbmc_project/sensors/'",
+        [](sdbusplus::message::message& m) { sensorTreePtr.reset(); });
+
+    bool sensorTreeUpdated = false;
+    if (sensorTreePtr)
+    {
+        subtree = sensorTreePtr;
+        return sensorTreeUpdated;
+    }
+
+    sensorTreePtr = std::make_shared<SensorSubTree>();
+
+    auto mapperCall =
+        dbus.new_method_call("xyz.openbmc_project.ObjectMapper",
+                             "/xyz/openbmc_project/object_mapper",
+                             "xyz.openbmc_project.ObjectMapper", "GetSubTree");
+    static constexpr const auto depth = 2;
+    static constexpr std::array<const char*, 3> interfaces = {
+        "xyz.openbmc_project.Sensor.Value",
+        "xyz.openbmc_project.Sensor.Threshold.Warning",
+        "xyz.openbmc_project.Sensor.Threshold.Critical"};
+    mapperCall.append("/xyz/openbmc_project/sensors", depth, interfaces);
+
+    try
+    {
+        auto mapperReply = dbus.call(mapperCall);
+        mapperReply.read(*sensorTreePtr);
+    }
+    catch (sdbusplus::exception_t& e)
+    {
+        phosphor::logging::log<phosphor::logging::level::ERR>(e.what());
+        return sensorTreeUpdated;
+    }
+    subtree = sensorTreePtr;
+    sensorTreeUpdated = true;
+    return sensorTreeUpdated;
+}
+
+inline static bool getSensorNumMap(std::shared_ptr<SensorNumMap>& sensorNumMap)
+{
+    static std::shared_ptr<SensorNumMap> sensorNumMapPtr;
+    bool sensorNumMapUpated = false;
+
+    std::shared_ptr<SensorSubTree> sensorTree;
+    bool sensorTreeUpdated = details::getSensorSubtree(sensorTree);
+    if (!sensorTree)
+    {
+        return sensorNumMapUpated;
+    }
+
+    if (!sensorTreeUpdated && sensorNumMapPtr)
+    {
+        sensorNumMap = sensorNumMapPtr;
+        return sensorNumMapUpated;
+    }
+
+    sensorNumMapPtr = std::make_shared<SensorNumMap>();
+
+    uint8_t sensorNum = 0;
+    for (const auto& sensor : *sensorTree)
+    {
+        sensorNumMapPtr->insert(
+            SensorNumMap::value_type(sensorNum++, sensor.first));
+    }
+    sensorNumMap = sensorNumMapPtr;
+    sensorNumMapUpated = true;
+    return sensorNumMapUpated;
+}
+} // namespace details
+
+inline static bool getSensorSubtree(SensorSubTree& subtree)
+{
+    std::shared_ptr<SensorSubTree> sensorTree;
+    details::getSensorSubtree(sensorTree);
+    if (!sensorTree)
+    {
+        return false;
+    }
+
+    subtree = *sensorTree;
+    return true;
+}
+
+struct CmpStr
+{
+    bool operator()(const char* a, const char* b) const
+    {
+        return std::strcmp(a, b) < 0;
+    }
+};
+
+enum class SensorTypeCodes : uint8_t
+{
+    reserved = 0x0,
+    temperature = 0x1,
+    voltage = 0x2,
+    current = 0x3,
+    fan = 0x4,
+    other = 0xB,
+};
+
+const static boost::container::flat_map<const char*, SensorTypeCodes, CmpStr>
+    sensorTypes{{{"temperature", SensorTypeCodes::temperature},
+                 {"voltage", SensorTypeCodes::voltage},
+                 {"current", SensorTypeCodes::current},
+                 {"fan_tach", SensorTypeCodes::fan},
+                 {"fan_pwm", SensorTypeCodes::fan},
+                 {"power", SensorTypeCodes::other}}};
+
+inline static std::string getSensorTypeStringFromPath(const std::string& path)
+{
+    // get sensor type string from path, path is defined as
+    // /xyz/openbmc_project/sensors/<type>/label
+    size_t typeEnd = path.rfind("/");
+    if (typeEnd == std::string::npos)
+    {
+        return path;
+    }
+    size_t typeStart = path.rfind("/", typeEnd - 1);
+    if (typeStart == std::string::npos)
+    {
+        return path;
+    }
+    // Start at the character after the '/'
+    typeStart++;
+    return path.substr(typeStart, typeEnd - typeStart);
+}
+
+inline static uint8_t getSensorTypeFromPath(const std::string& path)
+{
+    uint8_t sensorType = 0;
+    std::string type = getSensorTypeStringFromPath(path);
+    auto findSensor = sensorTypes.find(type.c_str());
+    if (findSensor != sensorTypes.end())
+    {
+        sensorType = static_cast<uint8_t>(findSensor->second);
+    } // else default 0x0 RESERVED
+
+    return sensorType;
+}
+
+inline static uint8_t getSensorNumberFromPath(const std::string& path)
+{
+    std::shared_ptr<SensorNumMap> sensorNumMapPtr;
+    details::getSensorNumMap(sensorNumMapPtr);
+    if (!sensorNumMapPtr)
+    {
+        return 0xFF;
+    }
+
+    try
+    {
+        return sensorNumMapPtr->right.at(path);
+    }
+    catch (std::out_of_range& e)
+    {
+        phosphor::logging::log<phosphor::logging::level::ERR>(e.what());
+        return 0xFF;
+    }
+}
+
+inline static uint8_t getSensorEventTypeFromPath(const std::string& path)
+{
+    // TODO: Add support for additional reading types as needed
+    return 0x1; // reading type = threshold
+}
+
+inline static std::string getPathFromSensorNumber(uint8_t sensorNum)
+{
+    std::shared_ptr<SensorNumMap> sensorNumMapPtr;
+    details::getSensorNumMap(sensorNumMapPtr);
+    if (!sensorNumMapPtr)
+    {
+        return std::string();
+    }
+
+    try
+    {
+        return sensorNumMapPtr->left.at(sensorNum);
+    }
+    catch (std::out_of_range& e)
+    {
+        phosphor::logging::log<phosphor::logging::level::ERR>(e.what());
+        return std::string();
+    }
+}
