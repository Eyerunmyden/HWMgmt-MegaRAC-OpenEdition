--- tmp/work/armv7ahf-vfpv4d16-openbmc-linux-gnueabi/phosphor-ipmi-host/1.0+gitAUTOINC+c0fe0c6b49-r1/git/apphandler.cpp	2021-05-19 13:36:10.150346940 -0400
+++ ./apphandler.cpp	2021-05-19 13:34:48.001580244 -0400
@@ -760,28 +760,59 @@
     return uuid;
 }
 
-auto ipmiAppGetDeviceGuid()
-    -> ipmi::RspType<std::array<uint8_t, uuidBinaryLength>>
+auto ipmiAppGetDeviceGuid() -> ipmi::RspType<std::array<uint8_t, 16>>
 {
-    // return a fixed GUID based on /etc/machine-id
-    // This should match the /redfish/v1/Managers/bmc's UUID data
-
-    // machine specific application ID (for BMC ID)
-    // generated by systemd-id128 -p new as per man page
-    static constexpr sd_id128_t bmcUuidAppId = SD_ID128_MAKE(
-        e0, e1, 73, 76, 64, 61, 47, da, a5, 0c, d0, cc, 64, 12, 45, 78);
-
-    sd_id128_t bmcUuid;
-    // create the UUID from /etc/machine-id via the systemd API
-    sd_id128_get_machine_app_specific(bmcUuidAppId, &bmcUuid);
-
-    char bmcUuidCstr[SD_ID128_STRING_MAX];
-    std::string systemUuid = sd_id128_to_string(bmcUuid, bmcUuidCstr);
+    std::string  deviceUuid {""};
+    const char* filename = "/home/root/bmcweb_persistent_data.json";
+    std::ifstream dev_uuid(filename);
+        if (dev_uuid.is_open())
+        {
+            auto data = nlohmann::json::parse(dev_uuid, nullptr, false);
+            if (data.is_discarded())
+            {
+                    std::cout
+                    << "Error parsing persistent data in json file.";
+            }
+            else{
+                  for (const auto& item : data.items())
+                  {
+                     if (item.key() == "device_uuid")
+                     {
+                        const std::string* jDeviceUuid =
+                        item.value().get_ptr<const std::string*>();
+			if (jDeviceUuid != nullptr)
+                        {
+                          deviceUuid = *jDeviceUuid;
+			  sd_journal_print(LOG_ERR, "guidtest: device UUID %s\n",deviceUuid.c_str());
+                          break;
+                        }
+                    }
+                  }
+              }
+        }
 
-    std::array<uint8_t, uuidBinaryLength> uuid = rfc4122ToIpmi(systemUuid);
+    std::array<uint8_t, 16> uuid;
+    std::string rfc4122Uuid =  deviceUuid;
+    try
+    {
+        // convert to IPMI format
+        uuid = rfc4122ToIpmi(rfc4122Uuid);
+    }
+    catch (const InvalidArgument& e)
+    {
+        log<level::ERR>("Failed in converting Uuid");
+        return ipmi::responseUnspecifiedError();
+    }
+    for(int j=0;j<16;++j)
+    {
+      sd_journal_print(LOG_ERR, "guidtest: uuid[%d] - 0x%x\n",j,uuid[j]);
+    }
+    
     return ipmi::responseSuccess(uuid);
 }
 
+    
+	
 auto ipmiAppGetBtCapabilities()
     -> ipmi::RspType<uint8_t, uint8_t, uint8_t, uint8_t, uint8_t>
 {
