diff -Naur a/include/ipmi_to_redfish_hooks.hpp b/include/ipmi_to_redfish_hooks.hpp
--- a/include/ipmi_to_redfish_hooks.hpp	2021-04-25 04:20:58.240501547 -0400
+++ b/include/ipmi_to_redfish_hooks.hpp	2021-04-08 06:51:10.701670381 -0400
@@ -36,6 +36,19 @@
 bool checkRedfishHooks(uint8_t generatorID, uint8_t evmRev, uint8_t sensorType,
                        uint8_t sensorNum, uint8_t eventType, uint8_t eventData1,
                        uint8_t eventData2, uint8_t eventData3);
+
+bool checkOEMRedfishHooks(uint16_t recordID, uint8_t recordType, 
+						uint8_t OEMData1, uint8_t OEMData2, uint8_t OEMData3,
+						uint8_t OEMData4 , uint8_t OEMData5, uint8_t OEMData6,
+						uint8_t OEMData7 , uint8_t OEMData8, uint8_t OEMData9,
+						uint8_t OEMData10 , uint8_t OEMData11, uint8_t OEMData12,
+						uint8_t OEMData13 );
+
+bool checkOEMTsRedfishHooks( uint16_t recordID, uint8_t recordType,
+                       uint32_t timestamp, uint8_t ManufactureIDByte1, uint8_t ManufactureIDByte2, uint8_t ManufactureIDByte3, 
+						uint8_t OEMData1, uint8_t OEMData2, uint8_t OEMData3,
+						uint8_t OEMData4 , uint8_t OEMData5, uint8_t OEMData6);
+
 namespace redfish_hooks
 {
 
@@ -82,6 +95,39 @@
     int eventData3;
 };
 
+struct OEMTsSELData
+{
+	uint8_t recordType;
+	uint8_t ManufactureIDByte1;
+	uint8_t ManufactureIDByte2;
+	uint8_t ManufactureIDByte3;
+	uint8_t OEMData1;
+	uint8_t OEMData2;
+	uint8_t OEMData3;
+	uint8_t OEMData4;
+	uint8_t OEMData5;
+	uint8_t OEMData6;
+};
+
+struct OEMSELData
+{
+	uint8_t recordType;
+	uint8_t OEMData1;
+	uint8_t OEMData2;
+	uint8_t OEMData3;
+	uint8_t OEMData4;
+	uint8_t OEMData5;
+	uint8_t OEMData6;
+	uint8_t OEMData7;
+	uint8_t OEMData8;
+	uint8_t OEMData9;
+	uint8_t OEMData10;
+	uint8_t OEMData11;
+	uint8_t OEMData12;
+	uint8_t OEMData13;
+};
+
+
 enum class BIOSSensors
 {
     memoryRASConfigStatus = 0x02,

diff -Naur a/include/redfish_map.hpp b/include/redfish_map.hpp
--- a/include/redfish_map.hpp	2021-04-25 04:20:58.240501547 -0400
+++ b/include/redfish_map.hpp	2021-04-27 03:17:45.027886914 -0400
@@ -1,18 +1,35 @@
 #include <string>
 #include <map>
 #include <bits/stdc++.h>
+#include "projdef.h"
 
-static const int MaxRecords=1000;
+std::string logfileformat = "/var/sellog/redfish.";
+std::string filename = "/var/sellog/redfish";
+
+#define RECORDS_PER_FILE 64
+#define MAX_FILE_INDEX 1024
+static int MaxFlag=0;
+static int maxRecordId =65534;
+static int FirstSelId=0;
+static int LastSelId=0;
+static int rotateflag=0;
+
+std::string selbusyflag="/tmp/sel_busy";
+const char *selrotatepath ="/tmp/selrotate";
 
 struct SELInfo_T
 {
 	char FileName[30];
 	unsigned long mod_time;
-	int StartingID;
 	int SELEntries;
 };
 
-SELInfo_T **SELInfoPtr=NULL;
+SELInfo_T SelInfo =
+{	.FileName = {0},
+	.mod_time =0,
+	.SELEntries =0,
+};
+
 int totalfiles=0;
 int totalSELEntries=0;
 

diff -Naur a/src/ipmi_to_redfish_hooks.cpp b/src/ipmi_to_redfish_hooks.cpp
--- a/src/ipmi_to_redfish_hooks.cpp	2021-04-25 04:20:58.240501547 -0400
+++ b/src/ipmi_to_redfish_hooks.cpp	2021-04-25 04:49:18.840522103 -0400
@@ -981,7 +981,7 @@
     }
 #endif
 
-     if(selData.sensorNum == 0x30 )
+    if(selData.sensorNum == 0x30 )
     {
         eventType = 0x30;
         SensorName = "SampleSensor1";
@@ -1416,8 +1416,37 @@
         phosphor::logging::entry("REDFISH_MESSAGE_ARGS=%s,%x,%x",
                                  SensorName.c_str(), selData.eventData3, selData.eventData3));
         return true;
+		
+}
+
+static bool startOEMTsRedfishHook(const OEMTsSELData& selData, const std::string& ipmiRaw)
+{
+		static const std::string openBMCMessageRegistryVersion("0.1");
+		std::string messageID = "OpenBMC." + openBMCMessageRegistryVersion;
+		std::string journalMsg = "SEL Entry Added: " + ipmiRaw;
+		std::string OEMString = "OEMTs" ; 
+        phosphor::logging::log<phosphor::logging::level::INFO>(
+        journalMsg.c_str(),
+        phosphor::logging::entry("REDFISH_MESSAGE_ID=%s,%s,%x", messageID.c_str(),OEMString.c_str(),selData.recordType),
+        phosphor::logging::entry("REDFISH_MESSAGE_ARGS=%x,%x,%x,%x,%x,%x,%x,%x,%x",
+                                 selData.ManufactureIDByte1, selData.ManufactureIDByte2, selData.ManufactureIDByte3, selData.OEMData1, selData.OEMData2, selData.OEMData3, selData.OEMData4, selData.OEMData5, selData.OEMData6));
+	return true;
+}
 
+static bool startOEMRedfishHook(const OEMSELData& selData, const std::string& ipmiRaw)
+{
+		static const std::string openBMCMessageRegistryVersion("0.1");
+        std::string messageID = "OpenBMC." + openBMCMessageRegistryVersion;
+		std::string OEMString = "OEM" ; 
+	    std::string journalMsg = "SEL Entry Added: " + ipmiRaw;
+        phosphor::logging::log<phosphor::logging::level::INFO>(
+        journalMsg.c_str(),
+        phosphor::logging::entry("REDFISH_MESSAGE_ID=%s,%s,%x", messageID.c_str(),OEMString.c_str(),selData.recordType),
+        phosphor::logging::entry("REDFISH_MESSAGE_ARGS=%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x",
+                                 selData.OEMData1, selData.OEMData2, selData.OEMData3, selData.OEMData4, selData.OEMData5, selData.OEMData6, selData.OEMData7, 	selData.OEMData8, selData.OEMData9, selData.OEMData10, selData.OEMData11, selData.OEMData12, selData.OEMData13));
+	return true;
 }
+
 } // namespace redfish_hooks
 
 static constexpr uint16_t selInvalidRecID =
@@ -1534,6 +1563,55 @@
     return true;
 }
 
+bool checkOEMTsRedfishHooks( uint16_t recordID, uint8_t recordType,
+                       uint32_t timestamp, uint8_t ManufactureIDByte1, uint8_t ManufactureIDByte2, uint8_t ManufactureIDByte3, 
+						uint8_t OEMData1, uint8_t OEMData2, uint8_t OEMData3,
+						uint8_t OEMData4 , uint8_t OEMData5, uint8_t OEMData6)
+{
+	std::string ipmiRaw;
+	redfish_hooks::OEMTsSELData selData= {
+							.recordType = recordType,
+							.ManufactureIDByte1 = ManufactureIDByte1,
+							.ManufactureIDByte2 = ManufactureIDByte2,
+							.ManufactureIDByte3 = ManufactureIDByte3,
+							.OEMData1 = OEMData1,
+							.OEMData2 = OEMData2,
+							.OEMData3 = OEMData3,
+							.OEMData4 = OEMData4,
+							.OEMData5 = OEMData5,
+							.OEMData6 = OEMData6};
+
+	return redfish_hooks::startOEMTsRedfishHook(selData, ipmiRaw);
+
+}
+
+bool checkOEMRedfishHooks(uint16_t recordID, uint8_t recordType, 
+						uint8_t OEMData1, uint8_t OEMData2, uint8_t OEMData3,
+						uint8_t OEMData4 , uint8_t OEMData5, uint8_t OEMData6,
+						uint8_t OEMData7 , uint8_t OEMData8, uint8_t OEMData9,
+						uint8_t OEMData10 , uint8_t OEMData11, uint8_t OEMData12,
+						uint8_t OEMData13 )
+{
+	std::string ipmiRaw;
+	redfish_hooks::OEMSELData selData= {
+							recordType = recordType,
+							.OEMData1 = OEMData1,
+							.OEMData2 = OEMData2,
+							.OEMData3 = OEMData3,
+							.OEMData4 = OEMData4,
+							.OEMData5 = OEMData5,
+							.OEMData6 = OEMData6,
+							.OEMData7 = OEMData7,
+							.OEMData8 = OEMData8,
+							.OEMData9 = OEMData9,
+							.OEMData10 = OEMData10,
+							.OEMData11 = OEMData11,
+							.OEMData12 = OEMData12,
+							.OEMData13 = OEMData13};
+
+	return redfish_hooks::startOEMRedfishHook(selData, ipmiRaw);
+
+}
 
 bool checkRedfishHooks(uint16_t recordID, uint8_t recordType,
                        uint32_t timestamp, uint16_t generatorID, uint8_t evmRev,
@@ -1563,11 +1641,11 @@
 
     // First check that this is a system event record type since that
     // determines the definition of the rest of the data
-    if (recordType != ipmi::sel::systemEvent)
+	/*if (recordType != ipmi::sel::systemEvent)
     {
-        // OEM record type, so let it go to the SEL
+        //OEM record type, so let it go to the SEL
         return redfish_hooks::defaultMessageHook(ipmiRaw);
-    }
+    }*/
 
     // Extract the SEL data for the hook
     redfish_hooks::SELData selData = {.generatorID = generatorID,

diff -Naur a/src/storagecommands.cpp b/src/storagecommands.cpp
--- a/src/storagecommands.cpp	2021-04-25 04:20:58.240501547 -0400
+++ b/src/storagecommands.cpp	2021-04-27 03:17:05.437829893 -0400
@@ -53,7 +53,7 @@
 static const std::filesystem::path selLogDir = "/var/sellog";
 static const std::string redfishLogFilename = "redfish";
 
-static int getFileTimestamp(const std::filesystem::path& file)
+static int getFileTimestamp(const std::string& file)
 {
     struct stat st;
 
@@ -744,7 +744,38 @@
     return IPMI_CC_OK;
 }
 
-static bool getSELLogFiles(std::vector<std::filesystem::path>& selLogFiles, int* fileindex)
+bool customsort(string s1, string s2)
+{
+	int i , j;
+	size_t pos1, pos2;
+	
+	pos1 = s1.find(logfileformat);
+	pos2 = s2.find(logfileformat);
+	if (pos1 != std::string::npos)
+	{
+		s1.erase(pos1,logfileformat.length());
+		i=std::stoi(s1);
+	}
+	else
+	{
+		i=0;
+	}
+	if (pos2 != std::string::npos)
+	{
+		s2.erase(pos2,logfileformat.length());
+		j=std::stoi(s2);
+	}
+	else
+	{
+		j=0;
+	}
+	if ( i==j)
+		return i > j;
+	else
+		return i < j;
+}
+
+static bool getSELLogFiles(std::vector<std::string>& selLogFiles, int* fileindex)
 {
     // Loop through the directory looking for ipmi_sel log files
     for (const std::filesystem::directory_entry& dirEnt :
@@ -762,7 +793,7 @@
     // As the log files rotate, they are appended with a ".#" that is higher for
     // the older logs. Since we don't expect more than 10 log files, we
     // can just sort the list to get them in order from newest to oldest
-    std::sort(selLogFiles.begin(), selLogFiles.end());
+    std::sort(selLogFiles.begin(), selLogFiles.end(),customsort);
 
     return !selLogFiles.empty();
 }
@@ -770,7 +801,7 @@
 static int countSELEntries()
 {
     // Get the list of ipmi_sel log files
-    std::vector<std::filesystem::path> selLogFiles;
+    std::vector<std::string> selLogFiles;
 	int fileindex=0;
     if (!getSELLogFiles(selLogFiles,&fileindex))
     {
@@ -778,7 +809,7 @@
     }
     int numSELEntries = 0;
     // Loop through each log file and count the number of logs
-    for (const std::filesystem::path& file : selLogFiles)
+    for (const std::string& file : selLogFiles)
     {
         std::ifstream logStream(file);
         if (!logStream.is_open())
@@ -796,7 +827,7 @@
 }
 
 static bool findSELEntry(const int recordID,
-                         const std::vector<std::filesystem::path>& selLogFiles,
+                         const std::vector<std::string>& selLogFiles,
                          std::string& entry)
 {
     // Record ID is the first entry field following the timestamp. It is
@@ -808,7 +839,7 @@
     std::string search = " " + res + ",";
 	int linecount=0; 
     // Loop through the ipmi_sel log entries
-    for (const std::filesystem::path& file : selLogFiles)
+    for (const std::string& file : selLogFiles)
     {
         std::ifstream logStream(file);
         if (!logStream.is_open())
@@ -831,7 +862,7 @@
 
 static uint16_t initializeRecordId(void)
 {
-    std::vector<std::filesystem::path> selLogFiles;
+    std::vector<std::string> selLogFiles;
 	int fileindex=0;
     if (!getSELLogFiles(selLogFiles,&fileindex))
     {
@@ -893,7 +924,7 @@
 
 static uint16_t
     getNextRecordID(const uint16_t recordID,
-                    const std::vector<std::filesystem::path>& selLogFiles)
+                    const std::vector<std::string>& selLogFiles)
 {
     uint16_t nextRecordID = recordID + 1;
     std::string entry;
@@ -955,18 +986,18 @@
 
 /* Compare the latest timestamp of the file with given index and 
 	return 1 if file is modified and 0 if there is no change */
-static int CheckLatestTimestamp(int index)
+static int CheckLatestTimestamp()
 {
 	struct stat st;
 	unsigned long timediff;
 	unsigned long newmod_time;
-	stat(SELInfoPtr[index]->FileName, &st);
+	stat(SelInfo.FileName, &st);
 	newmod_time = st.st_mtime;
 	
-	timediff = newmod_time - SELInfoPtr[index]->mod_time;
+	timediff = newmod_time - SelInfo.mod_time;
 	if (timediff)
 	{
-		SELInfoPtr[index]->mod_time = newmod_time;
+		SelInfo.mod_time = newmod_time;
 		return 1;
 	}
 	else
@@ -976,178 +1007,210 @@
 
 static int CheckandLoadSELTable()
 {
-	std::vector<std::filesystem::path> selLogFiles;
-	int filecount=0,i=0,linecount=0,tempcount=0,j=0;
-	std::string databuf;
+	std::vector<std::string> selLogFiles;
+	int filecount=0,ret=0,linecount=0,tempcount=0,j=0,fileindex=0,i=0,tempindex=0;
 	std::string tempbuf;
+	std::string databuf;
+	size_t pos;
 	struct stat st; 
+	uint16_t ignorerecord =0;
+	int selindex[RECORDS_PER_FILE]={0};
+	//get the filecount
+	getSELLogFiles(selLogFiles,&filecount);
+	totalfiles=filecount;
 	
-	if (SELInfoPtr == NULL) //condition for very first read
+	if ( filecount == 0 )
+		return 0;
+	else
 	{
-		filecount=0;
-		getSELLogFiles(selLogFiles,&filecount);
-		totalfiles=filecount;
-	
-		/* Dynamically allocate memory based on the no of files*/
-		SELInfoPtr = (struct SELInfo_T **)malloc(filecount * sizeof(struct SELInfo_T *));
-		for ( i=0; i< totalfiles ; i++)
-			SELInfoPtr[i] = (struct SELInfo_T *)malloc(sizeof(struct SELInfo_T));
-		
-		/*Update the table with filename,timestamp, starting id, NoofEntries(last entry in file)*/
-		for ( i=filecount-1; j<filecount; i--)
+		if ( SelInfo.mod_time == 0 )
 		{
-			tempbuf=selLogFiles[i];
-			strcpy(SELInfoPtr[j]->FileName,tempbuf.c_str());
-			
-			std::ifstream logStream(SELInfoPtr[i]->FileName);
+			strcpy(SelInfo.FileName,selLogFiles[0].c_str());
+			stat(SelInfo.FileName, &st);
+			SelInfo.mod_time=st.st_mtime;
+			std::ifstream logStream(SelInfo.FileName);
 			if (!logStream.is_open())
 			{
 				std::cout << "Error opening file" << endl;
 			}
-			
-			stat(SELInfoPtr[j]->FileName, &st);
-			SELInfoPtr[j]->mod_time=st.st_mtime;
-			tempcount = linecount;
 			while (std::getline(logStream, databuf))
 				linecount++;
-			
-			
-			SELInfoPtr[j]->StartingID = tempcount;
-			SELInfoPtr[j]->SELEntries = linecount;
-			
-			j++;
+			SelInfo.SELEntries = linecount;
 			logStream.close();
-		}
-		
-		/*Linecount will have total number of records*/
-		totalSELEntries=linecount;
-		
-		return 0;
-	}
-	else 
-	{
-		int value_0=0, value_1=0;
-		filecount=0;
-		getSELLogFiles(selLogFiles,&filecount);
-		
-		/* Check for change in filecount and change in first and last file in the table with the files in directory*/
-		if ((totalfiles == filecount) && ((strcmp(SELInfoPtr[0]->FileName,selLogFiles[filecount-1].c_str()) == 0) && (strcmp(SELInfoPtr[filecount-1]->FileName,selLogFiles[0].c_str()) == 0)))
-		{
-			/* if files are same check timestamp for last two files*/
-			value_0 = CheckLatestTimestamp(filecount-1);
-			if (filecount > 1)
-				value_1 = CheckLatestTimestamp(filecount-2);
 			
-			if((value_0 == 1) && (value_1 ==1)) /*if both file timestamp are changed update the entire table*/
-			{	
-				/*Free the memory*/
-				for ( i=0; i< totalfiles ; i++)
-					free(SELInfoPtr[i]);
-				free ( SELInfoPtr);
-			
-				totalfiles=filecount;
-				
-				SELInfoPtr = (struct SELInfo_T **)malloc(filecount * sizeof(struct SELInfo_T *));
-				for ( i=0; i< filecount ; i++)
-					SELInfoPtr[i] = (struct SELInfo_T *)malloc(sizeof(struct SELInfo_T));
+			//Calculate Total SEL Entries
+			totalSELEntries = (filecount-1) * RECORDS_PER_FILE;
+			totalSELEntries = totalSELEntries + SelInfo.SELEntries;
 			
+			//Calcuate First and Last SEL ID
+			if (filecount > 1 )
+			{
 				
-				j=0;
-				for ( i=filecount-1; j < filecount ; i--)
+				tempbuf = selLogFiles[filecount-1];
+				pos = tempbuf.find(logfileformat);
+				if (pos != std::string::npos)
 				{
-					tempbuf=selLogFiles[i];
-					strcpy(SELInfoPtr[j]->FileName,tempbuf.c_str());
-					
-					std::ifstream FileStream(SELInfoPtr[j]->FileName);
-					if (!FileStream.is_open())
+					tempbuf.erase(pos,logfileformat.length());
+				}
+				fileindex=std::stoi(tempbuf);
+				if ( fileindex == MAX_FILE_INDEX)
+				{
+					MaxFlag =1;
+					totalSELEntries = totalSELEntries -2;
+					for ( i=1 ; i < filecount -1 ; i++)
 					{
-						std::cout << "Error opening file" << endl;
+						tempbuf.clear();
+						tempbuf = selLogFiles[i];
+						pos = tempbuf.find(logfileformat);
+						if (pos != std::string::npos)
+						{
+							tempbuf.erase(pos,logfileformat.length());
+						}
+						fileindex=std::stoi(tempbuf);
+						selindex[i]=fileindex; 
+						if (fileindex > OBMC_MAX_SEL_RECORDS/RECORDS_PER_FILE)						
+							break;
 					}
-					stat(SELInfoPtr[j]->FileName, &st);
-					SELInfoPtr[j]->mod_time=st.st_mtime;
-					tempcount = linecount;
-					while (std::getline(FileStream, databuf))
-						linecount++;
-				
-					SELInfoPtr[j]->StartingID = tempcount;
-					SELInfoPtr[j]->SELEntries = linecount;
+					FirstSelId = ((fileindex - 1 ) * RECORDS_PER_FILE) + 1;
+					tempcount = i-1;
+					LastSelId = (selindex[tempcount] * RECORDS_PER_FILE) + SelInfo.SELEntries;
+					
+					if (LastSelId == 0 )
+						LastSelId = maxRecordId;
+				}
+				else
+				{
+					MaxFlag = 0;
+					LastSelId = (fileindex * RECORDS_PER_FILE) + SelInfo.SELEntries;
+				}
 				
-					j++;
-					FileStream.close();
+				tempbuf.clear();
+				tempbuf = selLogFiles[1];
+				pos = tempbuf.find(logfileformat);
+				if (pos != std::string::npos)
+				{
+					tempbuf.erase(pos,logfileformat.length());
 				}
-				totalSELEntries=linecount;
-				std::cout << "totalSELEntries : " << totalSELEntries << endl;
-				return 0;
-			}
-			else if ((value_0 == 1 ) && (value_1 ==0)) /*if only last file timestamp is changed update only the last latest file*/
-			{
-				std::ifstream fileStream(SELInfoPtr[filecount-1]->FileName);
-				if (!fileStream.is_open())
+				fileindex=std::stoi(tempbuf);
+				if (MaxFlag != 1)
 				{
-					std::cout << "Error opening file" << endl;
+					FirstSelId = ((fileindex - 1 ) * RECORDS_PER_FILE) + 1;
 				}
-				stat(SELInfoPtr[filecount-1]->FileName, &st);
-				SELInfoPtr[filecount-1]->mod_time=st.st_mtime;
-				linecount=SELInfoPtr[filecount-1]->StartingID;
-				while (std::getline(fileStream, databuf))
-					linecount++;
-				SELInfoPtr[filecount-1]->SELEntries = linecount;
-				totalSELEntries = linecount;
-				std::cout << "Last file updated no of entries: " << linecount << endl;
-				fileStream.close();
-				return 0;
 			}
-			else /* if there is no change use the same table*/
+			else
 			{
-				return 0;
+				FirstSelId = 1;
+				LastSelId = SelInfo.SELEntries;
+			}
+			if ( totalSELEntries > OBMC_MAX_SEL_RECORDS)
+			{
+				ignorerecord = totalSELEntries - OBMC_MAX_SEL_RECORDS;
+				FirstSelId = ignorerecord + FirstSelId;
 			}
 			
-		}	
-		else /*if the filecount is changed i.e., when a new file is created update the entire table*/
+		}
+		else
 		{
-			/*Free the memory*/
-			for ( i=0; i< totalfiles ; i++)
-					free(SELInfoPtr[i]);
-				free ( SELInfoPtr);
-			
-				totalfiles=filecount;
-			
-				SELInfoPtr = (struct SELInfo_T **)malloc(filecount * sizeof(struct SELInfo_T *));
-				for ( i=0; i< filecount ; i++)
-					SELInfoPtr[i] = (struct SELInfo_T *)malloc(sizeof(struct SELInfo_T));
+			ret = CheckLatestTimestamp();
+			if ( ret == 1)
+			{
+				std::ifstream logStream(SelInfo.FileName);
+				if (!logStream.is_open())
+				{
+					std::cout << "Error opening file" << endl;
+				}
+				while (std::getline(logStream, databuf))
+					linecount++;
+				SelInfo.SELEntries = linecount;
+				logStream.close();
 			
-				j=0;
-				for ( i=filecount-1; j < filecount ; i--)
+				//Calculate Total SEL Entries
+				totalSELEntries = (filecount-1) * RECORDS_PER_FILE;
+				totalSELEntries = totalSELEntries + SelInfo.SELEntries;
+				//Calcuate First and Last SEL ID
+				if (filecount > 1 )
 				{
-					tempbuf=selLogFiles[i];
-					strcpy(SELInfoPtr[j]->FileName,tempbuf.c_str());
+				
+					tempbuf = selLogFiles[filecount-1];
+					pos = tempbuf.find(logfileformat);
+					if (pos != std::string::npos)
+					{
+						tempbuf.erase(pos,logfileformat.length());
+					}
+					fileindex=std::stoi(tempbuf);
+					if ( fileindex == MAX_FILE_INDEX)
+					{
+						MaxFlag =1;
+						totalSELEntries = totalSELEntries -2;
+						tempbuf = selLogFiles[filecount-1];
+						pos = tempbuf.find(logfileformat);
+						if (pos != std::string::npos)
+						{
+							tempbuf.erase(pos,logfileformat.length());
+						}
+						fileindex=std::stoi(tempbuf);
+						
+						for ( i=1 ; i < filecount -1 ; i++)
+						{
+							tempbuf.clear();
+							tempbuf = selLogFiles[i];
+							pos = tempbuf.find(logfileformat);
+							if (pos != std::string::npos)
+							{
+								tempbuf.erase(pos,logfileformat.length());
+							}
+							fileindex=std::stoi(tempbuf); 
+							selindex[i]=fileindex;
+							if (fileindex > OBMC_MAX_SEL_RECORDS/RECORDS_PER_FILE)						
+								break;
+						}
+						FirstSelId = ((fileindex - 1 ) * RECORDS_PER_FILE) + 1;
+						tempcount = i-1;
+						LastSelId = (selindex[tempcount] * RECORDS_PER_FILE) + SelInfo.SELEntries;
 					
-					std::ifstream FileStream(SELInfoPtr[j]->FileName);
-					if (!FileStream.is_open())
+						if (LastSelId == 0 )
+							LastSelId = maxRecordId;
+						
+					}
+					else
 					{
-						std::cout << "Error opening file" << endl;
+						MaxFlag = 0;
+						LastSelId = (fileindex * RECORDS_PER_FILE) + SelInfo.SELEntries;
 					}
-					stat(SELInfoPtr[j]->FileName, &st);
-					SELInfoPtr[j]->mod_time=st.st_mtime;
-					tempcount = linecount;
-					while (std::getline(FileStream, databuf))
-						linecount++;
-				
-					SELInfoPtr[j]->StartingID = tempcount;
-					SELInfoPtr[j]->SELEntries = linecount;
 				
-					j++;
-					FileStream.close();
+					tempbuf.clear();
+					tempbuf = selLogFiles[1];
+					pos = tempbuf.find(logfileformat);
+					if (pos != std::string::npos)
+					{
+						tempbuf.erase(pos,logfileformat.length());
+					}
+					fileindex=std::stoi(tempbuf);
+					if (MaxFlag != 1 )
+					{
+						FirstSelId = ((fileindex - 1 ) * RECORDS_PER_FILE) + 1;
+					}
 				}
-				totalSELEntries=linecount;
+				else
+				{
+					FirstSelId = 1;
+					LastSelId = SelInfo.SELEntries;
+				}
+				if ( totalSELEntries > OBMC_MAX_SEL_RECORDS)
+				{
+					ignorerecord = totalSELEntries - OBMC_MAX_SEL_RECORDS;
+					FirstSelId = ignorerecord + FirstSelId;
+				}
+				
+			}
+			
+			else
 				return 0;
 		}
-	
 	}
-	return 0;
+	return 0;	
 }
 
-
 using systemEventType = std::tuple<
     uint32_t, // Timestamp
     uint16_t, // Generator ID
@@ -1187,36 +1250,154 @@
             return ipmi::responseInvalidReservationId();
         }
     }
+	
+	if (access(selrotatepath, F_OK) == 0) 
+	{
+		sleep(1);
+		if (access(selrotatepath, F_OK) == 0)
+			return ipmi::responseBusy();
+	}
+	
+	if (access(selbusyflag.c_str(), F_OK) == 0) 
+	{
+		sleep(1);
+		if (access(selbusyflag.c_str(), F_OK) == 0)
+			return ipmi::responseBusy();
+	}
+	
 	//Load the SEL table
 	CheckandLoadSELTable();
+	
+	if (totalfiles == 0)
+		return ipmi::responseRetBytesUnavailable();
+	
 	int i=0;
-	uint16_t ignorerecord =0;
+	int tempcount =0, tempindex=0;
+	std::string tempbuf;
+	
 	std::string targetEntry; //Record data from file
 	std::string databuf;
 	int linecount=0;
+	int changedrec;
 	size_t pos;
-	if ( totalSELEntries > MaxRecords)
+	uint16_t nextRecordID;
+	
+	if (targetID == ipmi::sel::lastEntry)
 	{
-		ignorerecord = totalSELEntries - MaxRecords;
+		targetID = LastSelId;
 	}
+		
 	
-	/*Change the requested ID(targetID) to the 0th record according to the table*/
-	int changedrec=ignorerecord+targetID;
+	if (MaxFlag == 0)
+	{
+		/*Change the requested ID(targetID) to the 0th record according to the table*/
+		if (targetID < FirstSelId )
+		{
+			if(targetID != ipmi::sel::firstEntry)
+			{
+				return ipmi::responseSensorInvalid();
+			}
+			else
+			{
+				targetID= FirstSelId;
+				changedrec=targetID;
+			}
+		}
+		else
+		{
+			changedrec=targetID;
+		}
+		if ( changedrec == LastSelId)
+			nextRecordID = 0xFFFF;
+		else
+			nextRecordID = targetID + 1;
+	}
+	else
+	{
+		if ( targetID < FirstSelId )
+		{
+			if ((targetID > LastSelId ) && (targetID != ipmi::sel::firstEntry))
+			{
+				return ipmi::responseSensorInvalid();
+			}
+			else
+			{
+				if (rotateflag == 0)
+				{
+					if (targetID == ipmi::sel::firstEntry)
+					{
+						targetID = FirstSelId;
+						rotateflag =1;
+					}
+				}
+				else
+				{
+					rotateflag = 0;
+				}
+				changedrec=targetID;
+			}
+		}
+		else
+		{
+			changedrec = targetID;
+		}
+		
+		if ( changedrec == LastSelId)
+		{
+			nextRecordID = 0xFFFF;
+		}
+		else if (changedrec == maxRecordId)
+		{
+			nextRecordID =1;
+			rotateflag =1;
+		}
+		else
+		{
+			nextRecordID = targetID +1;
+		}
+	}
+	
+	tempcount = changedrec/RECORDS_PER_FILE;
+	if ( changedrec % RECORDS_PER_FILE == 0)
+	{
+		tempindex = tempcount;
+	}
+	else
+	{
+		tempindex = tempcount + 1;
+	}
 	
-	/*iterate the table to find the SEL entry*/
-	for(i=0; i< totalfiles ; i++)
+	if ( tempindex > MAX_FILE_INDEX)
 	{
-		/*Check the changed record is present in the range of each file of the table*/
-		if (changedrec < SELInfoPtr[i]->SELEntries)
+		tempindex = tempindex - MAX_FILE_INDEX;
+	}
+	
+	linecount = ((tempindex - 1 ) * RECORDS_PER_FILE) + 1;
+
+		tempbuf.clear();
+		tempbuf = logfileformat + to_string(tempindex);
+		std::ifstream logStream(tempbuf.c_str());
+		if (!logStream.is_open())
 		{
-			std::ifstream logStream(SELInfoPtr[i]->FileName);
-			if (!logStream.is_open())
+			std::ifstream fileStream(SelInfo.FileName);
+			if (!fileStream.is_open())
 			{
 				std::cout << "Error opening file" << endl;
 			}
-			/*Initialize the linecount to starting id of the file*/
-			linecount=SELInfoPtr[i]->StartingID;
 			
+			while (std::getline(fileStream, databuf))
+			{
+				if (changedrec == linecount)
+				{
+					targetEntry = databuf;
+					break;
+				}
+				linecount=linecount+1;
+			}
+			fileStream.close();
+		}
+		else
+		{
 			while (std::getline(logStream, databuf))
 			{
 				if (changedrec == linecount)
@@ -1228,8 +1409,7 @@
 			}
 			logStream.close();
 		}
-	}
-	
+		
 	if(targetEntry.empty())
 	{
 		std::cout << "Target ID not found" << endl;
@@ -1267,27 +1447,65 @@
         timestamp = std::mktime(&timeStruct);
     }
 	
-	
-	uint8_t recordType = 0x02;
-	
-	uint16_t nextRecordID = targetID + 1;
-	
 	uint16_t recordID = targetID;
-    
+    unsigned int recordType;
 	uint8_t evmRev = 4;
 	uint16_t generatorID = 0;
     unsigned int sensorType = 0x00;
     unsigned int sensorNum = 0x00;
     unsigned int eventType = 0x00;
     bool eventDir = 0;
-    
-	std::array<uint8_t, intel_oem::ipmi::sel::systemEventSize> eventData{};
+    std::array<uint8_t, intel_oem::ipmi::sel::systemEventSize> eventData{};
+	
 	std::string redfishMessageID= "OpenBMC.0.1";
 	std::string DefaultStr="Ipmi";
 	std::string InvalidSELdata = targetEntryFields[0];
 	pos = InvalidSELdata.find(redfishMessageID);
 	if (pos != std::string::npos)
     {
+		std::string RecordType1= "OEMTs";
+		std::string RecordType2= "OEM";
+		std::string OEMData = targetEntryFields[1];
+		pos = OEMData.find(RecordType1) ; 
+		if (pos != std::string::npos)
+		{
+			int EntryFieldIndex=3;
+			std::string& recordTypeStr = targetEntryFields[2];
+			recordType = std::stoul(recordTypeStr, nullptr, 16);
+			std::string& OemTsEventdata=targetEntryFields[EntryFieldIndex];
+			std::array<uint8_t, intel_oem::ipmi::sel::oemTsEventSize> eventData2{};
+			for ( i=0; i < intel_oem::ipmi::sel::oemTsEventSize ; i++ )
+			{
+				OemTsEventdata= targetEntryFields[EntryFieldIndex];
+				eventData2[i] = std::stoul(OemTsEventdata, nullptr, 16);
+				EntryFieldIndex++;
+			}
+			phosphor::logging::log<phosphor::logging::level::INFO>("OEM Ts event 1");
+
+			return ipmi::responseSuccess(nextRecordID, recordID, recordType,
+                                     oemTsEventType{timestamp, eventData2});
+        }
+		
+		pos = OEMData.find(RecordType2);
+		if (pos != std::string::npos)
+		{
+			int EntryFieldIndex=3;
+			std::string& recordTypeStr = targetEntryFields[2];
+			recordType = std::stoul(recordTypeStr, nullptr, 16);
+			std::string& OemEventdata = targetEntryFields[EntryFieldIndex];
+			std::array<uint8_t, intel_oem::ipmi::sel::oemEventSize> eventData3{};
+			for ( i=0; i < intel_oem::ipmi::sel::oemEventSize; i++)
+			{
+				OemEventdata= targetEntryFields[EntryFieldIndex];
+				eventData3[i] = std::stoul(OemEventdata, nullptr, 16);
+				EntryFieldIndex++;
+			}
+			phosphor::logging::log<phosphor::logging::level::INFO>("OEM Ts event 2");
+			return ipmi::responseSuccess(nextRecordID, recordID, recordType,
+                                     eventData3);
+        }		
+		
+		recordType = 0x02;
 		eventData[0]=0xFF;
 		eventData[1]=0xFF;
 		eventData[2]=0xFF;
@@ -1298,6 +1516,7 @@
                             sensorNum, eventType, eventDir, eventData});
 	}
 	
+	recordType = 0x02;
     std::string& sensorTypeStr = targetEntryFields[0];
     std::string& sensorNumStr = targetEntryFields[1];
     std::string& eventTypeStr = targetEntryFields[2];
@@ -1469,10 +1688,37 @@
 
     // Send this request to the Redfish hooks to log it as a Redfish message
     // instead.  There is no need to add it to the SEL, so just return success.
-    std::cout << "In ipmiStorageAddSELEntry send req to checkRedfishHooks" << endl;
-    intel_oem::ipmi::sel::checkRedfishHooks(
-        recordID, recordType, timestamp, generatorID, evmRev, sensorType,
-        sensorNum, eventType, eventData1, eventData2, eventData3);
+	if (recordType == intel_oem::ipmi::sel::systemEvent )
+	{
+		intel_oem::ipmi::sel::checkRedfishHooks(
+	        recordID, recordType, timestamp, generatorID, evmRev, sensorType,
+        	sensorNum, eventType, eventData1, eventData2, eventData3);
+	}
+	else if (recordType >= intel_oem::ipmi::sel::oemTsEventFirst &&
+             recordType <= intel_oem::ipmi::sel::oemTsEventLast)
+	{
+		uint8_t ManufactureID1 = generatorID;
+		uint8_t ManufactureID2 = generatorID >> 8;
+		uint8_t ManufactureID3 = evmRev;
+		intel_oem::ipmi::sel::checkOEMTsRedfishHooks(
+			recordID, recordType, timestamp, ManufactureID1 , ManufactureID2, ManufactureID3,
+			sensorType, sensorNum, eventType, eventData1, eventData2, eventData3);
+	}
+	
+	else if (recordType >= intel_oem::ipmi::sel::oemEventFirst &&
+			recordType <= intel_oem::ipmi::sel::oemEventLast)
+	{
+		uint8_t OEMData1 = timestamp;
+		uint8_t OEMData2 = timestamp >> 8;
+		uint8_t OEMData3 = timestamp >> 16;
+		uint8_t OEMData4 = timestamp >> 24;
+		uint8_t OEMData5 = generatorID ;
+		uint8_t OEMData6 = generatorID >> 8;
+		intel_oem::ipmi::sel::checkOEMRedfishHooks(recordID, recordType, OEMData1, OEMData2, OEMData3, OEMData4, OEMData5, OEMData6, evmRev, sensorType, sensorNum, eventType, eventData1, eventData2, eventData3);
+	}
+
+	else
+		return ipmi::responseInvalidFieldRequest();
 
     uint16_t responseID = 0xFFFF;
     return ipmi::responseSuccess(responseID);
@@ -1580,44 +1826,25 @@
 
     // Save the erase time
     intel_oem::ipmi::sel::erase_time::save();
+	std::ofstream FlagStream;
+	FlagStream.open(selbusyflag.c_str(), ios::out);
+	FlagStream.close();
+	
 	int fileindex=0;
     // Clear the SEL by deleting the log files
-    std::vector<std::filesystem::path> selLogFiles;
+    std::vector<std::string> selLogFiles;
     if (getSELLogFiles(selLogFiles,&fileindex))
     {
-        for (const std::filesystem::path& file : selLogFiles)
+        for (const std::string& file : selLogFiles)
         {
             std::error_code ec;
-            std::filesystem::remove(file, ec);
+            std::filesystem::remove(file.c_str(), ec);
         }
     }
-
-
+	std::error_code ec;
+	std::filesystem::remove(selbusyflag.c_str(), ec);
     // Clear the SEL by deleting the log files
-    //std::vector<std::filesystem::path> redfishLogFiles;
-    /*if (getRedfishLogFiles(redfishLogFiles))
-    {
-        for (const std::filesystem::path& file : redfishLogFiles)
-        {
-            std::error_code ec;
-            std::filesystem::remove(file, ec);
-         }
-     }*/
 
-    // Reload rsyslog so it knows to start new log files
-    std::shared_ptr<sdbusplus::asio::connection> dbus = getSdBus();
-    sdbusplus::message::message rsyslogReload = dbus->new_method_call(
-        "org.freedesktop.systemd1", "/org/freedesktop/systemd1",
-        "org.freedesktop.systemd1.Manager", "ReloadUnit");
-    rsyslogReload.append("rsyslog.service", "replace");
-    try
-    {
-        sdbusplus::message::message reloadResponse = dbus->call(rsyslogReload);
-    }
-    catch (sdbusplus::exception_t& e)
-    {
-        phosphor::logging::log<phosphor::logging::level::ERR>(e.what());
-    }
 
     genevent();
 
@@ -1649,7 +1876,7 @@
     phosphor::logging::log<phosphor::logging::level::INFO>(
         "deleteSELEntry intel");
 
-    std::vector<std::filesystem::path> selLogFiles;
+    std::vector<std::string> selLogFiles;
 	int fileindex=0;
     if (!getSELLogFiles(selLogFiles, &fileindex))
     {
