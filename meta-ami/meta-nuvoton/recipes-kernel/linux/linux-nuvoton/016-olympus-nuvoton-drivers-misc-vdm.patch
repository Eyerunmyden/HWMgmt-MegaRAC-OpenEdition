diff --git a/arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts b/arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts
old mode 100644
new mode 100755
index 4343a62a1..548a809a9
--- a/arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts
+++ b/arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts
@@ -28,7 +28,7 @@
 		udc8 = &udc8;
 		udc9 = &udc9;
 		emmc0 = &sdhci0;
-		i2c0 = &i2c0;
+		vdma = &vdma;
 		i2c1 = &i2c1;
 		i2c2 = &i2c2;
 		i2c3 = &i2c3;
@@ -243,6 +243,10 @@
 			status = "okay";
 		};
 
+		vdma: vdma@e0800000 {
+			status = "okay";
+		};
+
 		pcimbox: pcimbox@f0848000 {
 			status = "okay";
 		};
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
old mode 100644
new mode 100755
index 9b5f4d0f3..177f820ef
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -494,6 +494,12 @@ config NPCM7XX_JTAG_MASTER
 	help
 	  Control PSPI/GPIO to transmit jtag signals to support jtag master function.
 
+config NPCM7XX_PCI_VDM
+	tristate "NPCM7xx VDM on PCIe driver"
+	depends on (ARCH_NPCM7XX || COMPILE_TEST)
+	help
+	  Provide tool to read, write, poll BDF to support VDM function.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
@@ -509,4 +515,5 @@ source "drivers/misc/cxl/Kconfig"
 source "drivers/misc/ocxl/Kconfig"
 source "drivers/misc/cardreader/Kconfig"
 source "drivers/misc/habanalabs/Kconfig"
+source "drivers/misc/npcm-vdm/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/misc/npcm-vdm/CircularBuffer.c b/drivers/misc/npcm-vdm/CircularBuffer.c
new file mode 100755
index 000000000..641efe5d9
--- /dev/null
+++ b/drivers/misc/npcm-vdm/CircularBuffer.c
@@ -0,0 +1,128 @@
+/* CircularBuffer_t.c */
+#include <linux/version.h>
+#include <linux/types.h> /* size_t */
+#include "CircularBuffer.h"
+
+void cbInit(CircularBuffer_t *cb, uint32_t size, void *startOfBuffer ,
+		uint32_t elementSize,copy_func_t	fCopyOnWrite ,copy_func_t	fCopyOnRead)
+{
+    cb->size  = size; /* include empty elem */
+    cb->write_next_pos = 1;
+    cb->read_last_pos  = 0;
+    cb->elementSize=elementSize;
+    cb->startOfBuffer=startOfBuffer;
+    cb->fCopyOnRead=fCopyOnRead;
+    cb->fCopyOnWrite=fCopyOnWrite;
+}
+
+
+uint32_t cbIsFull(CircularBuffer_t *cb)
+{
+    return cb->write_next_pos == cb->read_last_pos;
+}
+
+uint32_t cbIsEmpty(CircularBuffer_t *cb)
+{
+    return  cb->write_next_pos == ( (cb->read_last_pos + 1 ) % cb->size );
+}
+
+
+uint32_t cbGetNextReadPos(CircularBuffer_t *cb)
+{
+    return  ( (cb->read_last_pos + 1 ) % cb->size );
+}
+
+
+uint32_t cbGetNumOfElements(CircularBuffer_t *cb)
+{
+	uint32_t numOfElements;
+	if(cb->write_next_pos > cb->read_last_pos)
+	{
+		numOfElements = cb->write_next_pos - cb->read_last_pos -1;
+	}
+	else
+	{
+        numOfElements = (cb->size + cb->write_next_pos) - cb->read_last_pos -1;
+	}
+	return  numOfElements;
+}
+
+/* Write an elements */
+uint32_t cbWrite(CircularBuffer_t *cb, void *buffer, uint32_t max_num_to_write )
+{
+	uint32_t num_to_write =0 ;
+	uint32_t num_was_written =0 ;
+	uint32_t read_last_pos;
+
+	read_last_pos=cb->read_last_pos;
+	while (max_num_to_write && (read_last_pos != cb->write_next_pos) ) // second test is for fullness of buffer
+	{
+
+		if(cb->write_next_pos > read_last_pos)
+		{
+			num_to_write = cb->size - cb->write_next_pos ;
+		}
+		else
+		{
+			num_to_write = read_last_pos - cb->write_next_pos ;
+		}
+
+
+		if(num_to_write > max_num_to_write)
+		{
+			num_to_write = max_num_to_write;
+		}
+
+		cb->fCopyOnWrite(((uint8_t*)cb->startOfBuffer) + (cb->write_next_pos * cb->elementSize),
+				 buffer, num_to_write * cb->elementSize);
+		buffer = ((uint8_t*)buffer) + num_to_write * cb->elementSize;
+		max_num_to_write -= num_to_write;
+		num_was_written += num_to_write;
+		cb->write_next_pos = (cb->write_next_pos + num_to_write ) % cb->size;
+	}
+    return num_was_written;
+}
+
+/* Read oldest element. */
+uint32_t cbRead(CircularBuffer_t *cb, void *buffer, uint32_t max_num_to_read  )
+{
+	uint32_t num_to_read = 0 ;
+	uint32_t startOfReadPos ;
+	uint32_t num_was_read =0 ;
+	uint32_t write_next_pos;
+
+	write_next_pos = cb->write_next_pos;
+	startOfReadPos=((cb->read_last_pos+1) % cb->size);
+	while (max_num_to_read && (write_next_pos != startOfReadPos) ) // second test is for emptiness of buffer
+	{
+
+		if(write_next_pos > startOfReadPos)
+		{
+			num_to_read = ( write_next_pos - startOfReadPos ) ;
+		}
+		else
+		{
+			num_to_read = (cb->size - startOfReadPos ) ;
+		}
+
+
+		if(max_num_to_read < num_to_read)
+		{
+			num_to_read = max_num_to_read;
+		}
+
+		cb->fCopyOnRead(buffer, ((uint8_t*)cb->startOfBuffer) + (startOfReadPos * cb->elementSize),
+				num_to_read * cb->elementSize);
+		buffer = ((uint8_t*)buffer) + num_to_read * cb->elementSize;
+		max_num_to_read -= num_to_read;
+		num_was_read += num_to_read;
+		cb->read_last_pos = startOfReadPos + num_to_read - 1;
+
+		startOfReadPos = ((cb->read_last_pos+1) % cb->size);
+
+	}
+
+    return num_was_read;
+}
+
+
diff --git a/drivers/misc/npcm-vdm/CircularBuffer.h b/drivers/misc/npcm-vdm/CircularBuffer.h
new file mode 100755
index 000000000..7356c4cc7
--- /dev/null
+++ b/drivers/misc/npcm-vdm/CircularBuffer.h
@@ -0,0 +1,34 @@
+/********************************************************
+ *
+ * file : CircularBuffer.h
+ *
+ *
+ ****************************************************/
+
+#ifndef _CircularBuffer_H_
+#define _CircularBuffer_H_
+
+typedef void *(*copy_func_t)(void *dest, const void *src ,size_t n);
+
+/* Circular buffer object */
+typedef struct {
+    uint32_t         size;   /* maximum number of elements           */
+    uint32_t         read_last_pos;  /* index of last read element              */
+    uint32_t         write_next_pos;    /* index at which to write new element  */
+    void			*startOfBuffer;
+    uint32_t		elementSize;
+    copy_func_t		fCopyOnWrite;
+    copy_func_t		fCopyOnRead;
+} CircularBuffer_t;
+
+void cbInit(CircularBuffer_t *cb, uint32_t size, void *startOfBuffer ,
+		uint32_t elementSize,copy_func_t	fCopyOnWrite ,copy_func_t	fCopyOnRead) ;
+uint32_t cbWrite(CircularBuffer_t *cb, void *buffer , uint32_t max_num_to_write );
+uint32_t cbRead(CircularBuffer_t *cb, void *buffer , uint32_t max_num_to_read );
+uint32_t cbGetNextReadPos(CircularBuffer_t *cb);
+uint32_t cbGetNumOfElements(CircularBuffer_t *cb);
+
+
+#else
+#pragma message( "warning : this header file had already been included" )
+#endif
diff --git a/drivers/misc/npcm-vdm/Kconfig b/drivers/misc/npcm-vdm/Kconfig
new file mode 100755
index 000000000..a2c3845ac
--- /dev/null
+++ b/drivers/misc/npcm-vdm/Kconfig
@@ -0,0 +1,16 @@
+#
+# NPCMX50 MISC drivers
+#
+menu "Nuvoton Miscellaneous optional drivers"
+
+config NPCM_VDM
+	tristate "support npcmx50 VDM on PCIe"
+	depends on ARCH_NPCM7XX
+	default y
+	help
+	  Say Y here if you want ioctl npcmx50 VDM on PCIe.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called npcmx50_vdm.
+
+endmenu
diff --git a/drivers/misc/npcm-vdm/Makefile b/drivers/misc/npcm-vdm/Makefile
new file mode 100755
index 000000000..fcbf4edbe
--- /dev/null
+++ b/drivers/misc/npcm-vdm/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for Nuvoton Miscellaneous optional drivers
+#
+npcmx50_vdm-y := vdm_module.o vdm_common.o CircularBuffer.o ndelay-loop.o
+obj-$(CONFIG_NPCM_VDM)	         += npcmx50_vdm.o
diff --git a/drivers/misc/npcm-vdm/ndelay-loop.S b/drivers/misc/npcm-vdm/ndelay-loop.S
new file mode 100755
index 000000000..c2838e663
--- /dev/null
+++ b/drivers/misc/npcm-vdm/ndelay-loop.S
@@ -0,0 +1,68 @@
+/*
+ *  linux/arch/arm/lib/delay.S
+ *
+ *  Copyright (C) 1995, 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/delay.h>
+		.text
+
+.LC0:		.word	loops_per_jiffy_for_ndelay
+.LC1:		.word	UDELAY_MULT
+
+/*
+ * r0  <= 2000
+ * lpj <= 0x01ffffff (max. 3355 bogomips)
+ * HZ  <= 1000
+ */
+
+ENTRY(__loop_nanodelay)
+		ldr	r2, .LC1
+		mul	r0, r2, r0
+ENTRY(__loop_const_nanodelay)			@ 0 <= r0 <= 0x7fffff06
+		mov	r1, #-1
+		ldr	r2, .LC0
+		ldr	r2, [r2]		@ max = 0x01ffffff
+		add	r0, r0, r1, lsr #32-14
+		mov	r0, r0, lsr #14		@ max = 0x0001ffff
+		add	r2, r2, r1, lsr #32-10
+		mov	r2, r2, lsr #10		@ max = 0x00007fff
+		mul	r0, r2, r0		@ max = 2^32-1
+		add	r0, r0, r1, lsr #32-6
+		movs	r0, r0, lsr #6
+		reteq	lr
+
+/*
+ * loops = r0 * HZ * loops_per_jiffy / 1000000
+ */
+		.align 3
+
+@ Delay routine
+ENTRY(__loop_delay_l)
+		subs	r0, r0, #1
+#if 0
+		retls	lr
+		subs	r0, r0, #1
+		retls	lr
+		subs	r0, r0, #1
+		retls	lr
+		subs	r0, r0, #1
+		retls	lr
+		subs	r0, r0, #1
+		retls	lr
+		subs	r0, r0, #1
+		retls	lr
+		subs	r0, r0, #1
+		retls	lr
+		subs	r0, r0, #1
+#endif
+		bhi	__loop_delay_l
+		ret	lr
+ENDPROC(__loop_nanodelay)
+ENDPROC(__loop_const_nanodelay)
+ENDPROC(__loop_delay_l)
diff --git a/drivers/misc/npcm-vdm/vdm_api.h b/drivers/misc/npcm-vdm/vdm_api.h
new file mode 100755
index 000000000..59afcc4ed
--- /dev/null
+++ b/drivers/misc/npcm-vdm/vdm_api.h
@@ -0,0 +1,56 @@
+/********************************************************
+ *
+ * file : vdm_common.h
+ *
+ *
+ ****************************************************/
+
+#ifndef _VDM_API_H_
+#define _VDM_API_H_
+
+#define  PCIe_HEADER_ROUTE_BY_ID			0x12
+#define  PCIe_HEADER_ROUTE_TO_RC			0x10
+#define  PCIe_HEADER_ROUTE_FROM_RC			0x13
+
+#define VDM_ERR_FIFO_OVERFLOW				0x00000001
+
+typedef enum
+{
+	VDMA_STATUS_NONE						=	0,
+	VDMA_STATUS_DATA_READY					=	1,
+	VDMA_STATUS_OVERFLOWED					=	2,
+	VDMA_STATUS_DATA_READY_WITH_OVERFLOWED	=	3
+} VDMA_STATUS_t;
+
+
+typedef enum
+{
+	VDM_RX_TIMEOUT_NONE=0,
+	VDM_RX_TIMEOUT_0u5,
+	VDM_RX_TIMEOUT_1u,
+	VDM_RX_TIMEOUT_2u,
+	VDM_RX_TIMEOUT_4u,
+	VDM_RX_TIMEOUT_8u,
+} VDM_RX_TIMEOUT_t;
+
+typedef void (*receive_packet_func_t)(uint16_t aBDF, uint32_t *data ,
+										uint32_t NumOfWords ,uint8_t isThisLastDataInPacket);
+
+
+extern int vdm_exit_common(void);
+extern int vdm_init_common(uint32_t *apVdma_rx_buff,uint32_t *apVdma_rx_buff_virt_addr,uint32_t buff_bytes_len);
+extern int vdm_SendMessage(uint8_t route_type, uint16_t aBDF,uint8_t  *apData,uint32_t aLength);
+
+extern VDMA_STATUS_t vdma_is_data_ready(void);
+extern void vdma_copy_packets_from_buffer_with_overflow(receive_packet_func_t receive_packet_func);
+extern void vdma_copy_packets_from_buffer(receive_packet_func_t receive_packet_func);
+extern uint8_t vdm_is_ready_for_write(void);
+extern uint8_t vdm_set_timeout(VDM_RX_TIMEOUT_t timeout);
+extern void vdm_reset(void);
+extern void vdm_disable_rx(void);
+extern void vdm_enable_rx(void);
+extern uint8_t vdm_is_in_reset(void) ;
+extern uint32_t vdm_get_errors(void);
+extern void vdm_clear_errors(uint32_t clear_errors_bitmap) ;
+
+#endif
diff --git a/drivers/misc/npcm-vdm/vdm_common.c b/drivers/misc/npcm-vdm/vdm_common.c
new file mode 100755
index 000000000..b622da52d
--- /dev/null
+++ b/drivers/misc/npcm-vdm/vdm_common.c
@@ -0,0 +1,598 @@
+/********************************************************
+ *
+ * file : vdm_common.c
+ *
+ *
+ ****************************************************/
+
+#include <linux/types.h> /* size_t */
+#include <linux/delay.h>
+#include <linux/version.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include "vdm_common.h"
+#include "vdm_api.h"
+#include "CircularBuffer.h"
+
+extern void __iomem *vdm_virt_addr;
+extern void __iomem *vdma_virt_addr;
+extern struct regmap *gcr_regmap;
+
+int read_reg_bit(int bit, void __iomem *reg)
+{
+	u32 readval = ioread32(reg);
+
+	return (readval & BIT(bit));
+}
+
+void set_reg_bit(int bit, void __iomem *reg)
+{
+	u32 readval = ioread32(reg);
+
+	iowrite32(readval | BIT(bit), reg);
+}
+
+void clear_reg_bit(int bit, void __iomem *reg)
+{
+	u32 readval = ioread32(reg);
+
+	iowrite32(readval & (~BIT(bit)), reg);
+}
+
+#define VDM_DO_NOT_FILTER_ANY_PACKET
+
+uint32_t vdma_rx_buff_size_int,*vdma_rx_buff,*vdma_rx_buff_virt_addr;
+static uint8_t ready_for_transmit=0;
+extern void nano_delay(uint32_t nsec);
+
+VDMA_STATUS_t vdma_is_data_ready(void)
+{
+	uint32_t regVal = ioread32(vdma_virt_addr + VDMA_ECTL_REG);
+	VDMA_STATUS_t retVal;
+	//clear flags :
+
+	if( regVal & ( 1 << VDMA_ECTL_REG_DRDY_BIT_POS ) )
+	{
+		regVal |= ( 1 << VDMA_ECTL_REG_DRDY_BIT_POS );
+		if( regVal & ( 1 << VDMA_ECTL_REG_HALT_BIT_POS ) )
+		{
+			regVal |= ( 1 << VDMA_ECTL_REG_HALT_BIT_POS );
+			retVal = VDMA_STATUS_DATA_READY_WITH_OVERFLOWED;
+		}
+		else
+		{
+			retVal = VDMA_STATUS_DATA_READY;
+		}
+	}
+	else
+	{
+		if( regVal & ( 1 << VDMA_ECTL_REG_HALT_BIT_POS ) )
+		{
+			regVal |= ( 1 << VDMA_ECTL_REG_HALT_BIT_POS );
+			retVal = VDMA_STATUS_OVERFLOWED;
+		}
+		else
+		{
+			retVal = VDMA_STATUS_NONE;
+		}
+
+	}
+
+	iowrite32(regVal, vdma_virt_addr + VDMA_ECTL_REG);
+
+	return retVal;
+}
+
+uint32_t get_buffer_state(uint32_t *pCurrBuffReadPos,uint32_t *pCurrBuffWritePos)
+{
+	uint32_t numOfElementsInBuf ;
+
+	*pCurrBuffWritePos =  (ioread32(vdma_virt_addr + VDMA_CDST_REG) - (uint32_t)vdma_rx_buff) >> 2; // we are working with uint32_t
+	*pCurrBuffReadPos =  	(ioread32(vdma_virt_addr + VDMA_ERDPNT_REG) - (uint32_t)vdma_rx_buff) >> 2; // we are working with uint32_t
+
+	if(*pCurrBuffWritePos >= *pCurrBuffReadPos)
+	{
+		numOfElementsInBuf=*pCurrBuffWritePos - *pCurrBuffReadPos;
+	}
+	else
+	{
+		numOfElementsInBuf=vdma_rx_buff_size_int - (*pCurrBuffReadPos - *pCurrBuffWritePos)  ;
+	}
+
+	return numOfElementsInBuf;
+}
+
+/* function : vdma_copy_packets_from_buffer
+ *
+ *
+ *
+ */
+void __vdma_copy_packets_from_buffer(receive_packet_func_t receive_packet_func , uint8_t bufferWasOverflowed)
+{
+	uint32_t numOfElementsInBuf ;
+	uint32_t testReadPos , lengthOfPacketLeft,lengthOfPacket;
+	uint32_t PCIeHeaderUINT32;
+	uint32_t num_of_items_to_read_from_buff ;
+	uint32_t currBuffReadPos,currBuffWritePos;
+	uint32_t BDF;
+
+
+//	PRINTF("<1>vdm: irq \n");
+//	PRINTF("<1>vdm: vdma_rx_buff addr=0x%x \n", (uint32_t)vdma_rx_buff );
+
+
+//	currBuffWritePos =  (ioread32(VDMA_CDST_REG) - (uint32_t)vdma_rx_buff) >> 2; // we are working with uint32_t
+//	currBuffReadPos =  	(ioread32(VDMA_ERDPNT_REG) - (uint32_t)vdma_rx_buff) >> 2; // we are working with uint32_t
+//
+//	if(currBuffWritePos >= currBuffReadPos)
+//	{
+//		numOfElementsInBuf=currBuffWritePos-currBuffReadPos;
+//	}
+//	else
+//	{
+//		numOfElementsInBuf=vdma_rx_buff_size_int - (currBuffReadPos - currBuffWritePos)  ;
+//	}
+
+	numOfElementsInBuf = get_buffer_state(&currBuffReadPos,&currBuffWritePos);
+
+#if 1
+
+	while (numOfElementsInBuf >= PCIe_MSG_HEADER_SIZE_INT)
+	{
+		int wasMisReception;
+		//PRINTF("<1>vdm: currBuffReadPos = 0x%x \n", (uint32_t)currBuffReadPos );
+
+		// check if find next vdm packet
+		lengthOfPacket = 0;
+		testReadPos=(currBuffReadPos + 2) % vdma_rx_buff_size_int; // third UINT32 in packet includes vdm number
+		PCIeHeaderUINT32=vdma_rx_buff_virt_addr[testReadPos];
+		wasMisReception=0 ;
+		while((PCIeHeaderUINT32 & VDM_VENDOR_ID_MASK_LSB_IN_U32) != VDM_VENDOR_ID_LSB_IN_U32)
+		{
+			if(0==wasMisReception)
+			{
+				pr_info("<1>vdm: rx err addr=0x%x \n", (uint32_t)vdma_rx_buff + (currBuffReadPos<<2));
+			}
+			wasMisReception=1;
+//			numOfElementsInBuf--;
+
+			currBuffReadPos = (currBuffReadPos+1) % vdma_rx_buff_size_int;
+			iowrite32((currBuffReadPos << 2) + (uint32_t)vdma_rx_buff, vdma_virt_addr + VDMA_ERDPNT_REG);
+
+			numOfElementsInBuf = get_buffer_state(&currBuffReadPos,&currBuffWritePos);
+
+			if(PCIe_MSG_HEADER_SIZE_INT > numOfElementsInBuf)
+			{
+				break; // buffer is less then header
+			}
+			testReadPos=(currBuffReadPos + 2) % vdma_rx_buff_size_int;
+			PCIeHeaderUINT32=vdma_rx_buff_virt_addr[testReadPos];
+		}
+
+//		if(wasMisReception)
+//		{
+//			PRINTF("<1>vdm: rx err \n");
+//		}
+
+		if(numOfElementsInBuf >= PCIe_MSG_HEADER_SIZE_INT) // packet was found
+		{
+			PCIeHeaderUINT32 = vdma_rx_buff_virt_addr[currBuffReadPos] ;// read first UINT32 in packet
+			if((PCIeHeaderUINT32 & PCIe_HEADER_FMT_FIELD_MASK) == PCIe_HEADER_FMT_MSG_NO_PAYLOAD)
+			{
+				lengthOfPacket=4;
+			}
+			else
+			{
+				lengthOfPacket =( (PCIeHeaderUINT32 >> 8) & 0x0300) + (PCIeHeaderUINT32  >> 24) + 4;// 4 for pcie header length
+			}
+
+			if( (0 == lengthOfPacket) || (MAX_PACKET_LENGTH < lengthOfPacket) ) //invalid packet length
+			{
+				currBuffReadPos = (currBuffReadPos+1) % vdma_rx_buff_size_int;
+			}
+			else
+			{
+				if(numOfElementsInBuf>=lengthOfPacket)
+				{
+					BDF=vdma_rx_buff_virt_addr[(currBuffReadPos + 1)  % vdma_rx_buff_size_int ] ;// read second UINT32 in packet
+					BDF=((BDF>>8) & 0xff) + ((BDF & 0xff)<<8);
+
+					lengthOfPacketLeft=lengthOfPacket;
+					while(lengthOfPacketLeft)
+					{
+						if(currBuffWritePos>=currBuffReadPos)
+						{
+							num_of_items_to_read_from_buff=currBuffWritePos-currBuffReadPos;
+						}
+						else
+						{
+							num_of_items_to_read_from_buff = vdma_rx_buff_size_int - currBuffReadPos ;
+						}
+
+						if (num_of_items_to_read_from_buff > lengthOfPacketLeft)
+						{
+							num_of_items_to_read_from_buff = lengthOfPacketLeft;
+						}
+
+						lengthOfPacketLeft -= num_of_items_to_read_from_buff;
+
+						receive_packet_func(BDF , &vdma_rx_buff_virt_addr[currBuffReadPos] ,
+								num_of_items_to_read_from_buff, (0 == lengthOfPacketLeft) ? 1 : 0);
+
+						currBuffReadPos = (currBuffReadPos + num_of_items_to_read_from_buff) % vdma_rx_buff_size_int;
+
+					}
+	//				numOfElementsInBuf -= lengthOfPacket;
+				}
+				else
+				{
+					break; // no full packet found
+				}
+			}
+
+			iowrite32((currBuffReadPos << 2) + (uint32_t)vdma_rx_buff, vdma_virt_addr + VDMA_ERDPNT_REG);
+			numOfElementsInBuf = get_buffer_state(&currBuffReadPos,&currBuffWritePos);
+
+		}//while (numOfElementsInBuf >= PCIe_MSG_HEADER_SIZE_BYTES)
+	}
+#endif
+
+	// reset buffer
+	if(bufferWasOverflowed)
+	{
+		vdm_init_common(vdma_rx_buff , vdma_rx_buff_virt_addr , vdma_rx_buff_size_int * sizeof(uint32_t) );
+	}
+}
+
+void vdma_copy_packets_from_buffer(receive_packet_func_t receive_packet_func )
+{
+	__vdma_copy_packets_from_buffer(receive_packet_func,0);
+}
+
+void vdma_copy_packets_from_buffer_with_overflow(receive_packet_func_t receive_packet_func )
+{
+	__vdma_copy_packets_from_buffer(receive_packet_func,1);
+}
+
+int vdm_SendMessage(uint8_t route_type, uint16_t aBDF,uint8_t  *apData,uint32_t aLength)
+{
+	uint32_t 	i,txData;
+	uint8_t     idx;
+	uint8_t 	tag,paddingBytesNum;
+	uint8_t 	currLength;
+	uint32_t pci_message_header[4]={0};
+
+	ready_for_transmit=0;
+
+	pci_message_header[0]=
+			// ( ( ((1) << 5)+ ( (0x13/*1 0011 (broadcasting) */) << 0)) << 0) + // fmt + type . filled dynamically
+			( ( ( PCIe_TC0 << 4)+  (PCIe_NO_IDO << 2) +  	// TC + atr[2]
+					(PCIe_NO_TH << 0) ) << 8   ) + 			// TH
+			( ( (PCIe_NO_TD << 7) + (PCIe_NO_EP << 6) +     // TD  + EP
+					(PCIe_NO_RLX_ORDER_NO_SNOOP << 4) +     // atr[1,0]
+					(PCIe_NO_AT << 2)  ) << 16); 			// AT
+			//+ ( (0) << 24) ;// length . filled dynamically
+
+	pci_message_header[1]=
+			( (0) << 0) + //  request ID filled automatically by HW
+			( ( PCIe_TAG ) << 8) + // defult tag
+			( (PCIe_MSG_VDM_TYPE1) << 24 ) ;//message code (vd type1)
+
+
+	pci_message_header[2]=
+			// ( (0) << 0) + // bus_num (reserved in broadcasting) . filled dynamically
+			// ( ( (0 << 3) + (0 << 0) ) << 8) + // dev_num + func_num (reserved in broadcasting) . filled dynamically
+			( ( (VDM_VENDOR_ID >> 8) & 0xff) << 16) +// vendor id msb
+			( ( VDM_VENDOR_ID & 0xff ) << 24 ) ;// vendor id lsb
+
+//	PRINTF("<1>vdm:vdm_SendMessage \n"  );
+
+	// data will be split by PCIe_MAX_PAYLOAD_SIZE_BYTES
+	while(aLength)
+	{
+		if(aLength>PCIe_MAX_PAYLOAD_SIZE_BYTES)
+		{
+			currLength=PCIe_MAX_PAYLOAD_SIZE_BYTES;
+		}
+		else
+		{
+			currLength=aLength;
+		}
+		aLength-=currLength;
+
+		paddingBytesNum =  ( currLength % 4);
+		if ( 0 != paddingBytesNum )
+		{
+			paddingBytesNum = 4 - paddingBytesNum;
+		}
+
+		/*********** fill first U32 of TLP :  ***************/
+		pci_message_header[0] &= (~PCIe_HEADER_FMT_FIELD_MASK);
+		pci_message_header[0] &= (~PCIe_HEADER_LENGTH_FIELD_MASK);
+		if(currLength > 4)
+		{
+			pci_message_header[0] |= PCIe_HEADER_FMT_MSG_WITH_PAYLOAD;
+			pci_message_header[0] |= ((    ((currLength-1)/4) & 0xff) << 24);
+			pci_message_header[0] |= ( ((  ((currLength-1)/4) >> 8) & 0x3) << 16);
+		}
+		else
+		{
+			pci_message_header[0] |= PCIe_HEADER_FMT_MSG_NO_PAYLOAD;
+		}
+
+		/* route_type icludes tlp type and route mechanism*/
+		pci_message_header[0] &= (~PCIe_HEADER_ROUTE_FIELD_MASK);
+		pci_message_header[0] |= route_type;
+
+		pci_message_header[0] &= (~PCIe_HEADER_ATTR_MASK);
+		pci_message_header[0] |= PCIe_HEADER_ATTR_TEST;
+
+
+		/*********** fill second U32 of TLP :  ***************/
+		pci_message_header[1] &= (~PCIe_HEADER_TAG_FIELD_MASK);
+		tag = (paddingBytesNum & 3 ) << 4 ;
+		pci_message_header[1] |= (tag << 16);
+
+
+		/*********** fill third U32 of TLP :  ***************/
+		pci_message_header[2] &= (~PCIe_HEADER_DEST_BDF_FIELD_MASK);
+
+		if(PCIe_HEADER_ROUTE_BY_ID == route_type)
+		{
+			pci_message_header[2] |=
+					( ( (aBDF >> 8) & 0xff) ) +
+					( ( aBDF & 0xff ) << 8 ) ;
+		}
+
+		iowrite32(pci_message_header[0], vdm_virt_addr + VDM_TXF_REG);
+		iowrite32(pci_message_header[1], vdm_virt_addr + VDM_TXF_REG);
+		iowrite32(pci_message_header[2], vdm_virt_addr + VDM_TXF_REG);
+
+		while(currLength >3 )
+		{
+			txData=(apData[3]<<24) + (apData[2]<<16) + (apData[1]<<8) + (apData[0]) ;
+			iowrite32(txData, vdm_virt_addr + VDM_TXF_REG);
+			apData+=4;
+			currLength-=4;
+		}
+
+
+		txData=0;
+        idx=0;
+		while(currLength)
+		{
+            /*
+			txData |=*apData ;
+			apData++;
+			currLength--;
+			txData = txData << 8;
+            */
+            /*
+            txData |= (*apData << ((3 - currLength)*8));
+            apData++;
+            currLength--;
+            */
+
+            txData |= (*apData << idx*8);
+            idx++;
+            apData++;
+            currLength--;
+		}
+		//paddingBytesNum--;
+		//txData = txData << (paddingBytesNum*8);
+		iowrite32(txData, vdm_virt_addr + VDM_TXF_REG);
+
+
+        //Check if VDM Module is Enabled Before TX START
+        if(read_reg_bit(VDM_CNT_REG_VDM_ENABLE_BIT_POS, vdm_virt_addr + VDM_CNT_REG))
+            set_reg_bit(VDM_CNT_REG_START_TX_BIT, vdm_virt_addr + VDM_CNT_REG);
+
+//		PRINTF("<1>vdm: pci_message_header[0] = 0x%X \n",pci_message_header[0] );
+//		PRINTF("<1>vdm: pci_message_header[1] = 0x%X \n",pci_message_header[1] );
+//		PRINTF("<1>vdm: pci_message_header[2] = 0x%X \n",pci_message_header[2] );
+//		PRINTF("<1>vdm:txData = 0x%X \n",txData );
+//
+//		PRINTF("<1>vdm: status reg 0x%X= 0x%X \n",VDM_STAT_REG_ADDR , ioread32(VDM_STAT_REG) );
+//		PRINTF("<1>vdm: cont reg 0x%X = 0x%X \n",VDM_CNT_REG_ADDR,ioread32(VDM_CNT_REG) );
+
+
+		// test VDM_CNT_REG_VDM_ENABLE_BIT_POS to see that PCIe bus was not reset
+		for (i=0 ; i< SEND_TIMEOUT; i++)
+		{
+			if((read_reg_bit(VDM_TX_DONE_BIT_POS, vdm_virt_addr + VDM_STAT_REG) == 1) || vdm_is_in_reset())
+				break;
+			else
+				nano_delay(100);
+
+		}
+
+		iowrite32(1 << VDM_TX_DONE_BIT_POS, vdm_virt_addr + VDM_STAT_REG);// clear status
+		ready_for_transmit =1;
+
+		if((SEND_TIMEOUT == i) || vdm_is_in_reset())
+		{
+			return -EIO;
+		}
+
+	}
+
+	return 0;
+}
+
+uint8_t vdm_is_in_reset(void)
+{
+	return (0 == read_reg_bit(VDM_CNT_REG_VDM_ENABLE_BIT_POS, vdm_virt_addr + VDM_CNT_REG)) ? 1 : 0;
+}
+
+void vdm_reset(void)
+{
+	clear_reg_bit(VDM_ENABLE_FIELD_POS, vdm_virt_addr + VDM_CNT_REG);
+	set_reg_bit(VDM_ENABLE_FIELD_POS, vdm_virt_addr + VDM_CNT_REG);
+}
+
+uint8_t vdm_set_timeout(VDM_RX_TIMEOUT_t timeout)
+{
+	uint32_t regVal;
+	if(timeout > VDM_RX_TIMEOUT_8u)
+	{
+		return 1;
+	}
+
+	regVal = ioread32(vdm_virt_addr + VDM_CNT_REG) ;
+	regVal &= (~VDM_RX_TIMEOUT_FIELD_MASK);
+	regVal |= (timeout << VDM_RX_TIMEOUT_FIELD_POS);
+	return 0;
+}
+
+void vdm_disable_rx(void)
+{
+	uint32_t reg_val;
+	reg_val =  BIT(VDM_FLT_REG_FLT_ENABLE_BIT_POS) + 0xFFFF;  // filtering
+	iowrite32(reg_val, vdm_virt_addr + VDM_FLT_REG);
+	pr_debug("\n %s(): VDM_FLT_REG = 0x%08X\n", __FUNCTION__, reg_val);
+}
+
+void vdm_enable_rx(void)
+{
+	uint32_t reg_val;
+#ifdef VDM_DO_NOT_FILTER_ANY_PACKET
+	reg_val =  0;                                                       // no filtering
+#else
+	reg_val =  BIT(VDM_FLT_REG_FLT_ENABLE_BIT_POS) + VDM_VENDOR_ID; // filtering
+#endif
+	iowrite32(reg_val, vdm_virt_addr + VDM_FLT_REG);
+	pr_debug("\n %s(): VDM_FLT_REG = 0x%08X\n", __FUNCTION__, reg_val);
+}
+
+uint8_t vdm_is_ready_for_write(void)
+{
+	return ready_for_transmit  ;
+}
+
+uint32_t vdm_get_errors(void)
+{
+	uint32_t regVal = ioread32(vdm_virt_addr + VDM_STAT_REG);
+	uint32_t retVal = 0;
+	//clear flags :
+
+	if( regVal & ( 1 << VDM_RX_FULL_BIT_POS ) )
+		retVal |= VDM_ERR_FIFO_OVERFLOW;
+
+	return retVal;
+}
+
+void vdm_clear_errors(uint32_t clear_errors_bitmap)
+{
+	if(VDM_ERR_FIFO_OVERFLOW | clear_errors_bitmap)
+		clear_reg_bit(VDM_RX_FULL_BIT_POS, 
+			      vdm_virt_addr + VDM_STAT_REG);
+}
+
+/* function : vdm_init_common
+ *
+ *
+ *
+ */
+int vdm_init_common(uint32_t *apVdma_rx_buff,uint32_t *apVdma_rx_buff_virt_addr,uint32_t buff_bytes_len)
+{
+	uint32_t reg_val;
+	uint8_t buff_size_in_16kb;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,17,0)
+	unsigned long flags;
+#endif
+	vdma_rx_buff	=	apVdma_rx_buff;
+	vdma_rx_buff_virt_addr = apVdma_rx_buff_virt_addr;
+
+	buff_size_in_16kb =  (buff_bytes_len) / (16384); // calclulate available 16k blocks
+	if((0==buff_size_in_16kb) || (255<buff_size_in_16kb))
+	{
+		return 1;
+	}
+
+	vdma_rx_buff_size_int   = (buff_size_in_16kb * (16384))/sizeof(uint32_t);
+
+	regmap_update_bits(gcr_regmap, PHY_SELECT_FOR_PCIE_BRIDGE_REG,
+			   BIT(PHY_SELECT_FOR_PCIE_BRIDGE_FIELD_POS), 0x0);
+
+	/****** configure VDM Module *********/
+	/*************************************************/
+	reg_val = BIT(VDM_TX_DONE_BIT_POS) +  BIT(VDM_RX_DONE_BIT_POS) +  BIT(VDM_RX_FULL_BIT_POS);  // clear status
+	iowrite32(reg_val, vdm_virt_addr + VDM_STAT_REG);
+
+	//reset :
+	iowrite32(0x0, vdm_virt_addr + VDM_CNT_REG);// disable module
+	reg_val =  (VDM_RX_TIMEOUT_8u << VDM_RX_TIMEOUT_FIELD_POS) +
+			BIT(VDM_CNT_REG_VDM_ENABLE_BIT_POS);  //  (8us delay before packet drop) + enabe
+	iowrite32(reg_val, vdm_virt_addr + VDM_CNT_REG);
+	// end of reset
+
+#ifdef VDM_DO_NOT_FILTER_ANY_PACKET
+	reg_val =  0;                                                       // no filtering
+#else
+	reg_val =  BIT(VDM_FLT_REG_FLT_ENABLE_BIT_POS) + VDM_VENDOR_ID; // filtering
+#endif
+	iowrite32(reg_val, vdm_virt_addr + VDM_FLT_REG);
+	pr_debug("\n %s(): VDM_FLT_REG = 0x%08X\n", __FUNCTION__, reg_val);
+
+	reg_val =  BIT(VDM_INT_EN_REG_RX_INT_BIT_POS) ;  // enable rx int
+	iowrite32(reg_val, vdm_virt_addr + VDM_INT_EN_REG);
+
+	/****** configure VDMA Module *********/
+	/*************************************************/
+	iowrite32(0x00, vdma_virt_addr + VDMA_CNT_REG);// disable
+
+	iowrite32(PHYS_VDM_RXF_REG_ADDR, vdma_virt_addr + VDMA_SRCB_REG);// src_addr
+
+	iowrite32((uint32_t)apVdma_rx_buff, vdma_virt_addr + VDMA_DSTB_REG);// dst_addr
+
+	iowrite32(PHYS_VDM_STAT_REG_ADDR, vdma_virt_addr + VDMA_ESRCSZ_REG);	// size_addr
+	iowrite32((uint32_t)apVdma_rx_buff, vdma_virt_addr + VDMA_ERDPNT_REG);		// read pointer
+
+	//automatic clear vdmx rx done status bit
+	iowrite32(PHYS_VDM_STAT_REG_ADDR, vdma_virt_addr + VDMA_EST0AD_REG);			// address of clear bit
+//	iowrite32(VDMA_EST0MK_REG, BIT( VDM_RX_DONE_BIT_POS) );		// mask of bit
+	iowrite32(0xffffffff, vdma_virt_addr + VDMA_EST0MK_REG);		// mask of bit
+	iowrite32(BIT( VDM_RX_DONE_BIT_POS), vdma_virt_addr + VDMA_EST0DT_REG);		// data to write to masked bit
+
+	reg_val=BIT(VDMA_ECTL_REG_DRDY_EN_BIT_POS) + BIT( VDMA_ECTL_REG_DRDY_BIT_POS ) + // (ready int + clear rdy int)
+			BIT(VDMA_ECTL_REG_HALT_INT_EN_BIT_POS) + BIT( VDMA_ECTL_REG_HALT_BIT_POS ) + // (halt int + clear halt int)
+			(buff_size_in_16kb<<VDMA_ECTL_REG_BUFF_SIZE_POS)+ 								// ciclyc buffer size 16k*n
+			BIT(VDMA_ECTL_REG_RETRIGGER_IF_BUFF_NOT_EMPTY_BIT_POS) + 					//(Retrigger if Source Size not Zero )
+			BIT(VDMA_ECTL_REG_AUTO_STATUS_UPDATE_BIT_POS) + 							//(automatic update status register0)
+			(VDMA_SIZE_MODIFIER_BITS_16_23_USED << VDMA_ECTL_REG_SIZE_MODIFIER_POS)+		//    (size in bits 16-23)
+			BIT(VDMA_ECTL_REG_SIZE_CYCLIC_BUF_EN_BIT_POS);								// ciclyc buffer;
+	iowrite32(reg_val, vdma_virt_addr + VDMA_ECTL_REG);
+
+	reg_val= BIT(VDMA_CNT_REG_BUS_LOCK_BIT_POS)+  	// bus-lock
+			//BIT(VDMA_CNT_REG_BURST_BIT_POS)+ 		//  no 8-byte_burst
+			BIT(VDMA_CNT_REG_ENABLE_POS) ;  		//  enable
+
+	iowrite32(reg_val, vdma_virt_addr + VDMA_CNT_REG);
+
+	ready_for_transmit = 1;
+	return 0;
+}
+
+int vdm_exit_common(void)
+{
+	uint32_t prev_pointer = 0;
+	uint32_t curr_pointer = 1;
+	// stop retrigerring
+	clear_reg_bit(VDMA_ECTL_REG_RETRIGGER_IF_BUFF_NOT_EMPTY_BIT_POS,
+		      vdma_virt_addr + VDMA_ECTL_REG);
+
+	//wait till dma is not transferring data
+	while (prev_pointer != curr_pointer)
+	{
+		prev_pointer = curr_pointer;
+		mdelay(1);
+		curr_pointer = ioread32(vdma_virt_addr + VDMA_CDST_REG);
+	}
+
+	clear_reg_bit(VDMA_CNT_REG_ENABLE_POS, vdma_virt_addr + VDMA_CNT_REG);
+	clear_reg_bit(VDM_ENABLE_FIELD_POS, vdm_virt_addr + VDM_CNT_REG);
+
+	return 0;
+}
diff --git a/drivers/misc/npcm-vdm/vdm_common.h b/drivers/misc/npcm-vdm/vdm_common.h
new file mode 100755
index 000000000..fe890dfc8
--- /dev/null
+++ b/drivers/misc/npcm-vdm/vdm_common.h
@@ -0,0 +1,129 @@
+/********************************************************
+ *
+ * file : vdm_common.h
+ *
+ *
+ ****************************************************/
+
+#ifndef _VDM_COMMON_H_
+#define _VDM_COMMON_H_
+
+#define _1KB_ 1024
+#define _64KB_ (64*1024)
+
+/******** vdm module defines **************/
+#define PHY_SELECT_FOR_PCIE_BRIDGE_REG		0x64
+#define PHY_SELECT_FOR_PCIE_BRIDGE_FIELD_POS   (17)
+
+#define PHYS_VDM_STAT_REG_ADDR			0xE0800000
+#define VDM_STAT_REG_ADDR			0x00
+
+#define VDM_STAT_REG				VDM_STAT_REG_ADDR
+#define VDM_TX_DONE_BIT_POS 			0
+#define VDM_RX_DONE_BIT_POS 			1
+#define VDM_RX_FULL_BIT_POS 			2
+#define VDM_RXNDW_FIELD_POS 			16
+#define VDM_RXNDW_FIELD_MASK 			0xff0000
+
+#define VDM_INT_EN_REG				0x04
+#define VDM_INT_EN_REG_RX_INT_BIT_POS		1
+
+#define PHYS_VDM_RXF_REG_ADDR			0xE0800008
+#define VDM_RXF_REG_ADDR			0x08
+#define VDM_RXF_REG				VDM_RXF_REG_ADDR
+
+#define VDM_TXF_REG				0x0C
+
+#define VDM_CNT_REG_ADDR			0x10
+#define VDM_CNT_REG				VDM_CNT_REG_ADDR
+
+#define VDM_CNT_REG_START_TX_BIT		0
+#define VDM_CNT_REG_VDM_ENABLE_BIT_POS		1
+#define VDM_RX_TIMEOUT_FIELD_POS 		4
+#define VDM_RX_TIMEOUT_FIELD_MASK 		0x70
+#define VDM_ENABLE_FIELD_POS			1
+
+#define VDM_FLT_REG				0x14
+#define VDM_FLT_REG_FLT_ENABLE_BIT_POS		31
+
+/******** vdma module defines **************/
+#define VDMA_CNT_REG				0x00
+#define VDMA_CNT_REG_BUS_LOCK_BIT_POS		17
+#define VDMA_CNT_REG_BURST_BIT_POS		9
+#define VDMA_CNT_REG_ENABLE_POS			0
+
+
+#define VDMA_SRCB_REG				0x04
+#define VDMA_DSTB_REG				0x08
+#define VDMA_CDST_REG				0x14
+#define VDMA_ERDPNT_REG				0x48
+#define VDMA_ECTL_REG				0x40
+
+#define VDMA_ECTL_REG_DRDY_EN_BIT_POS		29
+#define VDMA_ECTL_REG_DRDY_BIT_POS		28
+#define VDMA_ECTL_REG_HALT_INT_EN_BIT_POS	25
+#define VDMA_ECTL_REG_HALT_BIT_POS		24
+#define VDMA_ECTL_REG_BUFF_SIZE_POS		16
+#define VDMA_ECTL_REG_RETRIGGER_IF_BUFF_NOT_EMPTY_BIT_POS	11
+#define VDMA_ECTL_REG_AUTO_STATUS_UPDATE_BIT_POS		9
+#define VDMA_ECTL_REG_SIZE_MODIFIER_POS				4
+#define VDMA_ECTL_REG_SIZE_CYCLIC_BUF_EN_BIT_POS		1
+
+#define VDMA_ESRCSZ_REG				0x44
+#define VDMA_EST0AD_REG				0x50
+#define VDMA_EST0MK_REG				0x54
+#define VDMA_EST0DT_REG				0x58
+
+#define PCIe_MAX_TX_BUFFER_SIZE		128
+#define PCIe_MSG_HEADER_SIZE_INT		(4)
+#define PCIe_MSG_HEADER_SIZE_WITHOUT_MCTP_INT	(3)
+#define PCIe_MAX_PAYLOAD_SIZE_BYTES  (PCIe_MAX_TX_BUFFER_SIZE-(PCIe_MSG_HEADER_SIZE_WITHOUT_MCTP_INT*4))
+
+//#define  VDM_VENDOR_ID     0xb41a
+#define  VDM_VENDOR_ID     0x1ab4
+//#define  VDM_VENDOR_ID_LSB_IN_U32     	0x1ab40000
+#define  VDM_VENDOR_ID_LSB_IN_U32     		( ((VDM_VENDOR_ID & 0xff)<<24) + ((VDM_VENDOR_ID & 0xff00)<<8))
+#define  VDM_VENDOR_ID_MASK_LSB_IN_U32    	0xffff0000
+
+#define  PCIe_HEADER_FMT_FIELD_MASK     	0x00000060
+#define  PCIe_HEADER_FMT_MSG_NO_PAYLOAD  	0x00000020
+#define  PCIe_HEADER_FMT_MSG_WITH_PAYLOAD  	0x00000060
+
+//ROUTE_FIELD icludes tlp type and route mechanism
+#define  PCIe_HEADER_ROUTE_FIELD_MASK     	0x0000001f
+
+#define  PCIe_HEADER_LENGTH_FIELD_MASK     	0xFF030000
+
+#define  PCIe_HEADER_ATTR_MASK  		0x00300000
+#define  PCIe_HEADER_ATTR_TEST  		0x00100000
+
+
+#define  PCIe_HEADER_DEST_BDF_FIELD_MASK	0x0000FFFF
+
+#define  PCIe_HEADER_TAG_FIELD_MASK		0x00FF0000
+
+#define  PCIe_TC0     			0x00
+#define  PCIe_NO_IDO    		0x00
+#define  PCIe_NO_TH    			0x00
+#define  PCIe_NO_TD    			0x00
+#define  PCIe_NO_EP    			0x00
+#define  PCIe_NO_RLX_ORDER_NO_SNOOP	0x00
+#define  PCIe_NO_AT			0x00
+#define  PCIe_TAG     			0x00
+#define  PCIe_MSG_VDM_TYPE1     	0x7f
+
+#define	MAX_PACKET_LENGTH		128
+#define SEND_TIMEOUT			100
+
+typedef enum
+{
+	VDMA_SIZE_MODIFIER_NONE=0,
+	VDMA_SIZE_MODIFIER_BITS_0_7_USED,
+	VDMA_SIZE_MODIFIER_BITS_8_15_USED,
+	VDMA_SIZE_MODIFIER_BITS_16_23_USED,
+	VDMA_SIZE_MODIFIER_BITS_24_31_USED,
+} VDMA_SIZE_MODIFIER_t;
+
+#else
+#pragma message( "warning : this header file had already been included" )
+#endif
diff --git a/drivers/misc/npcm-vdm/vdm_module.c b/drivers/misc/npcm-vdm/vdm_module.c
new file mode 100755
index 000000000..1cdcab95e
--- /dev/null
+++ b/drivers/misc/npcm-vdm/vdm_module.c
@@ -0,0 +1,1271 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/types.h> /* size_t */
+#include <linux/interrupt.h>
+#include <linux/version.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/workqueue.h>	/* We scheduale tasks here */
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/uaccess.h>
+#include <linux/sched/signal.h>
+#include "vdm_module.h"
+#include "vdm_api.h"
+#include "CircularBuffer.h"
+#include "vdm_common.h"
+#include <linux/delay.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+
+// VDM Debug Macros
+#define VDM_DEBUG_ENABLE            1
+#define VDM_DEBUG_DISABLE           0
+
+struct regmap *gcr_regmap;
+void __iomem *vdm_virt_addr;
+void __iomem *vdma_virt_addr;
+
+
+static const struct of_device_id vdm_dt_npcm750_match[] = {
+       { .compatible = "nuvoton,npcm750-vdm" },
+       { /*sentinel*/ },
+};
+
+#endif
+
+#define  AIC_GEN_MTCP   31
+#define _1KB_ 1024
+#define _64KB_ (64*1024)
+#define _128KB_ (128*1024)
+
+//#DEBUG
+
+static int majornum = 0;           /* default to dynamic major */
+module_param(majornum, int, 0);
+MODULE_PARM_DESC(majornum, "Major device number");
+
+//VDM debug varibles and module init
+static int vdm_debug_control = VDM_DEBUG_DISABLE;
+static int vdm_bdf_debug_flag = 0xFFFF;
+module_param_named(vdm_debug_enable, vdm_debug_control, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(vdm_debug_control, "This is used for enabling the debug logging for vdm driver");
+module_param_named(vdm_bdf_debug_filter,vdm_bdf_debug_flag, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(vdm_bdf_debug_flag, "This is used for enabling/disabling logs for a specific VDM BDF");
+
+// TODO: Avi: check if exist in BMC_HAL
+#define AIC_GEN				0x84
+#define AIC_GRSR			0x88
+
+#define AIC_GEN_REG			AIC_GEN
+#define AIC_GRSR_REG			AIC_GRSR
+
+#define DEVICE_NAME 	"vdm"
+
+#define VDMA_BUFF_BYTE_SIZE	(16*1024) //  buffer size in bytes
+
+#define RESET_POLL_TICK_mS	100
+#define VDM_STATUS_OPENED	0
+#define VDM_STATUS_CLOSED	1
+
+typedef struct my_struct {
+        struct list_head list;
+        uint16_t mBDF;
+        uint8_t *mprxBuffer;
+        uint8_t BDF_is_set;
+        uint32_t mprxBufferLength;
+        uint8_t *mptxBuffer;
+        uint32_t mptxBufferLength;
+        CircularBuffer_t circularBuffer;
+        uint32_t last_errors;
+        uint32_t dbg_counter;
+        wait_queue_head_t       in_data_available_wait;
+} vdm_instance_t;
+
+extern unsigned long loops_per_jiffy;
+unsigned long loops_per_jiffy_for_ndelay ;
+
+static uint32_t *vdma_buff;
+static uint32_t *vdma_buff_virt_addr;
+static uint32_t disable_TX=0;
+static uint8_t stop_reset_poll=0;
+static uint8_t vdm_status = VDM_STATUS_CLOSED;
+static uint8_t reset_detect_poll = 1;
+static uint8_t reset_detect_poll_is_running = 0;
+static int irq_count = 0;
+
+static struct tasklet_struct   vdm_tasklet;
+static struct tasklet_struct   vdm_tasklet_with_overflow;
+static spinlock_t lock;
+
+static dev_t vdm_dev;
+static struct cdev *vdm_cdev;
+static struct platform_device *vdm_pdev = NULL;
+static struct class *vdm_class;
+static struct device *vdm_sysfs_device;
+
+
+static LIST_HEAD(vdm_instances_list);
+
+static int dummy_vdma_dev;
+
+static vdm_instance_t *pVDM_Instance_Default = NULL ;
+
+static void vdm_tasklet_function( unsigned long data );
+static void vdm_tasklet_function_with_overflow( unsigned long data );
+
+static void reset_poll_routine(struct work_struct *irrelevant);
+static DECLARE_DELAYED_WORK(reset_poll_work, reset_poll_routine);
+static uint32_t vdm_data_for_platform;
+
+extern void __loop_nanodelay(unsigned long usecs);
+
+/*VDM DEBUG MACRO*/
+#define VDM_DEBUG_LOG(BDF, f, x...)                                                           \
+	if(vdm_debug_control && (BDF & vdm_bdf_debug_flag))                                   \
+            printk(KERN_DEBUG "%s():line %d: ox%X" f, __func__, __LINE__,BDF,## x);                   \
+
+/* function : ndelay
+ *
+ *
+ *
+ */
+void nano_delay(uint32_t nsec)
+{
+	__loop_nanodelay(nsec);
+}
+
+/* function : copy_to_user_wrapper
+ *
+ *
+ *
+ */
+static void *copy_to_user_wrapper(void *dest, const void *src, size_t n)
+{
+	uint32_t bytes_copied;
+	bytes_copied = copy_to_user(dest,src,n);
+	return dest;
+}
+
+/* function : reset_poll_routine
+ *
+ *
+ *
+ */
+static void reset_poll_routine(struct work_struct *irrelevant)
+{
+	unsigned long flags;
+	struct list_head *pList;
+	vdm_instance_t *pVDM_Instance;
+
+	spin_lock_irqsave(&lock,   flags);
+
+	reset_detect_poll_is_running = 0;
+
+	if (vdm_is_in_reset())
+    {
+//		pr_debug("%s : vdm reset detected\n",__FUNCTION__);
+    	// wake up all vdm_instances
+    	list_for_each(pList, &vdm_instances_list)
+    	{
+    		pVDM_Instance = list_entry(pList, vdm_instance_t, list);
+    		pVDM_Instance->last_errors |= PCIE_VDM_ERR_BUS_RESET_OCCURED;
+    		wake_up_interruptible(&pVDM_Instance->in_data_available_wait);
+    	}
+    }
+	else
+	{
+		/*
+		 * If we wants to stop task
+		 */
+		if ((stop_reset_poll == 0) && (0 == reset_detect_poll_is_running))
+		{
+			reset_detect_poll_is_running = 1;
+			schedule_delayed_work(&reset_poll_work, RESET_POLL_TICK_mS);
+		}
+	}
+	spin_unlock_irqrestore(&lock,   flags);
+}
+
+/* function : bdf_U16_to_bdf_arg
+ *
+ *
+ *
+ */
+static void bdf_U16_to_bdf_arg(uint16_t bdf_U16, bdf_arg_t *apBdf)
+{
+	apBdf->bus = ( bdf_U16 >> 8 ) & 0xff ;
+	apBdf->device = ( bdf_U16 >> 3 ) & 0x1f ;
+	apBdf->function = bdf_U16  & 0x07 ;
+}
+
+/* function : bdf_arg_to_bdf_U16
+ *
+ *
+ *
+ */
+static uint16_t bdf_arg_to_bdf_U16(bdf_arg_t *apBdf)
+{
+	return ( ((apBdf->bus & 0xff) << 8) + ((apBdf->device & 0x1f) << 3) + (apBdf->function & 7) ) ;
+}
+
+static int _vdm_open(void)
+{
+	if(VDM_STATUS_CLOSED == vdm_status)
+	{
+		if(vdm_init_common(vdma_buff, vdma_buff_virt_addr , VDMA_BUFF_BYTE_SIZE))
+			return -EINVAL;
+
+		/*-----------------------------------------------------------------------------------------------------*/
+		/* Init tasklets.                                                                                      */
+		/*-----------------------------------------------------------------------------------------------------*/
+		tasklet_init(&vdm_tasklet, vdm_tasklet_function, 0);
+		tasklet_init(&vdm_tasklet_with_overflow, vdm_tasklet_function_with_overflow, 0);
+
+		vdm_status = VDM_STATUS_OPENED;
+	}
+
+    return 0 ;
+}
+
+static void _vdm_close(void)
+{
+	struct list_head *pList;
+	vdm_instance_t *pVDM_Instance;
+
+	vdm_exit_common();
+	if(VDM_STATUS_OPENED == vdm_status)
+	{
+		tasklet_kill( &vdm_tasklet );
+		tasklet_kill( &vdm_tasklet_with_overflow );
+
+		// reinit vdm_instances
+		list_for_each(pList, &vdm_instances_list)
+		{
+			pVDM_Instance = list_entry(pList, vdm_instance_t, list);
+			cbInit(&pVDM_Instance->circularBuffer, (pVDM_Instance->mprxBufferLength/sizeof(uint32_t)) ,
+			            		pVDM_Instance->mprxBuffer , sizeof(uint32_t),memcpy,copy_to_user_wrapper);
+			pVDM_Instance->BDF_is_set = 0;
+		}
+
+		vdm_status = VDM_STATUS_CLOSED;
+	}
+}
+
+static ssize_t vdm_read(struct file *filp, char *buf, size_t count, loff_t *f_pos)
+{ 
+	long ret=0;
+	unsigned long flags;
+	uint32_t num_of_items_to_read_from_buff =0 ;//, StartPosToRead;
+        uint16_t tBDF = 0;
+	vdm_instance_t *pVDM_Instance;
+	pVDM_Instance=filp->private_data;
+
+	count = count/sizeof(uint32_t); // count is in bytes. we need to convert it to words
+        tBDF = pVDM_Instance->mBDF;
+
+	while(1)
+	{
+		spin_lock_irqsave(&lock, flags);
+		if(0 == pVDM_Instance->BDF_is_set)
+		{
+			ret = -ENOENT  ;
+			VDM_DEBUG_LOG(tBDF,"BDF was not set for given pVDM Instance\n");
+			goto unlock_and_exit;
+		}
+
+		if (vdm_is_in_reset())
+		{
+			pVDM_Instance->last_errors |= PCIE_VDM_ERR_BUS_RESET_OCCURED;
+			VDM_DEBUG_LOG(tBDF,"vdm reset detected while writing for 0x%X \n",pVDM_Instance->mBDF);
+			goto unlock_and_exit;
+		}
+
+		if (signal_pending(current))
+		{
+			ret = -EINTR;
+			goto unlock_and_exit;
+		}
+
+		num_of_items_to_read_from_buff = cbRead(&pVDM_Instance->circularBuffer, buf, count);
+
+		ret = num_of_items_to_read_from_buff<<2;
+
+		if (num_of_items_to_read_from_buff)
+		{
+			pVDM_Instance->dbg_counter -= ret;
+			VDM_DEBUG_LOG(tBDF," bdf=0x%X bytes in instance buffer %d\n",pVDM_Instance->mBDF,pVDM_Instance->dbg_counter );
+			goto unlock_and_exit ;
+		}
+		else
+		{
+			if(filp->f_flags & O_NONBLOCK)
+			{
+				ret = -EAGAIN;
+				goto unlock_and_exit;
+			}
+		}
+
+		if (vdm_is_in_reset())
+		{
+			pVDM_Instance->last_errors |= PCIE_VDM_ERR_BUS_RESET_OCCURED;
+			VDM_DEBUG_LOG(tBDF,"vdm reset detected while reading data\n");
+			goto unlock_and_exit;
+		}
+
+		stop_reset_poll = 0;
+		if ((reset_detect_poll) && (0 == reset_detect_poll_is_running))
+		{
+			reset_detect_poll_is_running = 1;
+			schedule_delayed_work(&reset_poll_work, RESET_POLL_TICK_mS);
+		}
+
+		spin_unlock_irqrestore(&lock, flags);
+
+                VDM_DEBUG_LOG(tBDF,"Going event interruptible state \n");
+		wait_event_interruptible( pVDM_Instance->in_data_available_wait ,
+				(vdm_is_in_reset() || ( 0 != cbGetNumOfElements(&pVDM_Instance->circularBuffer) ) ));
+	}
+
+unlock_and_exit:
+	stop_reset_poll = 1;
+	if(pVDM_Instance->last_errors)
+		ret = -EIO;
+
+	spin_unlock_irqrestore(&lock,   flags);
+	return (ret);
+}
+
+/* function : vdm_write
+ *
+ *
+ *
+ */
+static ssize_t vdm_write( struct file *filp, const char *buf, size_t count, loff_t *f_pos)
+{
+	long ret ;
+	unsigned long flags;
+	uint8_t route_type;
+        uint16_t tBDF = 0;
+	vdm_instance_t *pVDM_Instance;
+	pVDM_Instance=filp->private_data;
+	ret = count ;
+        tBDF = pVDM_Instance->mBDF;
+	spin_lock_irqsave(&lock,   flags);
+	
+	if (vdm_is_in_reset())
+	{
+		pVDM_Instance->last_errors |= PCIE_VDM_ERR_BUS_RESET_OCCURED;
+		ret = -EIO;
+                VDM_DEBUG_LOG(tBDF,"VDM is reset while writing \n");
+		goto failed;
+	}
+
+	if(0 != disable_TX)
+	{
+		VDM_DEBUG_LOG(tBDF,"vdm module TX stopped  \n");
+		ret = 0;
+		goto failed;
+	}
+	//pr_debug("<1> vdm module write start  \n");
+
+	if((count-1) > pVDM_Instance->mptxBufferLength)
+	{
+		VDM_DEBUG_LOG(tBDF,"vdm module data length is too big\n");
+		ret = -EINVAL;
+		goto failed;
+	}
+	if(count < 2)
+	{
+		VDM_DEBUG_LOG(tBDF,"vdm module : wrong buffer\n");
+		ret = -EINVAL;
+		goto failed;
+	}
+
+	if(copy_from_user( pVDM_Instance->mptxBuffer , &buf[1] , count-1))
+	{
+		ret = -EFAULT;
+                VDM_DEBUG_LOG(tBDF,"Failed for copying data from user\n");
+		goto failed;
+	}
+
+	if(0 == pVDM_Instance->BDF_is_set)
+	{
+		ret = -ENOENT  ;
+		VDM_DEBUG_LOG(tBDF,"BDF was not set\n");
+		goto failed;
+	}
+	if (copy_from_user(&route_type, &buf[0], sizeof(route_type)))
+	{
+		ret = -EFAULT;
+                VDM_DEBUG_LOG(tBDF,"Failed for copying data from user\n");
+		goto failed;
+	}
+	//route_type=buf[0];
+	if	(	(PCIe_HEADER_ROUTE_BY_ID 	!= route_type) &&
+			(PCIe_HEADER_ROUTE_TO_RC 	!= route_type) &&
+			(PCIe_HEADER_ROUTE_FROM_RC 	!= route_type) )
+	{
+		route_type=PCIe_HEADER_ROUTE_FROM_RC;
+	}
+
+        VDM_DEBUG_LOG(tBDF,"Before writing data route_type %d BDF 0x%X and count %d\n",route_type,pVDM_Instance->mBDF,count );
+
+	if (0 == vdm_SendMessage(route_type , pVDM_Instance->mBDF , pVDM_Instance->mptxBuffer,count-1))
+		ret = count;
+        else
+               VDM_DEBUG_LOG(tBDF,"Failed to send message \n");
+
+failed :
+	if(pVDM_Instance->last_errors)
+		ret = -EIO;
+
+	spin_unlock_irqrestore(&lock,   flags);
+
+	//pr_debug("<1> vdm module write end \n");
+
+	return ret;
+}
+
+
+
+
+
+
+/* function : vdm_ioctl
+ *
+ *
+ *
+ */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+static int vdm_ioctl(struct inode *i, struct file *f, unsigned int cmd, unsigned long arg)
+#else
+static long vdm_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+#endif
+{
+	long ret = 0 ;
+	unsigned long flags;
+	vdm_instance_t *pVDM_Instance;
+	bdf_arg_t lbdf_arg;
+	pVDM_Instance=filp->private_data;
+	VDM_DEBUG_LOG(pVDM_Instance->mBDF,"<1> %s vdm : cmd = %d \n",__FUNCTION__,cmd);
+	spin_lock_irqsave(&lock,   flags);
+
+    if (vdm_is_in_reset())
+    {
+    	pVDM_Instance->last_errors |= PCIE_VDM_ERR_BUS_RESET_OCCURED;
+    }
+
+    switch (cmd)
+    {
+        case PCIE_VDM_GET_BDF:
+        	//pVDM_Instance->mBDF=bdf_arg_to_bdf_U16((bdf_arg_t *)arg);
+        	bdf_U16_to_bdf_arg(pVDM_Instance->mBDF, &lbdf_arg);
+        	if(0 == pVDM_Instance->BDF_is_set)
+        	{
+        		ret = -ENOENT  ;
+        	}
+			if (copy_to_user((void __user *)arg, &lbdf_arg, sizeof(bdf_arg_t)))
+			{
+				ret = -EINVAL;
+			}
+            break;
+        case PCIE_VDM_SET_BDF :
+        	//bdf_U16_to_bdf_arg(pVDM_Instance->mBDF,(bdf_arg_t *)arg);
+			if (copy_from_user(&lbdf_arg, (const void __user *)arg,sizeof(bdf_arg_t)))
+			{
+        		ret = -EINVAL;
+			}
+        	pVDM_Instance->mBDF=bdf_arg_to_bdf_U16(&lbdf_arg);
+            VDM_DEBUG_LOG(pVDM_Instance->mBDF,"<1> %s vdm : PCIE_VDM_SET_BDF - pVDM_Instance->mBDF = %04X\n", __FUNCTION__, pVDM_Instance->mBDF);
+        	if(0 == pVDM_Instance->mBDF)
+        	{
+        		pVDM_Instance_Default = pVDM_Instance;
+        	}
+        	pVDM_Instance->BDF_is_set = 1;
+            break;
+
+        case PCIE_VDM_SET_TRANSMIT_BUFFER_SIZE:
+        	kfree(pVDM_Instance->mptxBuffer);
+        	pVDM_Instance->mptxBufferLength=(uint32_t)arg;
+        	pVDM_Instance->mptxBuffer=kmalloc(pVDM_Instance->mptxBufferLength,GFP_KERNEL);
+            if (pVDM_Instance->mptxBuffer == NULL)
+            {
+            	ret = -EINVAL;
+        	}
+            break;
+
+        case PCIE_VDM_SET_RECEIVE_BUFFER_SIZE:
+        	kfree(pVDM_Instance->mprxBuffer);
+
+        	pVDM_Instance->mprxBufferLength=(uint32_t)arg;
+        	pVDM_Instance->mprxBuffer=kmalloc((uint32_t)arg,GFP_KERNEL);
+            if (pVDM_Instance->mprxBuffer == NULL)
+            {
+        		ret = -EINVAL;
+                break;
+        	}
+            cbInit(&pVDM_Instance->circularBuffer, (pVDM_Instance->mprxBufferLength/sizeof(uint32_t)) ,
+            		pVDM_Instance->mprxBuffer , sizeof(uint32_t),memcpy,copy_to_user_wrapper);
+
+            break;
+
+        case PCIE_VDM_STOP_VDM_TX:
+			if(0 == (uint32_t)arg)
+				disable_TX=0;
+			else
+				disable_TX=1;
+			
+            break;
+			
+        case PCIE_VDM_STOP_VDM_RX:
+			if(0 == (uint32_t)arg)
+				vdm_enable_rx();
+			else
+				vdm_disable_rx();
+			
+            break;
+			
+        case PCIE_VDM_RESET:
+        	vdm_reset();
+            break;
+
+        case PCIE_VDM_SET_RX_TIMEOUT:
+        	if (vdm_set_timeout((VDM_RX_TIMEOUT_t)arg) )
+        		ret = -EINVAL;
+            break;
+
+        case PCIE_VDM_REINIT:
+        	_vdm_close();
+        	vdm_reset();
+        	_vdm_open();
+        	break;
+
+        case PCIE_VDM_SET_RESET_DETECT_POLL:
+        	reset_detect_poll = (uint32_t)arg;
+        	break;
+
+        case PCIE_VDM_GET_ERRORS:
+		if (copy_to_user((void __user *)arg,&pVDM_Instance->last_errors,sizeof(pVDM_Instance->last_errors)))
+			ret = -EINVAL;
+        	// *(uint32_t*)arg =pVDM_Instance->last_errors ;
+        	break;
+
+        case PCIE_VDM_CLEAR_ERRORS:
+        	{
+        		uint32_t last_errors =  (uint32_t)arg;
+        		if(PCIE_VDM_ERR_HW_FIFO_OVERFLOW & last_errors)
+        			vdm_clear_errors(VDM_ERR_FIFO_OVERFLOW);
+        		if(PCIE_VDM_ERR_USER_BUFFER_OVERFLOW & last_errors)
+				cbInit(&pVDM_Instance->circularBuffer, (pVDM_Instance->mprxBufferLength/sizeof(uint32_t)) ,
+                    		pVDM_Instance->mprxBuffer , sizeof(uint32_t),memcpy,copy_to_user_wrapper);
+        		pVDM_Instance->last_errors &= (~last_errors);
+        	}
+        	break;
+
+        default:
+        	ret = -EINVAL;
+    }
+
+	if (pVDM_Instance->last_errors & PCIE_VDM_ERR_BUS_RESET_OCCURED)
+		ret = -EIO;
+
+	spin_unlock_irqrestore(&lock,   flags);
+
+	return ret;
+}
+
+
+
+
+/* function : vdm_open
+ *
+ *
+ *
+ */
+static int vdm_open(struct inode *inode, struct file *filp)
+{
+	unsigned long flags;
+	vdm_instance_t *pVDM_Instance;
+//	uint16_t tBDF;
+
+	pVDM_Instance=kmalloc(sizeof(vdm_instance_t),GFP_KERNEL);
+	if (NULL == pVDM_Instance )
+	{
+		return -EINVAL;
+	}
+
+	memset(pVDM_Instance,0,sizeof(vdm_instance_t));
+	pVDM_Instance->BDF_is_set = 0;
+	pVDM_Instance->last_errors = 0;
+	pVDM_Instance->dbg_counter = 0;
+	pVDM_Instance->mptxBufferLength=_1KB_;// default data buffer
+	pVDM_Instance->mptxBuffer=kmalloc(pVDM_Instance->mptxBufferLength,GFP_KERNEL);
+	if (pVDM_Instance->mptxBuffer == NULL)
+	{
+		kfree(pVDM_Instance);
+		return -EINVAL;
+	}
+	pVDM_Instance->mprxBufferLength=_128KB_;// default data buffer
+	pVDM_Instance->mprxBuffer=kmalloc(pVDM_Instance->mprxBufferLength,GFP_KERNEL);
+	if (pVDM_Instance->mprxBuffer == NULL)
+	{
+		kfree(pVDM_Instance->mptxBuffer);
+		kfree(pVDM_Instance);
+		return -EINVAL;
+	}
+	init_waitqueue_head(&pVDM_Instance->in_data_available_wait);
+
+	cbInit(&pVDM_Instance->circularBuffer, (pVDM_Instance->mprxBufferLength/sizeof(uint32_t)) ,
+			pVDM_Instance->mprxBuffer , sizeof(uint32_t),memcpy,copy_to_user_wrapper);
+
+	filp->private_data=pVDM_Instance;
+	INIT_LIST_HEAD(&pVDM_Instance->list);
+
+	spin_lock_irqsave(&lock,   flags);
+	list_add ( &pVDM_Instance->list , &vdm_instances_list ) ;
+	spin_unlock_irqrestore(&lock,   flags);
+
+	//pr_debug(" vdm module open\n");
+	/* Success */
+	return 0;
+}
+
+/* function : vdm_release
+ *
+ *
+ *
+ */
+static int vdm_release(struct inode *inode, struct file *filp)
+{
+	vdm_instance_t *pVDM_Instance;
+        uint16_t tBDF;
+	pVDM_Instance=filp->private_data;
+        tBDF = pVDM_Instance->mBDF;
+	kfree(pVDM_Instance->mptxBuffer);
+	kfree(pVDM_Instance->mprxBuffer);
+	list_del ( &pVDM_Instance->list ) ;
+
+	if(pVDM_Instance_Default == pVDM_Instance)
+	{
+		pVDM_Instance_Default = NULL;
+	}
+
+	kfree(pVDM_Instance);
+	VDM_DEBUG_LOG(tBDF," vdm module released for %x \n",tBDF);
+  /* Success */
+  return 0;
+}
+
+
+
+/* function : vdm_poll
+ *
+ *
+ *
+ */
+static unsigned int vdm_poll(struct file *filp, poll_table *wait)
+{
+	unsigned long key;
+	unsigned long flags;
+	unsigned int mask;
+	vdm_instance_t *pVDM_Instance;
+	pVDM_Instance=filp->private_data;
+
+	mask = 0;
+
+	poll_wait(filp, &pVDM_Instance->in_data_available_wait,  wait);
+	key = poll_requested_events(wait);
+	spin_lock_irqsave(&lock,   flags);
+
+	if(vdm_is_in_reset())
+	{
+		pVDM_Instance->last_errors |= PCIE_VDM_ERR_BUS_RESET_OCCURED;
+		//		pr_debug("%s : vdm reset detected\n",__FUNCTION__);
+		stop_reset_poll = 1;
+		goto poll_exit;
+	}
+
+    if (cbGetNumOfElements(&pVDM_Instance->circularBuffer))
+    {
+        mask |= POLLIN | POLLRDNORM;    /* readable */
+
+    }
+    else
+    {
+    	if(POLLIN & key)
+    	{
+    		stop_reset_poll = 0;
+    		if ((reset_detect_poll) && (0 == reset_detect_poll_is_running))
+    		{
+    			reset_detect_poll_is_running = 1;
+    			schedule_delayed_work(&reset_poll_work, RESET_POLL_TICK_mS);
+    		}
+    	}
+    }
+
+    if ( vdm_is_ready_for_write())
+    {
+        mask |= POLLOUT | POLLWRNORM;   /* writable */
+    }
+
+
+	if(key & mask)
+	{
+		stop_reset_poll = 1;
+	}
+
+poll_exit :
+	if(pVDM_Instance->last_errors)
+	{
+		mask |= POLLHUP;
+	}
+	spin_unlock_irqrestore(&lock,   flags);
+
+    return mask;
+}
+
+
+
+static void receive_packet_func(uint16_t aBDF , uint32_t *data , uint32_t NumOfWords ,uint8_t isThisLastDataInPacket)
+{
+	uint32_t  num_of_items_written;
+	struct list_head *pList;
+	vdm_instance_t *pVDM_Instance;
+        uint32_t tBDF = aBDF;
+
+	// find instance with proper BDF
+	list_for_each(pList, &vdm_instances_list)
+	{
+		pVDM_Instance = list_entry(pList, vdm_instance_t, list);
+		//pr_debug("%s : Checking VDM_Instance->mBDF = %04X received = %04X\n",__FUNCTION__, pVDM_Instance->mBDF, aBDF);
+		VDM_DEBUG_LOG(tBDF,"%s : Checking VDM_Instance->mBDF = %04X received = %04X\n",__FUNCTION__,pVDM_Instance->mBDF, aBDF);
+		if(pVDM_Instance->mBDF == aBDF)
+		{
+			goto found_instance;
+		}
+	}
+
+    VDM_DEBUG_LOG(tBDF,"%s :No instance found so going with default\n",__FUNCTION__);
+	pVDM_Instance = pVDM_Instance_Default;
+
+found_instance :
+
+	if(NULL != pVDM_Instance)
+	{
+		pVDM_Instance->dbg_counter += (NumOfWords*4);
+		VDM_DEBUG_LOG(tBDF,"bytes in instance  %d\n",pVDM_Instance->dbg_counter);
+		num_of_items_written = cbWrite(&pVDM_Instance->circularBuffer, data, NumOfWords);
+		if( num_of_items_written != NumOfWords )
+		{
+			VDM_DEBUG_LOG(tBDF,"vdm:user buffer overflowed\n");
+			pVDM_Instance->last_errors |= PCIE_VDM_ERR_USER_BUFFER_OVERFLOW;
+		}
+		wake_up_interruptible(&pVDM_Instance->in_data_available_wait);
+	}
+	else
+	{
+		VDM_DEBUG_LOG(tBDF,"data discard because no instance found with proper BDF 0x%X\n",aBDF);
+	}
+}
+
+/* function : vdm_tasklet_function
+ *
+ *
+ *
+ */
+static void vdm_tasklet_function( unsigned long data )
+{
+	unsigned long flags;
+	//pr_debug("<1>vdm:vdm_tasklet_function\n");
+	spin_lock_irqsave(&lock,   flags);
+	vdma_copy_packets_from_buffer(receive_packet_func);
+	spin_unlock_irqrestore(&lock,   flags);
+}
+
+/* function : vdm_tasklet_function
+ *
+ *
+ *
+ */
+static void vdm_tasklet_function_with_overflow( unsigned long data )
+{
+	unsigned long flags;
+	//pr_debug("<1>vdm:vdm_tasklet_function with overflow\n");
+
+	spin_lock_irqsave(&lock,   flags);
+
+	vdma_copy_packets_from_buffer_with_overflow(receive_packet_func);
+	spin_unlock_irqrestore(&lock,   flags);
+
+}
+
+/* function : vdma_isr
+ *
+ *
+ *
+ */
+static irqreturn_t vdma_isr(int irq, void *dev_id)
+{
+	struct list_head *pList;
+	vdm_instance_t *pVDM_Instance;
+
+	irqreturn_t irqreturn = IRQ_NONE;
+
+	VDMA_STATUS_t status  ;
+
+	spin_lock(&lock);
+	irq_count++;
+    //pr_debug("irq_count %d\n",irq_count);
+	status = vdma_is_data_ready();
+	if(VDM_ERR_FIFO_OVERFLOW & vdm_get_errors() )
+	{
+		list_for_each(pList, &vdm_instances_list)
+		{
+			//pr_debug("<1>vdm:vdm fifo overflowed\n");
+			pVDM_Instance = list_entry(pList, vdm_instance_t, list);
+			pVDM_Instance->last_errors |= PCIE_VDM_ERR_HW_FIFO_OVERFLOW;
+		}
+	}
+
+	if(VDMA_STATUS_NONE != status)
+	{
+//		pr_debug("<1>vdm:vdma_isr 1\n");
+		if((VDMA_STATUS_OVERFLOWED == status) || (VDMA_STATUS_DATA_READY_WITH_OVERFLOWED == status))
+		{
+			//pr_debug("<1>vdm:vdma overflowed\n");
+			// find instance with proper BDF
+			list_for_each(pList, &vdm_instances_list)
+			{
+				pVDM_Instance = list_entry(pList, vdm_instance_t, list);
+				pVDM_Instance->last_errors |= PCIE_VDM_ERR_DMA_BUFFER_OVERFLOW;
+			}
+			//pr_debug("Going scheduling overflow tasklet\n");
+			tasklet_schedule( &vdm_tasklet_with_overflow );
+		}
+		else
+		{
+			//pr_debug("Going scheduling tasklet\n");
+			tasklet_schedule( &vdm_tasklet );
+		}
+	}
+	spin_unlock(&lock);
+
+
+	irqreturn = IRQ_HANDLED;
+
+	return irqreturn;
+
+}
+
+//#define  _USE_VDMA_POLLING
+
+#ifdef _USE_VDMA_POLLING
+
+static void task_routine(void *);
+static int stop_task = 0;		/* set this to 1 for shutdown */
+static struct workqueue_struct *my_workqueue = 0;
+static DECLARE_DELAYED_WORK(Task, task_routine);
+
+#define MY_WORK_QUEUE_NAME "WQsched.c"
+
+
+/* function : task_routine
+ *
+ *
+ *
+ */
+static void task_routine(void *irrelevant)
+{
+	vdma_isr(0,0);
+
+	/*
+	 * If cleanup wants us to stop_task
+	 */
+	if (stop_task == 0)
+		queue_delayed_work(my_workqueue, &Task, 1000);
+}
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        vdm_probe                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  pdev -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs probe for multiple slots                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static int vdm_probe(struct platform_device *pdev)
+{
+    int ret=0;
+
+    if(pdev == NULL)
+	pr_info("<1> vdm probe ERROR : pdev=NULL\n");
+
+    vdm_pdev=pdev;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set up the chip as the driver data of the device                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    platform_set_drvdata(pdev, &vdm_data_for_platform);
+
+    return ret;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        vdm_remove                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  pdev -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine handles driver uninitialization                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+static int vdm_remove(struct platform_device *pdev)
+{
+
+    platform_set_drvdata(pdev, NULL);
+
+    return 0;
+}
+
+/* Structure that declares the usual file */
+/* access functions */
+static struct file_operations vdm_fops =
+{
+  .read = vdm_read,
+  .write = vdm_write,
+  .open = vdm_open,
+  .release = vdm_release,
+  .poll = vdm_poll,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+  .release = vdm_ioctl
+#else
+  .unlocked_ioctl = vdm_ioctl
+#endif
+};
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           Device Declaration                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+static void vdm_device_release(struct device *dev)
+{
+     
+}
+
+#define DRIVER_NAME         "vdm"
+static struct resource vdm_resources[] /*=
+{
+    [0] = {
+        .start  = NPCMX50_PA_SDHC(SD2_DEV),
+        .end    = NPCMX50_PA_SDHC(SD2_DEV) + NPCMX50_SZ_SDHC - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+}*/;
+
+//u64 vdm_dmamask = 0xffffffff;
+static u64 vdm_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device vdm_device =
+{
+    .name       = DRIVER_NAME,
+    .id         = 0,
+    .dev        = {
+                .dma_mask           = &vdm_dmamask,
+                .coherent_dma_mask  = 0xffffffff,
+                .release            = vdm_device_release,
+    },
+    .resource   = NULL,//vdm_resources,
+    .num_resources  = 0,//ARRAY_SIZE(vdm_resources),
+};
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           Driver Declaration                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+static struct platform_driver vdm_driver =
+{
+    .driver     = {
+        .name   = DRIVER_NAME,
+        .owner  = THIS_MODULE,
+	.of_match_table = vdm_dt_npcm750_match,
+    },
+    .probe      = vdm_probe,
+    .remove     = vdm_remove,
+    .suspend    = NULL,
+    .resume     = NULL,
+};
+
+
+#define MAX_DDR_SIZE   (_256MB_ - _16MB_)
+
+/* function : vdm_init
+ *
+ *
+ *
+ */
+static int vdm_init(void) 
+{
+	int ret = 0;
+	int vdma_interrupt;
+	
+#ifdef CONFIG_OF
+	struct device_node *np = NULL;
+	struct resource res;
+#endif
+
+	loops_per_jiffy_for_ndelay = loops_per_jiffy / 1000;
+	//printk("vdm : loops for ndelay %lu  \n",loops_per_jiffy_for_ndelay);
+
+	 /*-----------------------------------------------------------------------------------------------------*/
+    /* Register the platform device driver.                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+	if ((ret=platform_driver_register(&vdm_driver)))
+		return ret;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Register the platform device.                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+	if ((ret=platform_device_register(&vdm_device)))
+		goto device_regestry_failed ;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* init device                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+
+	if (majornum <= 0)
+	{
+		/* allocate a device number */
+		ret = alloc_chrdev_region(&vdm_dev, 0, 1, "vdm");
+		majornum = MAJOR(vdm_dev);
+	}
+	else
+	{
+		vdm_dev = MKDEV(majornum, 0);
+		ret = register_chrdev_region(vdm_dev, 1, "vdm");
+	}
+
+	//printk(" vdm : mknod /dev/vdm c %d 0\n", MAJOR(vdm_dev));
+	if (ret)
+		goto alloc_chrdev_region_failed;
+
+	/* Add a char device */
+	vdm_cdev = cdev_alloc();
+	vdm_cdev->owner = THIS_MODULE;
+	vdm_cdev->ops = &vdm_fops;
+
+	cdev_add(vdm_cdev, vdm_dev, 1);
+	if(!vdm_pdev)
+	{
+		//pr_debug( "<1>  vdm : vdm_pdev=NULL \n" );
+		ret = -EINVAL;
+		goto char_dev_add_failed ;
+	}
+	
+#ifdef CONFIG_OF
+	np = of_find_matching_node(NULL, vdm_dt_npcm750_match);
+	if (!np)
+		pr_info("Failed to find of_find_matching_node\n");
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		pr_info("\t\t\t of_address_to_resource fail ret %d \n",ret);
+		return -EINVAL;
+	}
+
+	vdm_virt_addr = ioremap_nocache(res.start, resource_size(&res));
+	if (!vdm_virt_addr) {
+		pr_info("\t\t\t vdm_virt_addr fail \n");
+		return -ENOMEM;
+	}
+
+	ret = of_address_to_resource(np, 1, &res);
+	if (ret) {
+		pr_info("\t\t\t of_address_to_resource fail ret %d \n",ret);
+		return -EINVAL;
+	}
+
+	vdma_virt_addr = ioremap_nocache(res.start, resource_size(&res));
+
+	if (!vdma_virt_addr) {
+		pr_info("\t\t\t vdma_virt_addr fail \n");
+		return -ENOMEM;
+	}
+
+	if (of_device_is_compatible(np, "nuvoton,npcm750-vdm")) {
+		gcr_regmap = syscon_regmap_lookup_by_compatible("nuvoton,npcm750-gcr");
+		if (IS_ERR(gcr_regmap)) {
+			pr_info("Failed to find nuvoton,npcm750-gcr WD reset status not supported\n");
+		}
+	}
+#endif
+
+	vdma_buff_virt_addr = dma_alloc_coherent(&vdm_pdev->dev, VDMA_BUFF_BYTE_SIZE , (dma_addr_t*)&vdma_buff, GFP_KERNEL);
+	//printk( "<1>  vdm : dma_alloc_coherent virt_addr=0x%x ,phys_addr=0x%x   \n",(unsigned int)vdma_buff_virt_addr, (unsigned int)vdma_buff);
+	
+	if ((!vdma_buff_virt_addr) || (!vdma_buff))
+	{
+		//pr_debug( "<1>  vdm : vdma_buff_virt_addr or  vdma_buff allocation failed \n" );
+		ret = -EINVAL;
+		goto dma_alloc_coherent_failed ;
+	}
+
+	spin_lock_init(&lock);
+
+	ret = _vdm_open();
+	if (0 != ret)
+	{
+        //pr_debug(KERN_ERR DRIVER_NAME "_vdm_open error, rc=%d\n", ret);
+        goto vdm_open_failed;
+	}
+
+#ifdef _USE_VDMA_POLLING
+	my_workqueue = create_workqueue(MY_WORK_QUEUE_NAME);
+	queue_delayed_work(my_workqueue, &Task, 1000);
+	//pr_debug("<1> vdma polling is used   \n");
+#else
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Init interrupts.                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+	vdma_interrupt = irq_of_parse_and_map(np, 0);
+	if (!vdma_interrupt) {
+		dev_err(&vdm_pdev->dev, "failed getting interrupt resource\n");
+		ret = -EINVAL;
+		goto request_irq_failed;
+	}
+
+	ret = devm_request_irq(&vdm_pdev->dev, vdma_interrupt, vdma_isr,
+			       IRQF_SHARED, "VDMA", &dummy_vdma_dev);
+	if (ret < 0) {
+		dev_err(&vdm_pdev->dev, "failed requesting interrupt (%d)\n",
+			vdma_interrupt);
+		goto request_irq_failed;
+	}
+
+
+//	SET_REG_BIT(AIC_GEN_REG, AIC_GEN_MTCP);
+//	result = request_irq(MCTP_INT,
+//								   (void *) vdm_isr,
+//								   IRQF_SAMPLE_RANDOM ,
+//								   "VDMX",
+//								   (void *) NULL);
+//	pr_debug("<1> vdma request_irq return = %d \n",result);
+#endif
+
+	vdm_class = class_create(THIS_MODULE, "vdm");
+	if (IS_ERR(vdm_class))
+	{
+	    //pr_debug( "<1>  vdma :class_create failed  \n");
+        goto class_create_failed;
+	}
+
+	vdm_sysfs_device  =device_create(vdm_class, NULL, vdm_dev, NULL, "vdm");
+	if (IS_ERR(vdm_sysfs_device))
+	{
+	    //pr_debug( "<1>  vdma :device_create failed  \n");
+        goto device_create_failed;
+	}
+
+	pr_info("NPCM VDM driver probed\n");
+
+	return 0;
+
+device_create_failed:
+	class_destroy(vdm_class);
+class_create_failed:
+#ifndef _USE_VDMA_POLLING
+    free_irq(vdma_interrupt,(void *) &dummy_vdma_dev);
+#endif
+request_irq_failed :
+	_vdm_close();
+vdm_open_failed :
+	dma_free_coherent(&vdm_pdev->dev, VDMA_BUFF_BYTE_SIZE , vdma_buff_virt_addr , (dma_addr_t)vdma_buff);
+dma_alloc_coherent_failed :
+	cdev_del(vdm_cdev);
+char_dev_add_failed :
+	unregister_chrdev_region(vdm_dev, 1);
+alloc_chrdev_region_failed :
+	platform_device_unregister(&vdm_device);
+device_regestry_failed :
+	platform_device_put(&vdm_device);
+	platform_driver_unregister(&vdm_driver);
+
+	return ret;
+}
+
+static void vdm_exit(void) 
+{
+	struct list_head *pList;
+	vdm_instance_t *pVDM_Instance;
+	unsigned long flags;
+
+	spin_lock_irqsave(&lock,   flags);
+
+	device_destroy(vdm_class , vdm_dev);
+	class_destroy(vdm_class);
+
+	reset_detect_poll = 0;
+	stop_reset_poll = 1;
+	spin_unlock_irqrestore(&lock,   flags);
+	cancel_delayed_work(&reset_poll_work);
+	flush_scheduled_work();	/* wait till polling work finished */
+
+#ifdef _USE_VDMA_POLLING
+	stop_task = 1;		/* keep intrp_routine from queueing itself */
+	cancel_delayed_work(&Task);	/* no "new ones" */
+	flush_workqueue(my_workqueue);	/* wait till all "old ones" finished */
+	destroy_workqueue(my_workqueue);
+#endif
+	_vdm_close();
+	// clear list of vdm_instances
+	list_for_each(pList, &vdm_instances_list)
+	{
+		pVDM_Instance = list_entry(pList, vdm_instance_t, list);
+		kfree(pVDM_Instance->mptxBuffer);
+		kfree(pVDM_Instance->mprxBuffer);
+		list_del ( &pVDM_Instance->list ) ;
+		kfree(pVDM_Instance);
+	}
+
+	vdm_exit_common();
+	dma_free_coherent(&vdm_pdev->dev, VDMA_BUFF_BYTE_SIZE , vdma_buff_virt_addr , (dma_addr_t)vdma_buff);	
+
+	/* release the char device */
+	cdev_del(vdm_cdev);
+
+	/* release the device number */
+	unregister_chrdev_region(vdm_dev, 1);
+	platform_device_unregister(&vdm_device);
+	platform_driver_unregister(&vdm_driver);
+	//pr_debug("<1> vdm module exit\n");
+}
+
+module_init(vdm_init);
+module_exit(vdm_exit);
+MODULE_DESCRIPTION("AESS VDM Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/npcm-vdm/vdm_module.h b/drivers/misc/npcm-vdm/vdm_module.h
new file mode 100755
index 000000000..18461517e
--- /dev/null
+++ b/drivers/misc/npcm-vdm/vdm_module.h
@@ -0,0 +1,35 @@
+/********************************************************
+ *
+ * file : vdm_module.h
+ *
+ *
+ ****************************************************/
+
+#ifndef _VDM_MODULE_H_
+#define _VDM_MODULE_H_
+
+typedef struct
+{
+    uint8_t bus, device, function;
+} bdf_arg_t;
+
+#define PCIE_VDM_IOC_MAGIC       0xe8
+#define PCIE_VDM_SET_BDF 					_IOW(PCIE_VDM_IOC_MAGIC, 1, bdf_arg_t *)
+#define PCIE_VDM_SET_TRANSMIT_BUFFER_SIZE   _IOW(PCIE_VDM_IOC_MAGIC, 2 , uint32_t )
+#define PCIE_VDM_SET_RECEIVE_BUFFER_SIZE    _IOW(PCIE_VDM_IOC_MAGIC, 3 , uint32_t )
+#define PCIE_VDM_STOP_VDM_TX			    _IO(PCIE_VDM_IOC_MAGIC, 4 )
+#define PCIE_VDM_STOP_VDM_RX			    _IO(PCIE_VDM_IOC_MAGIC, 5 )
+#define PCIE_VDM_GET_BDF 					_IOR(PCIE_VDM_IOC_MAGIC, 6, bdf_arg_t *)
+#define PCIE_VDM_RESET 						_IO(PCIE_VDM_IOC_MAGIC, 7 )
+#define PCIE_VDM_SET_RX_TIMEOUT 			_IOW(PCIE_VDM_IOC_MAGIC, 8 , uint32_t )
+#define PCIE_VDM_REINIT						_IOW(PCIE_VDM_IOC_MAGIC, 9 , uint32_t )
+#define PCIE_VDM_SET_RESET_DETECT_POLL		_IOW(PCIE_VDM_IOC_MAGIC, 10 , uint32_t )
+#define PCIE_VDM_GET_ERRORS					_IOW(PCIE_VDM_IOC_MAGIC, 11 , uint32_t *)
+#define PCIE_VDM_CLEAR_ERRORS				_IOW(PCIE_VDM_IOC_MAGIC, 12 , uint32_t )
+
+#define PCIE_VDM_ERR_HW_FIFO_OVERFLOW				0x00000001
+#define PCIE_VDM_ERR_DMA_BUFFER_OVERFLOW			0x00000002
+#define PCIE_VDM_ERR_USER_BUFFER_OVERFLOW			0x00000004
+#define PCIE_VDM_ERR_BUS_RESET_OCCURED				0x00000008
+
+#endif
diff --git a/drivers/misc/npcm-vdm/vdm_readme.txt b/drivers/misc/npcm-vdm/vdm_readme.txt
new file mode 100755
index 000000000..ebad034d8
--- /dev/null
+++ b/drivers/misc/npcm-vdm/vdm_readme.txt
@@ -0,0 +1,71 @@
+
+Nuvoton VDM implementation notes:
+
+1) ioctl() commands:
+	For all ioctl commands in case that VDM is in reset (due to PCIe reset) then -EIO is returned.
+	
+	PCIE_VDM_SET_BDF
+		argument of ioctl is pointer to variable of following type:
+		typedef struct
+		{
+			u8_t bus, device, function;
+		} bdf_arg_t;
+
+	PCIE_VDM_SET_TRANSMIT_BUFFER_SIZE
+		set transmit buffer size
+		argument of ioctl is u32_t
+
+	PCIE_VDM_SET_RECEIVE_BUFFER_SIZE
+		set receive buffer size
+		argument of ioctl is u32_t
+
+	PCIE_VDM_STOP_VDM_TX
+		enable/disable transmit (argument of ioctl : 0 - disable / 1-enable)
+
+	PCIE_VDM_STOP_VDM_RX
+		enable/disable receive
+		argument of ioctl : 0 - disable / 1-enable
+
+	PCIE_VDM_GET_BDF
+		argument of ioctl is pointer to variable of following type:
+		typedef struct
+		{
+			u8_t bus, device, function;
+		} bdf_arg_t;
+
+		in case of invalid BDF -ENOENT is returned
+																	
+	PCIE_VDM_RESET
+		reset vdm hardware
+													
+	PCIE_VDM_SET_RX_TIMEOUT
+		set timeout on PCIe bus
+		argument of ioctl : 0 - 0us , 1 -0.5us , 2- 1us , 3- 2us , 4- 4us , 5- 8us
+									
+	PCIE_VDM_REINIT
+		re-init hw: mark all open BDF as invalid and re-init all buffers
+																					
+	PCIE_VDM_SET_RESET_DETECT_POLL
+		enable/disable PCIe reset detection polling (argument of ioctl : 0 - disable / 1-enable)
+		polling is enabled on start
+
+2) read()
+	Read the requested number of bytes from VDM.
+	in case of invalid BDF -ENOENT is returned.
+	in case that VDM is in reset (due to PCIe reset) then -EIO is returned.
+	in case of a blocking read (default read() in linux) and reset detection poll is
+			enabled (see ioctl PCIE_VDM_SET_RESET_DETECT_POLL) then every 100ms VDM is
+			checked for reset (due to PCIe reset), if reset detected then -EIO is returned
+
+3) write()
+	in case of invalid BDF -ENOENT is returned .
+	in case that VDM is in reset (due to PCIe reset) then -EIO is returned.
+
+4) poll()
+	0 - when timeout expires and data is not ready and VDM was not reset
+	1 and POLLIN set in revents parameter - when data is ready.
+	1 and POLLHUP (Hang up) set in revents - when VDM was reset.
+	Note:
+		if poll() timeout parameter is greater then 100ms and reset detection poll is
+		enabled (see ioctl PCIE_VDM_SET_RESET_DETECT_POLL) then every 100ms VDM is
+		checked for reset (due to PCIe reset)
