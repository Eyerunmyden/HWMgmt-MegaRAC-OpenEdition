From 6309fe17f9c52f182fb9fd900c3675c8b5dbdb4c Mon Sep 17 00:00:00 2001
From: eddyhan <eddyhan@ami.com.tw>
Date: Fri, 7 Sep 2018 11:47:32 +0800
Subject: [PATCH] Enable AMI extend IOCTLS and Slave function.


diff --git a/drivers/i2c/Kconfig b/drivers/i2c/Kconfig
index efc3354..e8beaac 100644
--- a/drivers/i2c/Kconfig
+++ b/drivers/i2c/Kconfig
@@ -33,6 +33,10 @@ config ACPI_I2C_OPREGION
 	  Operation Regions allow firmware (BIOS) code to access I2C slave devices,
 	  such as smart batteries through an I2C host controller driver.
 
+config AMII2C
+    bool "For AMI extended IOCTLS and functions"
+    default y
+    
 if I2C
 
 config I2C_BOARDINFO
diff --git a/drivers/i2c/busses/i2c-data.h b/drivers/i2c/busses/i2c-data.h
new file mode 100644
index 0000000..6396d48
--- /dev/null
+++ b/drivers/i2c/busses/i2c-data.h
@@ -0,0 +1,268 @@
+/*
+ ****************************************************************
+ **                                                            **
+ **    (C)Copyright 2009-2015, American Megatrends Inc.        **
+ **                                                            **
+ **            All Rights Reserved.                            **
+ **                                                            **
+ **        5555 Oakbrook Pkwy Suite 200, Norcross,             **
+ **                                                            **
+ **        Georgia - 30093, USA. Phone-(770)-246-8600.         **
+ **                                                            **
+ ****************************************************************
+ */
+#ifndef _I2C_DATA_H
+#define _I2C_DATA_H
+
+#include <linux/i2c.h>
+#include "projdef.h"
+
+#define TRANSFERSIZE 1024
+#define MAX_FIFO_LEN 16
+
+#define AST_I2C_DMA_SIZE 4096
+#if IS_ENABLED(CONFIG_AMII2C)
+#define SOC_AST2500 1
+#endif /* CONFIG_AMII2C */
+
+#if defined(SOC_AST2300)
+#define GROUP_AST2300 1
+#endif
+#if defined(SOC_AST2400) || defined(SOC_AST3100) || defined(SOC_AST3200)
+#define GROUP_AST2300_PLUS 1
+#endif
+#if defined(SOC_AST2500) || defined(SOC_AST2530)
+#define GROUP_AST2500 1
+#endif
+#if defined(CONFIG_SPX_FEATURE_BMCCOMPANIONDEVICE_AST1070)
+#define GROUP_AST1070_COMPANION 1
+#elif defined(SOC_AST1250)
+#define GROUP_AST2300_PLUS 1
+#endif
+#if defined(SOC_AST1050_1070)
+#define GROUP_AST1070_COMPANION 1
+#endif
+
+#if defined(GROUP_AST1070_COMPANION)
+#define AST_BMCCC_BUS_COUNT (CONFIG_SPX_FEATURE_NUM_SINGLE_BMC_COMPANION_I2C_BUSES * CONFIG_SPX_FEATURE_NUM_BMC_COMPANION_DEVICES)
+#define AST_BMC_BUS_COUNT (CONFIG_SPX_FEATURE_NUM_BMC_I2C_BUSES)
+#define BUS_COUNT  (AST_BMC_BUS_COUNT + AST_BMCCC_BUS_COUNT)
+#else
+#define AST_BMC_BUS_COUNT (CONFIG_SPX_FEATURE_NUM_TOTOL_I2C_BUSES)
+#define BUS_COUNT  AST_BMC_BUS_COUNT
+#endif
+
+#define DEFAULT_SLAVE_0     ( 0x10 )
+#define DEFAULT_SLAVE_1     ( 0x10 )
+#define DEFAULT_SLAVE_2     ( 0x10 )
+#define DEFAULT_SLAVE_3     ( 0x10 )
+#define DEFAULT_SLAVE_4     ( 0x10 )
+#define DEFAULT_SLAVE_5     ( 0x10 )
+#define DEFAULT_SLAVE_6     ( 0x10 )
+#if defined(GROUP_AST2300) || defined(GROUP_AST2300_PLUS) || defined(GROUP_AST2500) || defined(GROUP_AST1070_COMPANION)
+#define DEFAULT_SLAVE_7     ( 0x10 )
+#define DEFAULT_SLAVE_8     ( 0x10 )
+#endif
+#if defined(GROUP_AST2300_PLUS) || defined(GROUP_AST2500) || defined(GROUP_AST1070_COMPANION)
+#define DEFAULT_SLAVE_9     ( 0x10 )
+#define DEFAULT_SLAVE_10    ( 0x10 )
+#define DEFAULT_SLAVE_11    ( 0x10 )
+#define DEFAULT_SLAVE_12    ( 0x10 )
+#define DEFAULT_SLAVE_13    ( 0x10 )
+#endif
+#if defined(GROUP_AST1070_COMPANION)
+#define DEFAULT_SLAVE_14   ( 0x10 )
+#define DEFAULT_SLAVE_15   ( 0x10 )
+#define DEFAULT_SLAVE_16   ( 0x10 )
+#define DEFAULT_SLAVE_17   ( 0x10 )
+#define DEFAULT_SLAVE_18   ( 0x10 )
+#define DEFAULT_SLAVE_19   ( 0x10 )
+#define DEFAULT_SLAVE_20   ( 0x10 )
+#define DEFAULT_SLAVE_21   ( 0x10 )
+#if (CONFIG_SPX_FEATURE_NUM_BMC_COMPANION_DEVICES >= 2)
+#define DEFAULT_SLAVE_22   ( 0x10 )
+#define DEFAULT_SLAVE_23   ( 0x10 )
+#define DEFAULT_SLAVE_24   ( 0x10 )
+#define DEFAULT_SLAVE_25   ( 0x10 )
+#define DEFAULT_SLAVE_26   ( 0x10 )
+#define DEFAULT_SLAVE_27   ( 0x10 )
+#define DEFAULT_SLAVE_28   ( 0x10 )
+#define DEFAULT_SLAVE_29   ( 0x10 )
+#endif /* CONFIG_SPX_FEATURE_NUM_BMC_COMPANION_DEVICES >= 2 */
+#endif
+
+#define MASTER 0x10
+#define SLAVE 0x00
+#define MASTER_XMIT 0x11
+#define MASTER_RECV 0x10
+
+#define SLAVETX_MAX_RES_SIZE	34	//Here defined size for SSIF application: Length, Data[1..32], PEC 
+#define SLAVETX_RES_BUFFER_SIZE	((SLAVETX_MAX_RES_SIZE/4) + (SLAVETX_MAX_RES_SIZE%4 == 0?0:1)) * 4 
+
+/* Extended IOCTLS - Implemented in i2c-core and hardware for SSIF */ 
+#define ENABLE_SSIF	0x0852 
+
+/* Error codes in compliance with IPMI */
+#define ARBLOST		0x80000081
+#define BUSERR		0x80000082
+#define NACKONWR	0x80000083
+#define TRUNKRD		0x80000084
+
+#define I2C_BYTE_MODE   0 
+#define I2C_DMA_MODE    1 
+
+//#define JM_RECOVERY 1
+
+#ifdef CONFIG_SPX_FEATURE_ENABLE_I2C_LOG
+#define I2C_LOG_FILTER_COUNT_MAX 6
+
+#define I2C_LOG_NONE    0
+#define I2C_LOG_ALL     1
+#define I2C_LOG_FILTER  2
+
+struct log_i2c_filter
+{
+        unsigned addr;
+        unsigned mode;
+        unsigned offset;
+        unsigned val;
+};
+
+struct log_i2c_conf
+{
+        u8 log_enabled;
+        struct log_i2c_filter filters[I2C_LOG_FILTER_COUNT_MAX];
+};
+#endif // CONFIG_SPX_FEATURE_ENABLE_I2C_LOG
+
+struct i2c_as_data
+{
+    int i2c_dma_mode;
+    unsigned char *dma_buff;
+    dma_addr_t dma_addr;
+
+	unsigned char TX_data[TRANSFERSIZE];
+	int TX_len;
+	int TX_index;
+
+	unsigned char MCTPRX_data[MAX_FIFO_LEN][TRANSFERSIZE];
+	int MCTPRX_Writer;
+	int MCTPRX_Reader;
+	int MCTPRX_Len[MAX_FIFO_LEN];
+	int MCTPRX_Entries;
+ 
+	unsigned char MasterRX_data[TRANSFERSIZE];
+	int MasterRX_len;
+	int MasterRX_index;
+
+	unsigned char Linear_SlaveRX_data[TRANSFERSIZE];
+	int Linear_SlaveRX_len;
+	int Linear_SlaveRX_index;
+
+	unsigned char SlaveRX_data[MAX_FIFO_LEN][TRANSFERSIZE];
+	int SlaveRX_len[MAX_FIFO_LEN];
+	int SlaveRX_index[MAX_FIFO_LEN];
+	
+	int SlaveRX_Writer;
+	int SlaveRX_Reader;
+	int SlaveRX_Entries;
+
+	unsigned char SlaveTX_RES_data[SLAVETX_RES_BUFFER_SIZE];
+	int SlaveTX_Enable;
+	int SlaveTX_READ_DATA;
+	int SlaveTX_REQ_cmd;
+	int SlaveTX_RES_len;
+	int SlaveTX_index;
+	int SlaveTX_count; //For test usage, show how many data including padding byte are sent
+
+	spinlock_t data_lock;
+
+	volatile u32 op_status;
+	volatile u32 abort_status;
+
+	int master_xmit_recv_mode_flag;
+
+	u32 pool_buff_base;
+
+	wait_queue_head_t as_wait;
+    wait_queue_head_t as_slave_data_wait;
+	wait_queue_head_t as_mctp_data_wait;
+
+	int address_sent;
+	int target_address;
+	int block_read;
+	int block_proc_call;
+	int host_notify_flag;
+	int master_read_with_PEC;   //for I2C_SMBUS_BLOCK_DATA and I2C_SMBUS_BLOCK_PROC_CALL
+
+	unsigned char SMB_Linear_SlaveRX_data[TRANSFERSIZE];
+	int SMB_Linear_SlaveRX_len;
+	int SMB_Linear_SlaveRX_index;
+
+	
+	unsigned char SMB_SlaveRX_data[MAX_FIFO_LEN][TRANSFERSIZE];
+	int SMB_SlaveRX_len[MAX_FIFO_LEN];
+	int SMB_SlaveRX_index[MAX_FIFO_LEN];
+		
+	int SMB_SlaveRX_Writer;
+	int SMB_SlaveRX_Reader;
+	int SMB_SlaveRX_Entries;
+	unsigned short i2c_link_state;
+	
+#ifdef JM_RECOVERY 
+	unsigned char dev_fail_cnt[128];
+	unsigned char bus_busy_cnt;
+	int i2c_message_slave_address;
+#endif
+#ifdef CONFIG_SPX_FEATURE_ENABLE_I2C_LOG
+        struct log_i2c_conf log_conf;
+#endif
+
+};
+
+int i2c_as_add_bus( struct i2c_adapter * );
+int i2c_as_del_bus( struct i2c_adapter * );
+
+void i2c_init_internal_data(int bus);
+
+
+
+
+
+/*
+* I2C BUS states 
+*/
+
+#define I2C_LINK_NO_FAILURE						0x00  //
+#define I2C_UNABLE_DRIVE_CLK_HIGH				0x01  //
+#define I2C_UNABLE_DRIVE_DATA_HIGH				0x02  //
+#define I2C_UNABLE_DRIVE_CLK_LOW				0x03
+#define I2C_UNABLE_DRIVE_DATA_LOW				0x04
+#define I2C_CLOCK_LOW_TIMEOUT_CLK_HIGH			0x05   
+#define I2C_UNDER_TEST							0x06  //  
+#define I2C_UNDIAGNOSED_COMM_FAILURE			0x07  // 
+
+/*
+* I2c Test Operations
+*/
+#define I2C_TEST_BUS_BUSY					0x01
+#define I2C_TEST_BUS_RECOVERABLE				0x02
+
+typedef struct
+{
+       int i2cLinkState;
+ } i2c_link_state_T;
+
+typedef struct
+{
+ 	int operation;
+	int result;
+ } i2c_bus_test_T;
+
+
+/*
+ * Flag for as_check_SignalPending func
+ */
+#define I2C_RECEIVE 		(1 << 0)
+#define I2c_TRANSMIT 		(1 << 1)
+#endif
diff --git a/drivers/i2c/busses/i2c-hardware.h b/drivers/i2c/busses/i2c-hardware.h
new file mode 100644
index 0000000..663c4f1
--- /dev/null
+++ b/drivers/i2c/busses/i2c-hardware.h
@@ -0,0 +1,603 @@
+/*
+ ****************************************************************
+ **                                                            **
+ **    (C)Copyright 2009-2015, American Megatrends Inc.        **
+ **                                                            **
+ **            All Rights Reserved.                            **
+ **                                                            **
+ **        5555 Oakbrook Pkwy Suite 200, Norcross,             **
+ **                                                            **
+ **        Georgia - 30093, USA. Phone-(770)-246-8600.         **
+ **                                                            **
+ ****************************************************************
+ */
+#ifndef _I2C_HARDWARE_H
+#define _I2C_HARDWARE_H
+#include <linux/version.h>
+#include "projdef.h"
+
+/* Sensible Defaults */
+#define DEFAULT_TIMEOUT     ( 10 )          /* Timeout/delay for bus activities */
+#define DEFAULT_RETRIES     ( 3 )			/* Retries on send/receive */
+#define DEFAULT_BB_RETRIES  ( 5 )           /* Retries to get a free bus */
+#define MAX_MCTP_MSG_SIZE   164
+#define MAX_DMA_TRANSFER_LENGTH_SIZE   4095 /* Define the maximun size of DMA transfer length */
+
+/* protection key register */
+#define SCU_PROTECTION_UNLOCK		0x1688A8A8
+#define I2C_RESET_CNTLR_BIT		0x04
+
+
+/* These values are as per the data sheet provided for i2c clock */
+#if defined(GROUP_AST2300) || defined(GROUP_AST2300_PLUS) || defined(GROUP_AST1070_COMPANION)
+#define CLOCK_AC_1_VAL_100K		0x77776304	/* 100KHz for AST2300/AST2400/AST3100 */
+#define CLOCK_AC_1_VAL_400K		0x77766302	/* 400KHz for AST2300/AST2400/AST3100 */
+	#if defined(CONFIG_SPX_FEATURE_OVERRIDE_I2CD04_REG_VALUE_1MHZ)
+	#define CLOCK_AC_1_VAL_1000K	CONFIG_SPX_FEATURE_OVERRIDE_I2CD04_REG_VALUE_1MHZ /* 1000KHz for AST1250/AST2400*/
+	#else
+	#define CLOCK_AC_1_VAL_1000K	0x77743301	/* 1000KHz for AST1250/AST2400*/
+	#endif
+#endif
+
+#if defined(GROUP_AST2500)
+#define CLOCK_AC_1_VAL_100K		0x777FE303	/* 100KHz for AST2500 */
+#define CLOCK_AC_1_VAL_400K		0x777FE301	/* 400KHz for AST2500 */
+#define CLOCK_AC_1_VAL_1000K	0x777CB300	
+#endif
+
+#ifdef JM_RECOVERY
+#define MAX_ALLOWED_DEVICE_FAILURES	( 10 )
+#define MAX_ALLOWED_BUS_BUSY_FAILURES	( 10 )
+#endif
+
+#if defined(SOC_AST2150)
+#define CLOCK_AC_1_VAL_100K		0x77754355	/* 100KHz for AST2150 */
+#define CLOCK_AC_1_VAL_400K		0x77754333	/* 400KHz for AST2150 */
+#define CLOCK_AC_1_VAL_1000K		0x77755301	
+
+#endif
+#if defined(SOC_AST2050)
+#define CLOCK_AC_1_VAL_100K		0x77777344	/* 100KHz for AST2050 */
+#define CLOCK_AC_1_VAL_400K		0x77776322	/* 400KHz for AST2050 */
+#define CLOCK_AC_1_VAL_1000K		0x77755301	
+
+#endif
+
+#if defined(CONFIG_SPX_FEATURE_I2C00_FAST_MODE)
+	#define AST_I2C_0_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C00_FAST_MODE_PLUS)
+	#define AST_I2C_0_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_0_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+
+#if defined(CONFIG_SPX_FEATURE_I2C01_FAST_MODE)
+	#define AST_I2C_1_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C01_FAST_MODE_PLUS)
+	#define AST_I2C_1_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_1_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C02_FAST_MODE)
+	#define AST_I2C_2_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C02_FAST_MODE_PLUS)
+	#define AST_I2C_2_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_2_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C03_FAST_MODE)
+	#define AST_I2C_3_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C03_FAST_MODE_PLUS)
+	#define AST_I2C_3_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_3_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C04_FAST_MODE)
+	#define AST_I2C_4_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C04_FAST_MODE_PLUS)
+	#define AST_I2C_4_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_4_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C05_FAST_MODE)
+	#define AST_I2C_5_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C05_FAST_MODE_PLUS)
+	#define AST_I2C_5_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_5_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C06_FAST_MODE)
+	#define AST_I2C_6_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C06_FAST_MODE_PLUS)
+	#define AST_I2C_6_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_6_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+
+#if defined(GROUP_AST2300) || defined(GROUP_AST2300_PLUS) || defined(GROUP_AST2500) || defined(GROUP_AST1070_COMPANION)
+#if defined(CONFIG_SPX_FEATURE_I2C07_FAST_MODE)
+	#define AST_I2C_7_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C07_FAST_MODE_PLUS)
+	#define AST_I2C_7_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_7_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C08_FAST_MODE)
+	#define AST_I2C_8_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C08_FAST_MODE)
+	#define AST_I2C_8_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_8_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#endif
+
+#if defined(GROUP_AST2300_PLUS) || defined(GROUP_AST2500) || defined(GROUP_AST1070_COMPANION)
+#if defined(CONFIG_SPX_FEATURE_I2C09_FAST_MODE)
+	#define AST_I2C_9_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C09_FAST_MODE_PLUS)
+	#define AST_I2C_9_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_9_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C10_FAST_MODE)
+	#define AST_I2C_10_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C10_FAST_MODE_PLUS)
+	#define AST_I2C_10_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_10_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C11_FAST_MODE)
+	#define AST_I2C_11_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C11_FAST_MODE_PLUS)
+	#define AST_I2C_11_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_11_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C12_FAST_MODE)
+	#define AST_I2C_12_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C12_FAST_MODE_PLUS)
+	#define AST_I2C_12_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_12_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C13_FAST_MODE)
+	#define AST_I2C_13_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C13_FAST_MODE)
+	#define AST_I2C_13_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_13_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#endif
+
+#if defined(GROUP_AST1070_COMPANION)
+#if defined(CONFIG_SPX_FEATURE_I2C14_FAST_MODE)
+	#define AST_I2C_14_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C14_FAST_MODE_PLUS)
+	#define AST_I2C_14_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_14_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C15_FAST_MODE)
+	#define AST_I2C_15_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C15_FAST_MODE_PLUS)
+	#define AST_I2C_15_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_15_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C16_FAST_MODE)
+	#define AST_I2C_16_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C16_FAST_MODE_PLUS)
+	#define AST_I2C_16_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_16_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C17_FAST_MODE)
+	#define AST_I2C_17_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C17_FAST_MODE_PLUS)
+	#define AST_I2C_17_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_17_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C18_FAST_MODE)
+	#define AST_I2C_18_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C18_FAST_MODE_PLUS)
+	#define AST_I2C_18_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_18_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C19_FAST_MODE)
+	#define AST_I2C_19_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C19_FAST_MODE_PLUS)
+	#define AST_I2C_19_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_19_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C20_FAST_MODE)
+	#define AST_I2C_20_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C20_FAST_MODE_PLUS)
+	#define AST_I2C_20_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_20_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C21_FAST_MODE)
+	#define AST_I2C_21_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C21_FAST_MODE_PLUS)
+	#define AST_I2C_21_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_21_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if (CONFIG_SPX_FEATURE_NUM_BMC_COMPANION_DEVICES >= 2)
+#if defined(CONFIG_SPX_FEATURE_I2C22_FAST_MODE)
+	#define AST_I2C_22_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C22_FAST_MODE_PLUS)
+	#define AST_I2C_22_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_22_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C23_FAST_MODE)
+	#define AST_I2C_23_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C23_FAST_MODE_PLUS)
+	#define AST_I2C_23_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_23_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C24_FAST_MODE)
+	#define AST_I2C_24_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C24_FAST_MODE_PLUS)
+	#define AST_I2C_24_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_24_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C25_FAST_MODE)
+	#define AST_I2C_25_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C25_FAST_MODE_PLUS)
+	#define AST_I2C_25_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_25_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C26_FAST_MODE)
+	#define AST_I2C_26_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C26_FAST_MODE_PLUS)
+	#define AST_I2C_26_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_26_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C27_FAST_MODE)
+	#define AST_I2C_27_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C27_FAST_MODE_PLUS)
+	#define AST_I2C_27_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_27_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C28_FAST_MODE)
+	#define AST_I2C_28_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C28_FAST_MODE_PLUS)
+	#define AST_I2C_28_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_28_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#if defined(CONFIG_SPX_FEATURE_I2C29_FAST_MODE)
+	#define AST_I2C_29_CLOCK			CLOCK_AC_1_VAL_400K
+#elif defined(CONFIG_SPX_FEATURE_I2C29_FAST_MODE_PLUS)
+	#define AST_I2C_29_CLOCK			CLOCK_AC_1_VAL_1000K
+#else
+	#define AST_I2C_29_CLOCK			CLOCK_AC_1_VAL_100K
+#endif
+#endif /* CONFIG_SPX_FEATURE_NUM_BMC_COMPANION_DEVICES >= 2 */
+#endif
+
+// I2C Bus Speed Modes
+#define I2C_BUS_SPEED_MODE_STANDARD     100
+#define I2C_BUS_SPEED_MODE_FAST         400
+
+#define AST_DEFAULT_NUM_PULSES     ( 10 )          /* i2c recovery pulses number */
+
+#define DEFAULT_CLOCK_AC_2_VAL			0x0
+#define DEFAULT_BUF_CONTROL_VAL			0x0000
+
+#define I2C_GLOBAL_CONTROL_REG		   (0x0C)
+#define I2C_FUNCTION_CONTROL_REG       (0x00)
+#define I2C_CLOCK_AC_1_CONTROL_REG     (0x04)
+#define I2C_CLOCK_AC_2_CONTROL_REG     (0x08)
+#define I2C_INTR_CONTROL_REG		   (0x0C)	
+#define I2C_INTR_STATUS_REG			   (0x10)
+#define I2C_CMD_STATUS_REG			   (0x14)	 
+#define I2C_SLAVE_ADDR_REG  		   (0x18)
+#define I2C_BUF_CONTROL_REG  		   (0x1C)
+#define I2C_DATA_REG        		   (0x20)
+#if !defined(SOC_AST3100)
+#define I2C_DMA_MODE_CONTROL_REG	   (0x24)
+#define I2C_DMA_MODE_STATUS_REG	   	   (0x28)
+#endif
+#define GENERAL_STATUS_REG			   (0xFF)	 
+#define AS_SIGNAL_RECEIVED  		   (0xffffffff)
+#define INTR_ENABLE_MASK		   (0xFF)	
+
+/* I2C Device Base Offsets */
+#define AST_I2C_GLOBAL_BASE		AST_I2C_BASE
+#define AST_I2C_DEV_1_BASE		(AST_I2C_GLOBAL_BASE + 0x40)
+#define AST_I2C_DEV_2_BASE		(AST_I2C_DEV_1_BASE  + 0x40)
+#define AST_I2C_DEV_3_BASE		(AST_I2C_DEV_2_BASE  + 0x40)
+#define AST_I2C_DEV_4_BASE		(AST_I2C_DEV_3_BASE  + 0x40)
+#define AST_I2C_DEV_5_BASE		(AST_I2C_DEV_4_BASE  + 0x40)
+#define AST_I2C_DEV_6_BASE		(AST_I2C_DEV_5_BASE  + 0x40)
+#define AST_I2C_DEV_7_BASE		(AST_I2C_DEV_6_BASE  + 0x40)
+#if defined(GROUP_AST2300) || defined(GROUP_AST2300_PLUS) || defined(GROUP_AST2500) || defined(GROUP_AST1070_COMPANION)
+#define AST_I2C_DEV_8_BASE		(AST_I2C_DEV_7_BASE  + 0x140)
+#define AST_I2C_DEV_9_BASE		(AST_I2C_DEV_8_BASE  + 0x40)
+#endif
+#if defined(GROUP_AST2300_PLUS) || defined(GROUP_AST2500) || defined(GROUP_AST1070_COMPANION)
+#define AST_I2C_DEV_10_BASE		(AST_I2C_DEV_9_BASE  + 0x40)
+#define AST_I2C_DEV_11_BASE		(AST_I2C_DEV_10_BASE + 0x40)
+#define AST_I2C_DEV_12_BASE		(AST_I2C_DEV_11_BASE + 0x40)
+#define AST_I2C_DEV_13_BASE		(AST_I2C_DEV_12_BASE + 0x40)
+#define AST_I2C_DEV_14_BASE		(AST_I2C_DEV_13_BASE + 0x40)
+#endif
+#if defined(GROUP_AST1070_COMPANION)
+#define AST_BMCCC0_I2C_GLOBAL_BASE		AST_BMCCC_I2C_BASE(0)
+#define AST_I2C_DEV_15_BASE		(AST_BMCCC0_I2C_GLOBAL_BASE + 0x40)
+#define AST_I2C_DEV_16_BASE		(AST_I2C_DEV_15_BASE + 0x40)
+#define AST_I2C_DEV_17_BASE		(AST_I2C_DEV_16_BASE + 0x40)
+#define AST_I2C_DEV_18_BASE		(AST_I2C_DEV_17_BASE + 0x40)
+#define AST_I2C_DEV_19_BASE		(AST_I2C_DEV_18_BASE + 0x40)
+#define AST_I2C_DEV_20_BASE		(AST_I2C_DEV_19_BASE + 0x40)
+#define AST_I2C_DEV_21_BASE		(AST_I2C_DEV_20_BASE + 0x40)
+#define AST_I2C_DEV_22_BASE		(AST_I2C_DEV_21_BASE + 0x40)
+#if (CONFIG_SPX_FEATURE_NUM_BMC_COMPANION_DEVICES >= 2)
+#define AST_BMCCC1_I2C_GLOBAL_BASE		AST_BMCCC_I2C_BASE(1)
+#define AST_I2C_DEV_23_BASE		(AST_BMCCC1_I2C_GLOBAL_BASE + 0x40)
+#define AST_I2C_DEV_24_BASE		(AST_I2C_DEV_23_BASE + 0x40)
+#define AST_I2C_DEV_25_BASE		(AST_I2C_DEV_24_BASE + 0x40)
+#define AST_I2C_DEV_26_BASE		(AST_I2C_DEV_25_BASE + 0x40)
+#define AST_I2C_DEV_27_BASE		(AST_I2C_DEV_26_BASE + 0x40)
+#define AST_I2C_DEV_28_BASE		(AST_I2C_DEV_27_BASE + 0x40)
+#define AST_I2C_DEV_29_BASE		(AST_I2C_DEV_28_BASE + 0x40)
+#define AST_I2C_DEV_30_BASE		(AST_I2C_DEV_29_BASE + 0x40)
+#endif /* CONFIG_SPX_FEATURE_NUM_BMC_COMPANION_DEVICES >= 2 */
+#endif
+
+#if defined(GROUP_AST2300)
+#define AST_I2C_POLLBUF_BASE		(AST_I2C_GLOBAL_BASE  + 0x200)
+#elif defined(GROUP_AST2300_PLUS)
+#define AST_I2C_POLLBUF_BASE		(AST_I2C_GLOBAL_BASE  + 0x800)
+#endif
+
+/* Bits */
+/* I2CG0C: Global Control Register : Init = 0 */
+#define ENABLE_SRAM_BUFFER							(1 << 0)
+
+/* I2CD00: Function Control Register : Init = 0x00200000 */
+#define ENABLE_MASTER_FUNC							(1 << 0)
+#define ENABLE_SLAVE_FUNC							(1 << 1)
+#define ENABLE_SLAVE_GENERAL_CALL_ADDR				(1 << 2)
+#define ENABLE_SMBUS_ARP_HOST_ADDR_RESP				(1 << 3)
+#define ENABLE_SMBUS_ALERT_RESP_ADDR				(1 << 4)
+#define ENABLE_SMBUS_DEFAULT_ADDR					(1 << 5)
+#if defined(SOC_AST3100)	
+//AST3100 supports high speed (3.4Mbps). Can only act as Master in this mode. Should use buffer. 
+#define ENABLE_FAST_MODE						    (1 << 6)
+#else
+#define ENABLE_P2P_MODE								(1 << 6)
+#endif
+#define ENABLE_SCL_ACTIVE_PULL_HIGH					(1 << 7)
+#define ENABLE_SDA_ACTIVE_PULL_HIGH					(1 << 8)
+#if !defined(SOC_AST3100)	//These bits are reserved in AST3100
+#define ENABLE_LSB_FIRST							(1 << 9)
+#define ENABLE_RECV_FAST_MODE						(1 << 10)
+#else
+#define ENABLE_SCL_DIRECT_DRIVE_MODE				(1 << 14)
+#define DISABLE_MULTI_MASTER_CAPABILITY				(1 << 15)
+#define ENABLE_MASTER_AUTO_RECOVERY					(1 << 16)
+#endif
+#define BUFFER_SELECTION_PAGE_MASK                  0x00700000
+#define BUFFER_SELECTION_PAGE_0						(0 << 20)
+#define BUFFER_SELECTION_PAGE_1						(1 << 20)
+#define BUFFER_SELECTION_PAGE_2						(2 << 20)
+#define BUFFER_SELECTION_PAGE_3						(3 << 20)
+#define BUFFER_SELECTION_PAGE_4						(4 << 20)
+#define BUFFER_SELECTION_PAGE_5						(5 << 20)
+#define BUFFER_SELECTION_PAGE_6						(6 << 20)
+#define BUFFER_SELECTION_PAGE_7						(7 << 20)
+
+/* I2CD0C: Interrupt Control Register : Init = 0 */
+#define ENABLE_TX_DONE_WITH_ACK_INTR				(1 << 0)
+#define ENABLE_TX_DONE_WITH_NACK_INTR				(1 << 1)
+#define ENABLE_RX_DONE_INTR							(1 << 2)
+#define ENABLE_ARBITRATION_LOST_INTR				(1 << 3)
+#define ENABLE_STOP_CONDITION_RECVD_INTR			(1 << 4)
+#define ENABLE_ABNORMAL_START_STOP_RECVD_INTR		(1 << 5)
+#define ENABLE_SCL_LOW_TIMEOUT_INTR					(1 << 6)
+#define ENABLE_SLAVE_ADDR_MATCH_INTR				(1 << 7)
+#if !defined(SOC_AST3100)	//These bits are reserved in AST3100
+#define ENABLE_GENERAL_CALL_ADDR_MATCH_INTR			(1 << 8)
+#define ENABLE_SMBUS_DEFAULT_ADDR_MATCH_INTR		(1 << 9)
+#define ENABLE_SMBUS_ALERT_RESP_ADDR_MATCH_INTR		(1 << 10)
+#define ENABLE_SMBUS_ARP_HOST_ADDR_MATCH_INTR		(1 << 11)
+#endif
+#define ENABLE_SMBUS_DEVICE_ALERT_INTR				(1 << 12)
+#define ENABLE_BUS_RECOVER_DONE_INTR				(1 << 13)
+#if defined(SOC_AST3100)
+#define ENABLE_SDA_LOW_TIMEOUT_INTR					(1 << 14)
+#endif
+
+/* I2CD10: Interrupt Status Register : Init = 0 */
+#define TX_DONE_WITH_ACK							(1 << 0)
+#define TX_DONE_WITH_NACK							(1 << 1)
+#define RX_DONE										(1 << 2)
+#define MASTER_ARBITRATION_LOST						(1 << 3)
+#define STOP_DETECTED								(1 << 4)
+#define ABNORMAL_START_STOP_DETECTED				(1 << 5)
+#define SCL_LOW_TIMEOUT								(1 << 6)
+#define SLAVE_ADDR_MATCH							(1 << 7)
+#define GENERAL_CALL_ADDR_MATCH						(1 << 8)
+#define SMBUS_DEFAULT_ADDR_MATCH					(1 << 9)
+#define SMBUS_ALERT_RESP_ADDR_MATCH					(1 << 10)
+#define SMBUS_ARP_HOST_ADDR_MATCH					(1 << 11)
+#define SMBUS_DEVICE_ALERT							(1 << 12)
+#define BUS_RECOVER_DONE							(1 << 13)
+#if defined(SOC_AST3100)
+#define SDA_LOW_TIMEOUT								(1 << 14)
+#endif
+
+/* I2CD14: Command-Status Register : Init = 0 */
+#define MASTER_START								(1 << 0)
+#define MASTER_TRANSMIT								(1 << 1)
+#define SLAVE_TRANSMIT								(1 << 2)
+#define MASTER_RECEIVE								(1 << 3)
+#define MASTER_SLAVE_RECEIVE_COMMAND_LAST			(1 << 4)
+#define MASTER_STOP									(1 << 5)
+#define ENABLE_MASTER_SLAVE_TX_DATA_BUF				(1 << 6)
+#define ENABLE_MASTER_SLAVE_RX_DATA_BUF				(1 << 7)
+#if !defined(SOC_AST3100)	//These bits are reserved in AST3100
+#define ENABLE_MASTER_SLAVE_TX_DMA_BUF				(1 << 8)
+#define ENABLE_MASTER_SLAVE_RX_DMA_BUF				(1 << 9)
+#endif
+#define ENABLE_SMBUS_SLAVE_ALERT					(1 << 10)
+#define ENABLE_BUS_RECOVER_COMMAND					(1 << 11)
+#define BUS_BUSY_STATUS								(1 << 16)
+#define SAMPLE_SDA_LINE								(1 << 17)
+#define SAMPLE_SCL_LINE								(1 << 18)
+#define TRANSFER_MODE_STATE							(0x0F << 19)
+#define TRANSFER_MODE_TIMING_STATE					(0x03 << 23)
+#define SCL_O_STATE									(1 << 25)
+#define SCL_OE_STATE								(1 << 26)
+#define SDA_O_STATE									(1 << 27)
+#define SDA_OE_STATE								(1 << 28)
+//#define SCL_O										(1 << 12)
+#define SCL_OE										(1 << 13)
+//#define SDA_O										(1 << 14)
+#define SDA_OE										(1 << 15)
+
+#define SDA_HIGH	(1 << 14)
+#define SDA_LOW		~(1 << 14)
+
+#define SCL_HIGH	(1 << 12)
+#define SCL_LOW		~(1 << 12)
+
+#define BUF_BASE_ADDR_PTR							(0x3F << 0)
+#define TX_DATA_BUF_END_ADDR						(0xFF << 8)
+#define RX_DATA_BUF_END_ADDR						(0xFF << 16)
+#define REAL_RX_DATA_BUF_ADDR_PTR					(0xFF << 24)
+
+#define READ_RX_DATA								(0xFF << 8)
+#define READ_TX_DATA								(0xFF << 0)
+
+#define DMA_BUF_SIZE								(0xFFF << 0)
+#define DMA_BUF_BASE_ADDR							(0xFFFF << 12)
+
+#define DMA_LAST_ACCESSED_ADDR						(0xFFF << 12)
+
+/* I2CD1C: Pool Buffer Ctrl Register : Init = X */
+#define POOLBUFF_CTRL_TX_END_ADDR_SHIFT      8
+
+/* Init Values */
+#define	DEFAULT_FUNCTION_VAL						(ENABLE_MASTER_FUNC | ENABLE_SLAVE_FUNC)
+
+#define ENABLE_INTS_VAL								(ENABLE_TX_DONE_WITH_ACK_INTR  			| \
+													 ENABLE_TX_DONE_WITH_NACK_INTR 			| \
+													 ENABLE_RX_DONE_INTR		   			| \
+													 ENABLE_ARBITRATION_LOST_INTR  			| \
+													 ENABLE_STOP_CONDITION_RECVD_INTR		| \
+													 ENABLE_ABNORMAL_START_STOP_RECVD_INTR	| \
+													 ENABLE_SCL_LOW_TIMEOUT_INTR			| \
+													 ENABLE_SLAVE_ADDR_MATCH_INTR)
+
+#define CLR_ALL_INTS_VAL							 0xFFFFFFFF
+
+#define AS_INTR_MASK								 0x1FFF	
+#define AS_JUST_STOP								(MASTER_STOP)
+#define AS_STOP_XMIT								(MASTER_STOP | MASTER_TRANSMIT)
+#define AS_XMIT_TX									(MASTER_TRANSMIT)
+#define AS_STOP_RCV									(MASTER_STOP | MASTER_SLAVE_RECEIVE_COMMAND_LAST | MASTER_RECEIVE)
+#define AS_XMIT_RCV									(MASTER_RECEIVE)
+#define AS_START					 				(MASTER_START | MASTER_TRANSMIT)
+
+#define I2C_BB										(BUS_BUSY_STATUS)
+#define I2C_CLRSAM									(SLAVE_ADDR_MATCH)
+#define I2C_SDA										(SAMPLE_SDA_LINE)
+#define I2C_SCL										(SAMPLE_SCL_LINE)
+#define I2C_ACK										(TX_DONE_WITH_ACK)
+#define I2C_NACK									(TX_DONE_WITH_NACK)
+#define I2C_CLRAL									(MASTER_ARBITRATION_LOST)
+#define I2C_DT										(TX_DONE_WITH_ACK)
+#define I2C_DR										(RX_DONE)
+#define	I2C_I2CRST									(~ENABLE_MASTER_FUNC | ~ENABLE_SLAVE_FUNC)
+#define I2C_CLRSTOP									(STOP_DETECTED)
+
+
+//#define JM_RECOVERY 1
+
+
+u32 i2c_as_read_reg( int bus, u32 offset );
+void i2c_as_write_reg( int bus, u32 value, u32 offset );
+u32 i2c_as_read_global_reg( u32 offset );
+void i2c_as_write_global_reg( u32 value, u32 offset );
+
+void i2c_as_reset(int bus);
+void i2c_init_hardware(int bus);
+void i2c_init_slave_address(int bus);
+int i2c_wait_for_bus_free(int bus);
+int i2c_bus_recovery(int bus);
+int i2c_as_disable_slave(int bus);
+int i2c_as_enable_slave(int bus);
+void i2c_as_disable_all_interrupts(int bus);
+
+
+
+#if (LINUX_VERSION_CODE >=  KERNEL_VERSION(2,6,24)) 
+irqreturn_t i2c_handler( int this_irq, void *dev_id);
+#if defined(GROUP_AST1070_COMPANION)
+irqreturn_t bmccc0_i2c_handler( int this_irq, void *dev_id);
+#if (CONFIG_SPX_FEATURE_NUM_BMC_COMPANION_DEVICES >= 2)
+irqreturn_t bmccc1_i2c_handler( int this_irq, void *dev_id);
+#endif /* CONFIG_SPX_FEATURE_NUM_BMC_COMPANION_DEVICES >= 2 */
+#endif
+
+#else
+
+irqreturn_t i2c_handler( int this_irq, void *dev_id,struct pt_regs *regs );
+#if defined(GROUP_AST1070_COMPANION)
+irqreturn_t bmccc0_i2c_handler( int this_irq, void *dev_id,struct pt_regs *regs );
+#if (CONFIG_SPX_FEATURE_NUM_BMC_COMPANION_DEVICES >= 2)
+irqreturn_t bmccc1_i2c_handler( int this_irq, void *dev_id,struct pt_regs *regs );
+#endif /* CONFIG_SPX_FEATURE_NUM_BMC_COMPANION_DEVICES >= 2 */
+#endif
+
+#endif
+
+
+
+void i2c_enable_bus(int bus);
+void i2c_disable_bus(int bus);
+void i2c_as_disable_interrupt(int bus, unsigned long mask);
+void i2c_as_enable_interrupt(int bus, unsigned long mask);
+
+int as_master_xfer(struct i2c_adapter *i2c_adap,
+                    struct i2c_msg *msgs, int num );
+int as_smb_xfer( struct i2c_adapter *i2c_adap, u16 addr, unsigned short flags,
+							char read_write, u8 command, int size, union i2c_smbus_data * data);
+
+int as_mctp_recv(struct i2c_adapter *i2c_adap,char *buf);
+int as_slave_recv( struct i2c_adapter *i2c_adap,
+                    char *buf, int num );
+
+int as_smb_host_notify_recv( struct i2c_adapter *i2c_adap,
+                    char *buf, int num );
+
+int i2c_bus_recovery(int bus);
+int as_i2c_bus_recovery(struct i2c_adapter *i2c_adap);
+
+void i2c_as_set_slave( int bus, int slave );
+int i2c_as_get_slave( int bus );
+void i2c_as_reset(int bus);
+int i2c_as_set_speed(int bus, unsigned short speed);
+void i2c_stop_cntlr_reset(void);
+#ifdef JM_RECOVERY
+	int i2c_is_bus_hung(int bus);
+#endif
+
+int as_slave_send( struct i2c_adapter *i2c_adap, char *buf, int num ); 
+void i2c_as_slave_xfer_enable(int bus);
+	
+#endif
+
diff --git a/drivers/i2c/busses/projdef.h b/drivers/i2c/busses/projdef.h
new file mode 100644
index 0000000..94f9286
--- /dev/null
+++ b/drivers/i2c/busses/projdef.h
@@ -0,0 +1,106 @@
+#define CONFIG_SPX_FEATURE_GLOBAL_ENDIAN_LITTLE YES
+#define CONFIG_SPX_FEATURE_GLOBAL_FAILSAFE_WATCHDOG 0x2
+#define CONFIG_SPX_FEATURE_GLOBAL_SUPPORTED_BASES YES
+#define CONFIG_SPX_FEATURE_GLOBAL_FLASH_TYPE_SPI YES
+#define CONFIG_SPX_FEATURE_GLOBAL_FLASH_START 0x20000000
+#define CONFIG_SPX_FEATURE_GLOBAL_FLASH_SIZE 0x2000000
+#define CONFIG_SPX_FEATURE_GLOBAL_ERASE_BLOCK_SIZE 0x10000
+#define CONFIG_SPX_FEATURE_GLOBAL_FLASH_BANKS 0x1
+#define CONFIG_SPX_FEATURE_GLOBAL_USED_FLASH_START 0x20000000
+#define CONFIG_SPX_FEATURE_GLOBAL_USED_FLASH_SIZE 0x2000000
+#define CONFIG_SPX_FEATURE_GLOBAL_UBOOT_MONITOR_SIZE 0x40000
+#define CONFIG_SPX_FEATURE_GLOBAL_UBOOT_ENV_START 0x20040000
+#define CONFIG_SPX_FEATURE_GLOBAL_UBOOT_ENV_SIZE 0x10000
+#define CONFIG_SPX_FEATURE_GLOBAL_MEMORY_START 0x80000000
+#define CONFIG_SPX_FEATURE_GLOBAL_MEMORY_SIZE 0xf000000
+#define CONFIG_SPX_FEATURE_GLOBAL_NIC_COUNT 0x2
+#define CONFIG_SPX_FEATURE_GLOBAL_UBOOT_ENABLE_I2C_BUS 0x3
+#define CONFIG_SPX_FEATURE_LAN_AND_DRAM_TEST_CMD YES
+#define CONFIG_SPX_FEATURE_GLOBAL_SD_SLOT_COUNT 0x1
+#define CONFIG_SPX_FEATURE_GLOBAL_EMMC_FLASH_COUNT 0x0
+#define CONFIG_SPX_FEATURE_GLOBAL_MAX_ADC_CHANNELS 0x10
+#define CONFIG_SPX_FEATURE_GLOBAL_KERNEL_VER3_PLUS_JESSIE YES
+#define CONFIG_SPX_FEATURE_GLOBAL_KERNEL_VER3 YES
+#define CONFIG_SPX_FEATURE_GLOBAL_TARGET_NON_SQUEEZE YES
+#define CONFIG_SPX_FEATURE_GLOBAL_TARGET_JESSIE YES
+#define CONFIG_SPX_FEATURE_GLOBAL_SUPPORTS_PYTHON_2_7 YES
+#define CONFIG_SPX_FEATURE_GLOBAL_BOOTLOADER_DENX YES
+#define CONFIG_SPX_FEATURE_GLOBAL_SYSBASE_EX YES
+#define CONFIG_SPX_FEATURE_GLOBAL_BUSYBOX_EX YES
+#define CONFIG_SPX_FEATURE_GLOBAL_CROSSCC_JESSIE YES
+#define CONFIG_SPX_FEATURE_GLOBAL_SHOW_NEW_BASE_ONLY YES
+#define CONFIG_SPX_FEATURE_KERNEL_VER3_PLUS_JESSIE YES
+#define CONFIG_SPX_FEATURE_GLOBAL_CONSOLE_TTY "ttyS4"
+#define CONFIG_SPX_FEATURE_BAUDRATE_CONSOLE_TTY 0x1c200
+#define CONFIG_SPX_FEATURE_GLOBAL_DEFAULT_SHELL "/usr/local/bin/smash"
+#define CONFIG_SPX_FEATURE_GLOBAL_HOST_PREFIX "AMI"
+#define CONFIG_SPX_FEATURE_GLOBAL_DEFAULT_DOMAINNAME ""
+#define CONFIG_SPX_FEATURE_GLOBAL_DEFAULT_NETWORK_DHCP YES
+#define CONFIG_SPX_FEATURE_FASTER_BOOT_SUPPORT YES
+#define CONFIG_SPX_FEATURE_GLOBAL_UDEV_SUPPORT YES
+#define CONFIG_SPX_FEATURE_PROCESS_MGR_POLLING_INTERVAL 0x6
+#define CONFIG_SPX_FEATURE_IPMI_AMI_OEM_NETFUN_SUPPORT 0x32
+#define CONFIG_SPX_FEATURE_DISABLE_EMPTY_PASSWORD_LOGIN YES
+#define CONFIG_SPX_FEATURE_DELAYED_LAN_RESTART_SUPPORT YES
+#define CONFIG_SPX_FEATURE_PREFIX_IPMICONFIG_FILE_LOCATION_SUPPORT "/conf"
+#define CONFIG_SPX_FEATURE_DELAYED_LAN_RESTART_TIMEOUT 0x5
+#define CONFIG_SPX_FEATURE_IPMI_SUPPORT_SINGLE_PLATFORM YES
+#define CONFIG_SPX_FEATURE_I2C_BUS_DISABLE_MASK 0x0
+#define CONFIG_SPX_FEATURE_NUM_TOTOL_I2C_BUSES 0x8
+#define CONFIG_SPX_FEATURE_I2C_BYTE_MODE YES
+#define CONFIG_SPX_FEATURE_NCSI_AUTO_FAILOVER YES
+#define CONFIG_SPX_FEATURE_NCSI_INTERFACE_NAMES "eth0,eth1,eth2,eth3"
+#define CONFIG_SPX_FEATURE_NCSI_DEFAULT_INTERFACE "eth1"
+#define CONFIG_SPX_FEATURE_NCSI_IPMI_COMMAND_SUPPORT YES
+#define CONFIG_SPX_FEATURE_GLOBAL_VERSION_MGT_SUPPORT YES
+#define CONFIG_SPX_FEATURE_PHY_SUPPORT YES
+#define CONFIG_SPX_FEATURE_SOL_SERIAL_PORT_SHARING_ENABLE YES
+#define CONFIG_SPX_FEATURE_SOL_EXTERNAL_SUPERIO YES
+#define CONFIG_SPX_FEATURE_FASTER_BOOT_SUPPORT_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_15_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_SUPPORTS_PYTHON_2_7_ANY YES
+#define CONFIG_SPX_FEATURE_IPMI_SUPPORT_SINGLE_PLATFORM_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_DEFAULT_NETWORK_DHCP_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_10_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_11_ANY YES
+#define CONFIG_SPX_FEATURE_LAN_AND_DRAM_TEST_CMD_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_13_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_CROSSCC_JESSIE_ANY YES
+#define CONFIG_SPX_FEATURE_SOL_SERIAL_PORT_SHARING_ENABLE_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_ENDIAN_LITTLE_ANY YES
+#define CONFIG_SPX_FEATURE_LMEDIA_IMAGE_DIR_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_16_ANY YES
+#define CONFIG_SPX_FEATURE_PHY_SUPPORT_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_SHOW_NEW_BASE_ONLY_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_5_ANY YES
+#define CONFIG_SPX_FEATURE_NCSI_IPMI_COMMAND_SUPPORT_ANY YES
+#define CONFIG_SPX_FEATURE_DELAYED_LAN_RESTART_SUPPORT_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_1_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_BOOTLOADER_DENX_ANY YES
+#define CONFIG_SPX_FEATURE_DISABLE_EMPTY_PASSWORD_LOGIN_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_UDEV_SUPPORT_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_SUPPORTED_BASES_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_7_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_KERNEL_VER3_PLUS_JESSIE_ANY YES
+#define CONFIG_SPX_FEATURE_SOL_EXTERNAL_SUPERIO_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_6_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_TARGET_JESSIE_ANY YES
+#define CONFIG_SPX_FEATURE_NCSI_AUTO_FAILOVER_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_TARGET_NON_SQUEEZE_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_SYSBASE_EX_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_BUSYBOX_EX_ANY YES
+#define CONFIG_SPX_FEATURE_I2C_BYTE_MODE_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_3_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_DEFAULT_DOMAINNAME_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_4_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_14_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_12_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_VERSION_MGT_SUPPORT_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_KERNEL_VER3_ANY YES
+#define CONFIG_SPX_FEATURE_GLOBAL_FLASH_TYPE_SPI_ANY YES
+#define CONFIG_SPX_FEATURE_SPECIFY_MOUNT_OPTIONS_FOR_SD_PARTITION_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_8_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_2_ANY YES
+#define CONFIG_SPX_FEATURE_INSTANCE_9_ANY YES
+#define CONFIG_SPX_FEATURE_KERNEL_VER3_PLUS_JESSIE_ANY YES
+#define CONFIG_SPX_FEATURE_MDS_VERSION 12.0.1
diff --git a/include/linux/amii2c.h b/include/linux/amii2c.h
new file mode 100644
index 0000000..8868b4e
--- /dev/null
+++ b/include/linux/amii2c.h
@@ -0,0 +1,40 @@
+#define MAX_IPMB_MSG_SIZE  128
+#define MAX_I2C_ADAPTERS   16
+
+
+//extern u8 i2c_smbus_msg_pec(u8 pec, struct i2c_msg *msg);
+//extern void i2c_smbus_add_pec(struct i2c_msg *msg);
+//extern int i2c_smbus_check_pec(u8 cpec, struct i2c_msg *msg);
+//2 extern static u8 i2c_smbus_msg_pec(u8 pec, struct i2c_msg *msg);
+//2 extern static inline void i2c_smbus_add_pec(struct i2c_msg *msg);
+//2 extern static int i2c_smbus_check_pec(u8 cpec, struct i2c_msg *msg);
+
+
+/*              AMI Recovery Begin                */
+extern int i2c_recovery_event(void);
+
+/*
+    * i2c_recovery is the structure used to specify the recovery parameters for the bus
+     */
+#define DEFAULT_NUM_PULSES     16
+#define DEFAULT_PULSE_PERIOD       5
+#define DEFAULT_FREQ           100000
+#define ENABLE_SMBUS_RESET     1
+#define DISABLE_SMBUS_RESET        0
+#define ENABLE_CLOCK_PULSE     1
+#define DISABLE_CLOCK_PULSE        0
+#define ENABLE_FORCE_STOP      1
+#define DISABLE_FORCE_STOP     0
+#define ENABLE_RECOVERY            1
+#define DISABLE_RECOVERY       0   /* Recovery should not be done on multi-master bus - Disable Recovery */
+typedef struct
+{
+    int enable_recovery;
+    int is_smbus_reset_enabled;
+    int is_generate_clock_pulses_enabled;
+    int is_force_stop_enabled;
+    int num_clock_pulses;
+    int frequency;
+} bus_recovery_info_T;
+
+/*               AMI Recovery End                 */
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 44ad14e..9490e3f 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -36,6 +36,10 @@
 #include <linux/swab.h>		/* for swab16 */
 #include <uapi/linux/i2c.h>
 
+#if IS_ENABLED(CONFIG_AMII2C)
+#include "amii2c.h"
+#endif
+
 extern struct bus_type i2c_bus_type;
 extern struct device_type i2c_adapter_type;
 extern struct device_type i2c_client_type;
@@ -56,6 +60,11 @@ typedef int (*i2c_slave_cb_t)(struct i2c_client *, enum i2c_slave_event, u8 *);
 struct module;
 struct property_entry;
 
+#if IS_ENABLED(CONFIG_AMII2C)
+/* Extended IOCTLs -implemented in i2c-core */
+extern int i2c_ioctl(struct i2c_adapter *adap, unsigned long cmd, unsigned long arg);
+#endif
+
 #if IS_ENABLED(CONFIG_I2C)
 /*
  * The master routines are the ones normally used to transmit data to devices
@@ -538,6 +547,20 @@ struct i2c_algorithm {
 	int (*reg_slave)(struct i2c_client *client);
 	int (*unreg_slave)(struct i2c_client *client);
 #endif
+
+#if IS_ENABLED(CONFIG_AMII2C)
+   /* AMI Extended Functions */
+   /* i2c recovery */
+   int (*i2c_recovery) (struct i2c_adapter *adap);
+
+   /* Slave Receive and Slave Send Functions */
+   int (*slave_send)(struct i2c_adapter *adap , char *data ,int size);
+   int (*slave_recv)(struct i2c_adapter *adap , char *data ,int size);
+   int (*smb_slave_recv)(struct i2c_adapter *adap , char *data , int size);
+
+   /* Extended IOCTL Calls */
+   int (*i2c_hw_ioctl)(struct i2c_adapter *adap, unsigned long cmd , unsigned long arg);
+#endif   
 };
 
 /**
diff --git a/include/uapi/linux/amii2c-dev.h b/include/uapi/linux/amii2c-dev.h
new file mode 100644
index 0000000..c0d9019
--- /dev/null
+++ b/include/uapi/linux/amii2c-dev.h
@@ -0,0 +1,13 @@
+/* Extended IOCTLS - Implemented in i2c-core and hardware */
+#define I2C_SLAVEREAD      0x0750  /* Perform Slave Read   */
+#define I2C_SLAVEWRITE     0x0751  /* Perform Slave Write  */
+#define I2C_SET_HOST_ADDR  0x0752  /* Set Slave Address of the Controller */
+#define I2C_GET_HOST_ADDR  0x0753  /* Get Slave Address of the Controller */
+#define I2C_SET_REC_INFO   0x0754  /* Set Recovery Parameters */
+#define I2C_GET_REC_INFO   0x0755  /* Get Recovery Parameters */
+#define I2C_RESET      0x0756  /* Reset Controller */
+#define SMBUS_HOST_NOTIFY  0x0757 /* Perform SMBus Host Notify Protocol */
+#define I2C_SET_SPEED      0x0758  /* Set I2C Bus Speed */
+#define I2C_GET_LINK_STATE      0x0759  /* Get the Status of Clk/Data pin*/
+#define I2C_BUS_TEST            0x0850  /* Perform the I2C Bus test*/
+#define I2C_MCTP_READ           0x0851  /* Perform MCTP Pkt Read*/
diff --git a/include/uapi/linux/i2c-dev.h b/include/uapi/linux/i2c-dev.h
index 85f8047..bcf97e0 100644
--- a/include/uapi/linux/i2c-dev.h
+++ b/include/uapi/linux/i2c-dev.h
@@ -27,6 +27,10 @@
 #include <linux/types.h>
 #include <linux/compiler.h>
 
+#if IS_ENABLED(CONFIG_AMII2C)
+#include "amii2c-dev.h"
+#endif
+
 /* /dev/i2c-X ioctl commands.  The ioctl's parameter is always an
  * unsigned long, except for:
  *	- I2C_FUNCS, takes pointer to an unsigned long
-- 
2.7.4
--- a/drivers/i2c/busses/i2c-aspeed.c	2019-08-11 10:22:39.202912312 -0400
+++ b/drivers/i2c/busses/i2c-aspeed.c	2019-08-11 10:37:49.666704024 -0400
@@ -27,6 +27,14 @@
 #include <linux/reset.h>
 #include <linux/slab.h>
 
+#if IS_ENABLED(CONFIG_AMII2C)
+#include <linux/uaccess.h>
+#include <linux/i2c-dev.h> //For IOCTL defines
+#include <linux/delay.h>
+#include "i2c-data.h"
+#include "i2c-hardware.h"
+#endif /* CONFIG_AMII2C */
+
 /* I2C Register */
 #define ASPEED_I2C_FUN_CTRL_REG				0x00
 #define ASPEED_I2C_AC_TIMING_REG1			0x04
@@ -112,6 +120,211 @@
 /* 0x18 : I2CD Slave Device Address Register   */
 #define ASPEED_I2CD_DEV_ADDR_MASK			GENMASK(6, 0)
 
+#if IS_ENABLED(CONFIG_AMII2C)
+#define IO_ADDRESS(x)  (x - 0x1e600000 + 0xF8000000) //from Aspeed SDK kernel 4.9
+#define AST_I2C_DEV_G_VA_BASE       IO_ADDRESS(AST_I2C_GLOBAL_BASE)
+#define AST_I2C_GLOBAL_BASE     AST_I2C_BASE //in i2c-hardware.h
+#define AST_I2C_BASE                   0x1E78A000 //in arch/arm/include/asm/soc-ast/hwmap.h
+#endif /* CONFIG_AMII2C */
+
+#if IS_ENABLED(CONFIG_AMII2C)
+static u32 i2c_as_io_base_global = AST_I2C_DEV_G_VA_BASE;
+extern struct i2c_as_data as_data_ptr[BUS_COUNT];
+extern int as_get_recovery_info (int bus, bus_recovery_info_T* info);
+extern int as_set_recovery_info (int bus, bus_recovery_info_T* info);
+extern int i2c_bus_test (int bus, i2c_bus_test_T* info);
+
+static int slave_addr[ BUS_COUNT ] =
+{
+#if (BUS_COUNT>=1)
+        DEFAULT_SLAVE_0,
+#endif
+#if (BUS_COUNT>=2)
+        DEFAULT_SLAVE_1,
+#endif
+#if (BUS_COUNT>=3)
+        DEFAULT_SLAVE_2,
+#endif
+#if (BUS_COUNT>=4)
+        DEFAULT_SLAVE_3,
+#endif
+#if (BUS_COUNT>=5)
+        DEFAULT_SLAVE_4,
+#endif
+#if (BUS_COUNT>=6)
+        DEFAULT_SLAVE_5,
+#endif
+#if (BUS_COUNT>=7)
+        DEFAULT_SLAVE_6,
+#endif
+#if (BUS_COUNT>=8)
+        DEFAULT_SLAVE_7,
+#endif
+#if (BUS_COUNT>=9)
+        DEFAULT_SLAVE_8,
+#endif
+#if (BUS_COUNT>=10)
+        DEFAULT_SLAVE_9,
+#endif
+#if (BUS_COUNT>=11)
+        DEFAULT_SLAVE_10,
+#endif
+#if (BUS_COUNT>=12)
+        DEFAULT_SLAVE_11,
+#endif
+#if (BUS_COUNT>=13)
+        DEFAULT_SLAVE_12,
+#endif
+#if (BUS_COUNT>=14)
+        DEFAULT_SLAVE_13,
+#endif
+#if (BUS_COUNT>=15)
+        DEFAULT_SLAVE_14,
+#endif
+#if (BUS_COUNT>=16)
+        DEFAULT_SLAVE_15,
+#endif
+#if (BUS_COUNT>=17)
+        DEFAULT_SLAVE_16,
+#endif
+#if (BUS_COUNT>=18)
+        DEFAULT_SLAVE_17,
+#endif
+#if (BUS_COUNT>=19)
+        DEFAULT_SLAVE_18,
+#endif
+#if (BUS_COUNT>=20)
+        DEFAULT_SLAVE_19,
+#endif
+#if (BUS_COUNT>=21)
+        DEFAULT_SLAVE_20,
+#endif
+#if (BUS_COUNT>=22)
+        DEFAULT_SLAVE_21,
+#endif
+#if (BUS_COUNT>=23)
+        DEFAULT_SLAVE_22,
+#endif
+#if (BUS_COUNT>=24)
+        DEFAULT_SLAVE_23,
+#endif
+#if (BUS_COUNT>=25)
+        DEFAULT_SLAVE_24,
+#endif
+#if (BUS_COUNT>=26)
+        DEFAULT_SLAVE_25,
+#endif
+#if (BUS_COUNT>=27)
+        DEFAULT_SLAVE_26,
+#endif
+#if (BUS_COUNT>=28)
+        DEFAULT_SLAVE_27,
+#endif
+#if (BUS_COUNT>=29)
+        DEFAULT_SLAVE_28,
+#endif
+#if (BUS_COUNT>=30)
+        DEFAULT_SLAVE_29,
+#endif
+};
+
+static int ast_i2c_clock1[ BUS_COUNT ] =
+{
+#if (BUS_COUNT>=1)
+        AST_I2C_0_CLOCK,
+#endif
+#if (BUS_COUNT>=2)
+        AST_I2C_1_CLOCK,
+#endif
+#if (BUS_COUNT>=3)
+        AST_I2C_2_CLOCK,
+#endif
+#if (BUS_COUNT>=4)
+        AST_I2C_3_CLOCK,
+#endif
+#if (BUS_COUNT>=5)
+        AST_I2C_4_CLOCK,
+#endif
+#if (BUS_COUNT>=6)
+        AST_I2C_5_CLOCK,
+#endif
+#if (BUS_COUNT>=7)
+        AST_I2C_6_CLOCK,
+#endif
+#if (BUS_COUNT>=8)
+        AST_I2C_7_CLOCK,
+#endif
+#if (BUS_COUNT>=9)
+        AST_I2C_8_CLOCK,
+#endif
+#if (BUS_COUNT>=10)
+        AST_I2C_9_CLOCK,
+#endif
+#if (BUS_COUNT>=11)
+        AST_I2C_10_CLOCK,
+#endif
+#if (BUS_COUNT>=12)
+        AST_I2C_11_CLOCK,
+#endif
+#if (BUS_COUNT>=13)
+        AST_I2C_12_CLOCK,
+#endif
+#if (BUS_COUNT>=14)
+        AST_I2C_13_CLOCK,
+#endif
+#if (BUS_COUNT>=15)
+        AST_I2C_14_CLOCK,
+#endif
+#if (BUS_COUNT>=16)
+        AST_I2C_15_CLOCK,
+#endif
+#if (BUS_COUNT>=17)
+        AST_I2C_16_CLOCK,
+#endif
+#if (BUS_COUNT>=18)
+        AST_I2C_17_CLOCK,
+#endif
+#if (BUS_COUNT>=19)
+        AST_I2C_18_CLOCK,
+#endif
+#if (BUS_COUNT>=20)
+        AST_I2C_19_CLOCK,
+#endif
+#if (BUS_COUNT>=21)
+        AST_I2C_20_CLOCK,
+#endif
+#if (BUS_COUNT>=22)
+        AST_I2C_21_CLOCK,
+#endif
+#if (BUS_COUNT>=23)
+        AST_I2C_22_CLOCK,
+#endif
+#if (BUS_COUNT>=24)
+        AST_I2C_23_CLOCK,
+#endif
+#if (BUS_COUNT>=25)
+        AST_I2C_24_CLOCK,
+#endif
+#if (BUS_COUNT>=26)
+        AST_I2C_25_CLOCK,
+#endif
+#if (BUS_COUNT>=27)
+        AST_I2C_26_CLOCK,
+#endif
+#if (BUS_COUNT>=28)
+        AST_I2C_27_CLOCK,
+#endif
+#if (BUS_COUNT>=29)
+        AST_I2C_28_CLOCK,
+#endif
+#if (BUS_COUNT>=30)
+        AST_I2C_29_CLOCK,
+#endif
+};
+
+#endif /* CONFIG_AMII2C */
+
+
 enum aspeed_i2c_master_state {
 	ASPEED_I2C_MASTER_INACTIVE,
 	ASPEED_I2C_MASTER_PENDING,
@@ -163,6 +376,30 @@
 #endif /* CONFIG_I2C_SLAVE */
 };
 
+#if IS_ENABLED(CONFIG_AMII2C)
+void i2c_init_hardware_(struct aspeed_i2c_bus *i2c_bus);
+
+static inline u32
+ast_i2c_read(struct aspeed_i2c_bus *i2c_bus, u32 reg)
+{
+#if 0 //default is 0
+        u32 val = readl(i2c_bus->base + reg);
+        printk("R : reg %x , val: %x \n", reg, val);
+        return val;
+#else
+        return readl(i2c_bus->base + reg);
+#endif
+}
+
+static inline void
+ast_i2c_write(struct aspeed_i2c_bus *i2c_bus, u32 val, u32 reg)
+{
+//      dev_dbg(i2c_bus->dev, "ast_i2c_write : val: %x , reg : %x \n",val,reg);
+        //printk("ast_i2c_write : val: %x , reg : %x \n",val,reg);
+        writel(val, i2c_bus->base + reg);
+}
+#endif /* CONFIG_AMII2C */
+
 static int aspeed_i2c_reset(struct aspeed_i2c_bus *bus);
 
 static int aspeed_i2c_recover_bus(struct aspeed_i2c_bus *bus)
@@ -764,6 +1001,322 @@
 }
 #endif /* CONFIG_I2C_SLAVE */
 
+#if IS_ENABLED(CONFIG_AMII2C)
+void i2c_as_set_slave_(int bus, int slave, struct aspeed_i2c_bus *i2c_bus)
+{
+    /* Save the save address for future uses */
+    slave_addr[ bus ] = slave >> 1;
+
+    /* set slave mode */
+    ast_i2c_write(i2c_bus, slave >> 1, I2C_SLAVE_ADDR_REG);
+}
+
+void i2c_as_reset_(struct aspeed_i2c_bus *i2c_bus)
+{
+        u32 ctrl_bits;
+
+        /* Disable Both Master and Slave function when resetting device */
+    ctrl_bits = ast_i2c_read(i2c_bus, I2C_FUNCTION_CONTROL_REG);
+    ctrl_bits &= ~( ENABLE_MASTER_FUNC |ENABLE_SLAVE_FUNC);
+    ast_i2c_write(i2c_bus, ctrl_bits, I2C_FUNCTION_CONTROL_REG);
+    udelay(100);
+        i2c_init_hardware_(i2c_bus);
+}
+
+void i2c_as_disable_all_interrupts_(struct aspeed_i2c_bus *i2c_bus)
+{
+        ast_i2c_write(i2c_bus,0,I2C_INTR_CONTROL_REG);
+}
+
+void i2c_as_write_global_reg( u32 value, u32 offset )
+{
+  iowrite32( value, (void * __iomem)i2c_as_io_base_global + offset );
+}
+
+#if 0 //temp solution: disable SSIF
+void i2c_as_slave_xfer_enable_(struct aspeed_i2c_bus *i2c_bus)
+{
+                u32 ctrl_bits;
+
+                /* Disable Master function  , Set buffer page selection = 0*/
+                ctrl_bits = ast_i2c_read(i2c_bus,I2C_FUNCTION_CONTROL_REG);
+                ctrl_bits &= ~( ENABLE_MASTER_FUNC);
+                ctrl_bits |= ENABLE_SLAVE_FUNC;
+                #if defined(GROUP_AST2300_PLUS)
+                ctrl_bits &= ~( BUFFER_SELECTION_PAGE_MASK);
+                ctrl_bits |= BUFFER_SELECTION_PAGE_0;
+                #endif
+                ast_i2c_write( i2c_bus,ctrl_bits,I2C_FUNCTION_CONTROL_REG);
+                udelay(100);
+
+         /* clear interrups */
+            i2c_as_disable_all_interrupts_(i2c_bus);
+                ast_i2c_write (i2c_bus, CLR_ALL_INTS_VAL, I2C_INTR_STATUS_REG);
+
+                as_data_ptr[i2c_bus->adap.nr].SlaveTX_Enable = 1;
+                as_data_ptr[i2c_bus->adap.nr].TX_len = 0;
+                as_data_ptr[i2c_bus->adap.nr].TX_index = 0;
+
+                as_data_ptr[i2c_bus->adap.nr].MasterRX_len = 0;
+                as_data_ptr[i2c_bus->adap.nr].MasterRX_index = 0;
+
+                /* Default I2C_BYTE_MODE for GROUP_AST2300 and GROUP_AST2300_PLUS.
+                   For testing buffer transfer mode of SSIF, init ssif tx pool buffer. */
+                //as_data_ptr[bus].pool_buff_base = AST_I2C_POLLBUF_VA_BASE;
+
+                /* Enable interrupts */
+        #if 0
+                i2c_as_write_reg (bus,  ENABLE_TX_DONE_WITH_ACK_INTR                    | \
+                                           ENABLE_TX_DONE_WITH_NACK_INTR                        | \
+                                           ENABLE_RX_DONE_INTR|
+                                                                ENABLE_STOP_CONDITION_RECVD_INTR|
+                                                                ENABLE_ABNORMAL_START_STOP_RECVD_INTR|
+                                                                ENABLE_SLAVE_ADDR_MATCH_INTR,
+                                                                                I2C_INTR_CONTROL_REG);
+        #endif
+                ast_i2c_write (i2c_bus, ENABLE_TX_DONE_WITH_ACK_INTR                    | \
+                                           ENABLE_TX_DONE_WITH_NACK_INTR                        | \
+                                           ENABLE_RX_DONE_INTR|
+                                                                ENABLE_STOP_CONDITION_RECVD_INTR|
+                                                                ENABLE_ABNORMAL_START_STOP_RECVD_INTR|
+                                                                ENABLE_SLAVE_ADDR_MATCH_INTR,
+                                                                                I2C_INTR_CONTROL_REG);
+}
+#endif
+
+void i2c_init_hardware_(struct aspeed_i2c_bus *i2c_bus)
+{
+        /* clear interrups */
+        //i2c_as_disable_all_interrupts(bus);
+        i2c_as_disable_all_interrupts_(i2c_bus);
+
+        /* Set Function Register */
+#ifdef ENABLE_SMBUS_ARP_HOST
+    ast_i2c_write(i2c_bus, ENABLE_MASTER_FUNC | ENABLE_SLAVE_FUNC | ENABLE_SMBUS_ARP_HOST_ADDR_RESP, I2C_FUNCTION_CONTROL_REG);
+#else
+    ast_i2c_write(i2c_bus, ENABLE_MASTER_FUNC | ENABLE_SLAVE_FUNC , I2C_FUNCTION_CONTROL_REG);
+#endif
+
+        /* Set Clock and AC timing Control register 1*/
+    ast_i2c_write(i2c_bus, ast_i2c_clock1[i2c_bus->adap.nr], I2C_CLOCK_AC_1_CONTROL_REG);
+
+        /* Set Clock and AC timing Control register 2*/
+        ast_i2c_write(i2c_bus, DEFAULT_CLOCK_AC_2_VAL, I2C_CLOCK_AC_2_CONTROL_REG );
+
+    /* Set Function Register */
+        ast_i2c_write(i2c_bus, DEFAULT_BUF_CONTROL_VAL, I2C_BUF_CONTROL_REG);
+
+#if !defined(SOC_AST3100)
+#if defined(CONFIG_SPX_FEATURE_I2C_DMA_MODE)
+        /* Enable SRAM Buffer */
+        i2c_as_write_global_reg( ENABLE_SRAM_BUFFER, I2C_GLOBAL_CONTROL_REG);
+#endif
+
+    /* DMA Mode Control Register */
+        ast_i2c_write(i2c_bus, 0, I2C_DMA_MODE_CONTROL_REG);
+#endif
+    /* clear interrups */
+        ast_i2c_write(i2c_bus, CLR_ALL_INTS_VAL, I2C_INTR_STATUS_REG);
+
+        /* Enable interrupts */
+#ifdef ENABLE_SMBUS_ARP_HOST
+#if 0
+        i2c_as_write_reg (bus, ENABLE_TX_DONE_WITH_ACK_INTR                     | \
+                                        ENABLE_TX_DONE_WITH_NACK_INTR                   | \
+                                        ENABLE_RX_DONE_INTR                                             | \
+                                        ENABLE_ARBITRATION_LOST_INTR                    | \
+                                        ENABLE_STOP_CONDITION_RECVD_INTR                | \
+                                        ENABLE_ABNORMAL_START_STOP_RECVD_INTR   | \
+                                        ENABLE_SLAVE_ADDR_MATCH_INTR                    | \
+                                        ENABLE_SCL_LOW_TIMEOUT_INTR                             | \
+                                        ENABLE_SMBUS_ARP_HOST_ADDR_MATCH_INTR ,
+                                        I2C_INTR_CONTROL_REG);
+#endif
+        ast_i2c_write (i2c_bus, ENABLE_TX_DONE_WITH_ACK_INTR                    | \
+                                        ENABLE_TX_DONE_WITH_NACK_INTR                   | \
+                                        ENABLE_RX_DONE_INTR                                             | \
+                                        ENABLE_ARBITRATION_LOST_INTR                    | \
+                                        ENABLE_STOP_CONDITION_RECVD_INTR                | \
+                                        ENABLE_ABNORMAL_START_STOP_RECVD_INTR   | \
+                                        ENABLE_SLAVE_ADDR_MATCH_INTR                    | \
+                                        ENABLE_SCL_LOW_TIMEOUT_INTR                             | \
+                                        ENABLE_SMBUS_ARP_HOST_ADDR_MATCH_INTR ,
+                                        I2C_INTR_CONTROL_REG);
+#else
+#if 0
+        i2c_as_write_reg (bus, ENABLE_TX_DONE_WITH_ACK_INTR                     | \
+                                        ENABLE_TX_DONE_WITH_NACK_INTR                   | \
+                                        ENABLE_RX_DONE_INTR                                             | \
+                                        ENABLE_ARBITRATION_LOST_INTR                    | \
+                                        ENABLE_STOP_CONDITION_RECVD_INTR                | \
+                                        ENABLE_ABNORMAL_START_STOP_RECVD_INTR   | \
+                                        ENABLE_SLAVE_ADDR_MATCH_INTR                    | \
+                                        ENABLE_SCL_LOW_TIMEOUT_INTR     ,
+                                        I2C_INTR_CONTROL_REG);
+#endif
+        ast_i2c_write (i2c_bus, ENABLE_TX_DONE_WITH_ACK_INTR                    | \
+                                        ENABLE_TX_DONE_WITH_NACK_INTR                   | \
+                                        ENABLE_RX_DONE_INTR                                             | \
+                                        ENABLE_ARBITRATION_LOST_INTR                    | \
+                                        ENABLE_STOP_CONDITION_RECVD_INTR                | \
+                                        ENABLE_ABNORMAL_START_STOP_RECVD_INTR   | \
+                                        ENABLE_SLAVE_ADDR_MATCH_INTR                    | \
+                                        ENABLE_SCL_LOW_TIMEOUT_INTR     ,
+                                        I2C_INTR_CONTROL_REG);
+#endif
+#if 0 //temp solution: disable ssif
+        if (as_data_ptr[i2c_bus->adap.nr].SlaveTX_Enable == 1)
+                i2c_as_slave_xfer_enable_(i2c_bus);
+#endif
+}
+
+void i2c_enable_bus_(struct aspeed_i2c_bus *i2c_bus)
+{
+        /* Enable I2C interface */
+#ifdef ENABLE_SMBUS_ARP_HOST
+    ast_i2c_write(i2c_bus, ENABLE_MASTER_FUNC | ENABLE_SLAVE_FUNC | ENABLE_SMBUS_ARP_HOST_ADDR_RESP, I2C_FUNCTION_CONTROL_REG);
+#else
+        ast_i2c_write(i2c_bus, ENABLE_MASTER_FUNC | ENABLE_SLAVE_FUNC , I2C_FUNCTION_CONTROL_REG);
+#endif
+
+#if 0 //temp solution: disable ssif
+        if (as_data_ptr[i2c_bus->adap.nr].SlaveTX_Enable == 1)
+                i2c_as_slave_xfer_enable_(i2c_bus);
+#endif
+}
+
+void i2c_disable_bus_(struct aspeed_i2c_bus *i2c_bus)
+{
+        /* Disable I2C interface */
+        ast_i2c_write(i2c_bus, 0, I2C_FUNCTION_CONTROL_REG);
+}
+
+int i2c_as_set_speed_(struct aspeed_i2c_bus *i2c_bus, unsigned short speed)
+{
+        /* Need to disable the I2C interface before writing to the I2C Control Register */
+        i2c_disable_bus_(i2c_bus);
+
+        switch(speed)
+        {
+                case I2C_BUS_SPEED_MODE_STANDARD: // 100 Kbit/s
+                    ast_i2c_write (i2c_bus, CLOCK_AC_1_VAL_100K, I2C_CLOCK_AC_1_CONTROL_REG);
+                        break;
+
+                case I2C_BUS_SPEED_MODE_FAST:   // 400 Kbit/s
+                    ast_i2c_write (i2c_bus, CLOCK_AC_1_VAL_400K, I2C_CLOCK_AC_1_CONTROL_REG);
+                        break;
+
+                default:
+                        printk("ERROR: I2C-%d: Invalid Speed Mode requested to set.\n", i2c_bus->adap.nr);
+                        return -1;
+        }
+
+        /* Control Register is set. Now enable back the i2c interface */
+        i2c_enable_bus_(i2c_bus);
+        return 0;
+}
+#endif /* CONFIG_AMII2C */
+
+#if IS_ENABLED(CONFIG_AMII2C)
+/* Algorithm level handling of ioctls and other control commands */
+static int
+as_control( struct i2c_adapter *i2c_adap, unsigned long cmd,
+                       unsigned long arg )
+{
+    int retval = 0;
+
+        //bus_recovery_info_T   bus_recovery_info;
+        //i2c_bus_test_T testData;
+        //i2c_link_state_T linkData;
+    //char *tmp;
+
+    struct aspeed_i2c_bus *i2c_bus = i2c_get_adapdata(i2c_adap);
+    int arg_int = (int)arg;
+
+    switch( cmd )
+    {
+        case I2C_SET_HOST_ADDR:
+            i2c_as_set_slave_(i2c_bus->adap.nr, arg_int, i2c_bus);
+            break;
+
+        case I2C_GET_HOST_ADDR:
+            retval = ast_i2c_read(i2c_bus, I2C_SLAVE_ADDR_REG);
+            break;
+
+        case I2C_RESET:
+                        printk("I2C%d: Resetting the controller\n",i2c_bus->adap.nr);
+            /* Reset the controller */
+                i2c_as_reset_(i2c_bus);
+            break;
+
+#if 0
+                case I2C_SET_REC_INFO:
+                        if (copy_from_user(&bus_recovery_info, (void*)arg, sizeof(bus_recovery_info_T)))
+                                return -EFAULT;
+                        if (0 != as_set_recovery_info (i2c_adap->nr, &bus_recovery_info))
+                        {
+                                dev_err (&i2c_adap->dev, "as_control: set recovery info asiled\n");
+                        }
+                        break;
+                case I2C_GET_REC_INFO:
+                        if (0 != as_get_recovery_info (i2c_adap->nr, &bus_recovery_info))
+                        {
+                                dev_err (&i2c_adap->dev, "as_control: get recovery info failed\n");
+                        }
+                        if (copy_to_user((void*)arg, &bus_recovery_info, sizeof(bus_recovery_info_T)))
+                                return -EFAULT;
+                        break;
+#endif
+                case I2C_SET_SPEED:
+                        printk("I2C-%d. Going to set the speed...\n", i2c_bus->adap.nr);
+                        retval = i2c_as_set_speed_(i2c_bus, arg);
+
+                        break;
+#if 0
+                case I2C_GET_LINK_STATE:
+                        linkData.i2cLinkState = as_data_ptr[i2c_adap->nr].i2c_link_state;
+                        if (copy_to_user((void*)arg, &linkData, sizeof(i2c_link_state_T)))
+                                retval  =  -EFAULT;
+
+                        break;
+
+                case I2C_BUS_TEST:
+                        if  (copy_from_user (&testData, (void*) arg, sizeof(i2c_bus_test_T)))
+                                return -EFAULT;
+
+                        if (0 != i2c_bus_test (i2c_adap->nr, &testData))
+                        {
+                                dev_err (&i2c_adap->dev, "i2c-ioctl: I2C_BUS_TEST failed\n");
+                        }
+                        if (copy_to_user((void*)arg, &testData, sizeof(i2c_bus_test_T)))
+                                retval =  -EFAULT;
+                        break;
+
+        case I2C_MCTP_READ:
+            tmp = kmalloc(MAX_MCTP_MSG_SIZE,GFP_KERNEL);
+            if(!tmp)
+                return -ENOMEM;
+            retval = as_mctp_recv(i2c_adap,tmp);
+            if(retval > 0)
+                retval = copy_to_user((char*)arg,tmp,retval)? -EFAULT:retval;
+            kfree(tmp);
+            break;
+
+        case ENABLE_SSIF:
+                //printk("I2C%d: Enable slave xfer for SSIF\n",i2c_adap->nr);
+            i2c_as_slave_xfer_enable(i2c_adap->nr);
+                    break;
+#endif
+        default:
+            dev_err( &i2c_adap->dev, "as_control: Unknown ioctl command\n" );
+            retval = -ENOTTY;
+    }
+
+    return( retval );
+}
+#endif /* CONFIG_AMII2C */
+
+
 static const struct i2c_algorithm aspeed_i2c_algo = {
 	.master_xfer	= aspeed_i2c_master_xfer,
 	.functionality	= aspeed_i2c_functionality,
@@ -771,6 +1324,13 @@
 	.reg_slave	= aspeed_i2c_reg_slave,
 	.unreg_slave	= aspeed_i2c_unreg_slave,
 #endif /* CONFIG_I2C_SLAVE */
+#if IS_ENABLED(CONFIG_AMII2C)
+    //.smb_slave_recv = as_smb_host_notify_recv,
+    .i2c_hw_ioctl = as_control,
+    //.slave_recv = as_slave_recv,
+    //.slave_send = as_slave_send,
+    //.i2c_recovery = as_i2c_bus_recovery,
+#endif /* CONFIG_AMII2C */
 };
 
 static u32 aspeed_i2c_get_clk_reg_val(struct device *dev,
--- a/drivers/i2c/i2c-core-base.c	2019-08-11 10:43:18.425197039 -0400
+++ b/drivers/i2c/i2c-core-base.c	2019-08-11 10:47:40.051999361 -0400
@@ -41,6 +41,10 @@
 
 #include "i2c-core.h"
 
+#if IS_ENABLED(CONFIG_AMII2C)
+#include <linux/i2c-dev.h> //For IOCTL defines
+#endif /* CONFIG_AMII2C */
+
 #define CREATE_TRACE_POINTS
 #include <trace/events/i2c.h>
 
@@ -2051,6 +2055,97 @@
 }
 EXPORT_SYMBOL(i2c_transfer);
 
+#if IS_ENABLED(CONFIG_AMII2C)
+/* AMI Extended IOCTLS */
+int i2c_ioctl(struct i2c_adapter * adap,unsigned long cmd, unsigned long arg)
+{
+        switch (cmd)
+        {
+                case I2C_SLAVEREAD:
+                        /* IMPORTANT NOTE:
+                           Why we don't lock slave xfer functions?
+
+                           All SPX compliant i2c hardware should never access hardware.
+                           Instead they sleep for slave buffers gets filled up.
+
+                           Since they does access hardware, locking is not needed to
+                           prevent master and slave access to hardware. Also if we lock
+                           the master xfers cannot be done as the slave routines does not
+                           return if if does not have slave data.
+                        */
+                        if (adap->algo->slave_recv)
+                        {
+                                char *tmp;
+                                int ret;
+                                tmp = kmalloc(MAX_IPMB_MSG_SIZE,GFP_KERNEL);
+                                if (!tmp)
+                                        return -ENOMEM;
+                                ret = adap->algo->slave_recv(adap,tmp,MAX_IPMB_MSG_SIZE);
+                                if (ret > 0)
+                                        ret = copy_to_user((char *)arg,tmp,ret)?-EFAULT:ret;
+                                kfree(tmp);
+                                return ret;
+                        }
+                        break;
+
+                case SMBUS_HOST_NOTIFY:
+                        if (adap->algo->smb_slave_recv)
+                        {
+                                char    *tmp;
+                                int     ret = 0;
+                                int     count = 0;
+                                tmp = kmalloc(MAX_IPMB_MSG_SIZE, GFP_KERNEL);
+                                if (tmp==NULL)
+                                        return -ENOMEM;
+
+                                ret = adap->algo->smb_slave_recv(adap,tmp,count);
+                                if (ret > 0)
+                                        ret = copy_to_user((unsigned char __user *)arg,tmp,ret)?-EFAULT:ret;
+#ifdef DEBUG
+                                printk (KERN_DEBUG "ret value returned in slave receive call = 0x%x\n", ret);
+#endif
+                                kfree(tmp);
+                                return ret;
+                        }
+                        break;
+
+                /* UNTESTED CODE :We don't have any scenario to test slave writes */
+#if 1
+                case I2C_SLAVEWRITE:
+                        if (adap->algo->slave_send)
+                        {
+                                char *tmp;
+                                int ret;
+                                tmp = kmalloc(MAX_IPMB_MSG_SIZE,GFP_KERNEL);
+                                if (!tmp)
+                                        return -ENOMEM;
+                                ret = copy_from_user(tmp,(char *)arg,MAX_IPMB_MSG_SIZE)?-EFAULT:0;
+                                if (ret == -EFAULT)
+                                {
+                                        kfree(tmp);
+                                        return -EFAULT;
+                                }
+                                return adap->algo->slave_send(adap,tmp,MAX_IPMB_MSG_SIZE);
+                        }
+                        break;
+#endif
+                default:
+                        if (adap->algo->i2c_hw_ioctl)
+                                return adap->algo->i2c_hw_ioctl(adap,cmd,arg);
+                        break;
+        }
+
+        /* NOTE:  returning a fault code here could cause trouble
+         * in buggy userspace code.  Some old kernel bugs returned
+         * zero in this case, and userspace code might accidentally
+         * have depended on that bug.
+         */
+        return -ENOTTY;
+}
+
+EXPORT_SYMBOL(i2c_ioctl);
+#endif /* CONFIG_AMII2C */
+
 /**
  * i2c_transfer_buffer_flags - issue a single I2C message transferring data
  *			       to/from a buffer
--- a/drivers/i2c/i2c-dev.c	2019-08-11 10:43:25.561164345 -0400
+++ b/drivers/i2c/i2c-dev.c	2019-08-11 10:52:15.614738782 -0400
@@ -478,6 +478,10 @@
 		client->adapter->timeout = msecs_to_jiffies(arg * 10);
 		break;
 	default:
+		#if IS_ENABLED(CONFIG_AMII2C)
+        	/* Call the core ioctl (AMI extended)functions */                                                                                                                                                        return i2c_ioctl(client->adapter,cmd,arg);
+        	#endif /* CONFIG_I2C_AMII2C */
+
 		/* NOTE:  returning a fault code here could cause trouble
 		 * in buggy userspace code.  Some old kernel bugs returned
 		 * zero in this case, and userspace code might accidentally
